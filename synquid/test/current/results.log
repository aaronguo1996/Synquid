add :: x:Nat -> y:Nat -> {Int|_v == x + y}
add = \x . \y . 
    if x <= 0
      then y
      else add (dec x) (inc y)

null :: xs:List a -> {Bool|_v == (len xs == 0)}
null = \xs . 
  match xs with
    Nil -> true
    Cons x7 x8 -> false

elem :: x:a -> xs:List a -> {Bool|_v == (x in elems xs)}
elem = \x . \xs . 
    match xs with
      Nil -> false
      Cons x9 x10 -> 
        if x9 == x
          then true
          else elem x x10

stutter :: xs:List a -> {List a|len _v == 2 * len xs}
stutter = \xs . 
  match xs with
    Nil -> xs
    Cons x7 x8 -> Cons x7 (Cons x7
                             (stutter x8))

replicate :: n:Nat -> x:a -> {List a|len _v == n}
replicate = \n . \x . 
    if n <= 0
      then Nil
      else Cons x (replicate (dec n)
                     x)

append :: xs:List a -> ys:List a -> {List a|len _v == len xs + len ys && elems _v == elems xs + elems ys}
append = \xs . \ys . 
    match xs with
      Nil -> ys
      Cons x13 x14 -> append x14 (Cons
                                    x13 ys)

concat :: xss:ListOfLists a -> {List a|len _v == sumLen xss}
concat = \xss . 
  match xss with
    Nil2 -> Nil
    Cons2 x11 x12 -> append x11
                       (concat x12)

take :: n:Nat -> xs:{List a|len _v >= n} -> {List a|len _v == n}
./List-Take.sq:18: Error:
  Cannot find sufficiently strong refinements
  when checking zero ::
  {Int|_v >= 0 && (_v >= 0 && _v < n)}
  in
  \n . \xs . 
      match zero with

