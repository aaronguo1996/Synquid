add :: x:Nat -> y:Nat -> {Int|_v == x + y}
add = \x . \y . add y (dec (inc
                              x))

null :: xs:List a -> {Bool|_v == (len xs == 0)}
null = \xs . 
  match xs with
    Nil -> true
    Cons x7 x8 -> false

elem :: x:a -> xs:List a -> {Bool|_v == (x in elems xs)}
elem = \x . \xs . 
    match xs with
      Nil -> false
      Cons x9 x10 -> 
        if x9 == x
          then true
          else elem x x10

stutter :: xs:List a -> {List a|len _v == 2 * len xs}
stutter = \xs . 
  match xs with
    Nil -> xs
    Cons x7 x8 -> Cons x7 (Cons x7
                             (stutter x8))

replicate :: n:Nat -> x:a -> {List a|len _v == n}
./List-Replicate.sq:18: Error:
  Cannot find sufficiently strong refinements
  when checking zero ::
  {Int|_v >= 0 && (_v >= 0 && _v < n)}
  in
  \n . \x . 
      match replicate zero ?? with

append :: xs:List a -> ys:List a -> {List a|len _v == len xs + len ys && elems _v == elems xs + elems ys}
append = \xs . \ys . 
    match xs with
      Nil -> ys
      Cons x17 x18 -> append x18 (Cons
                                    x17 ys)

concat :: xss:ListOfLists a -> {List a|len _v == sumLen xss}
concat = \xss . 
  match xss with
    Nil2 -> Nil
    Cons2 x13 x14 -> append x13
                       (concat x14)

take :: n:Nat -> xs:{List a|len _v >= n} -> {List a|len _v == n}
take = \n . \xs . 
    if 0 != n
      then 
        match xs with
          Nil -> error
          Cons x9 x10 -> Cons x9 (take
                                    (dec n) x10)
      else Nil

drop :: n:Nat -> xs:{List a|len _v >= n} -> {List a|len _v == len xs - n}
drop = \n . \xs . 
    if 0 != n
      then 
        match xs with
          Nil -> error
          Cons x9 x10 -> drop (dec n) x10
      else xs

delete :: x:a -> xs:List a -> {List a|elems _v == elems xs - [x]}
delete = \x . \xs . 
    match xs with
      Nil -> xs
      Cons x11 x12 -> 
        if x11 == x
          then delete x x12
          else Cons x11 (delete x x12)

map :: f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
./List-Map.sq:10: Error:
  Cannot find sufficiently strong refinements
  when checking Nil ::
  {List a|len _v >= 0 && len _v < len xs}
  in
  \f . \xs . 
      match map f0 Nil with

zipWith :: f:(arg1:a -> arg0:b -> c) -> xs:List a -> ys:{List b|len _v == len xs} -> {List c|len _v == len xs}
zipWith = \f . \xs . \ys . 
      match xs with
        Nil -> Nil
        Cons x19 x20 -> 
          match ys with
            Nil -> error
            Cons x23 x24 -> Cons (f x19 x23)
                              (zipWith f x20 x24)

zip :: xs:List a -> ys:{List b|len _v == len xs} -> {List Pair a b|len _v == len xs}
./List-Zip.sq:13: Error:
  Cannot find sufficiently strong refinements
  when checking Nil ::
  {List a|len _v >= 0 && len _v < len xs}
  in
  \xs . \ys . 
      match zip Nil ?? with

toNat :: xs:List Int -> {List Nat|len _v == len xs}
toNat = \xs . 
  let f0 = \x11 . 
      if x11 <= 0
        then neg x11
        else neg (neg x11) in
  map f0 xs

