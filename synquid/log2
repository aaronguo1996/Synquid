Checking error in
error
Adding constraint nodesOf |- Int <: {Int|False} ()
Typing Constraints
nodesOf |- Int <: {Int|False} ()
Type assignment
Simple Constraints
nodesOf |- Int <: {Int|False} ()
Pred assignment
After process simple constraints
nodesOf |- Int <: {Int|False} ()
Constraints
  True ==> False
QMap
Candidates (1)
  0: [] (0 1)
Chosen candidate: 0: [] (0 1)
Invalid Constraint: True ==> False
Strengthening: True ==> False
Instantiated axioms:
All assumptions:
True
RHS: False
assumption True
mustHave True
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
error
Adding constraint graph, nodesOf |- (match) M0
Adding constraint graph, nodesOf |- C0
Checking error in
\graph . error
Adding constraint graph, nodesOf C0, M0 |- {Int|graph == graph} <: {Int|False} ()
Typing Constraints
graph, nodesOf C0, M0 |- {Int|graph == graph} <: {Int|False} ()
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
Type assignment
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf C0, M0 |- {Int|graph == graph} <: {Int|False} ()
Pred assignment
After process simple constraints
graph, nodesOf C0, M0 |- {Int|graph == graph} <: {Int|False} ()
Constraints
  C0 && (M0 && (graph == graph && size graph >= 0)) ==> False
QMap
  C0 -> {}
  M0 -> {}
Candidates (1)
  0: [C0 -> {}, M0 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}, M0 -> {}] (0 1)
Invalid Constraint: C0 && (M0 && (graph == graph && size graph >= 0)) ==> False
Strengthening: C0 && (M0 && (graph == graph && size graph >= 0)) ==> False
Instantiated axioms:
All assumptions:
graph == graph, size graph >= 0
RHS: False
assumption True
mustHave graph == graph && size graph >= 0
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\graph . error
Looking for type {List Int|elems _v == vertices graph}
Trying graph
Checking graph :: {List Int|elems _v == vertices graph} in
\graph . ??
Adding constraint graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph ::
{List Int|elems _v == vertices graph}
in
\graph . graph
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A0|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List Int|elems _v == vertices graph} in
\graph . ??
Adding constraint graph, nodesOf C0, M0 |- {List {A0|False}|_v == (Nil)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- {List {A0|False}|_v == (Nil)} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {Int|U0}
graph, nodesOf C0, M0 |- {List|_v == (Nil)} <: {List|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- {Int|False} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf C0, M0 |- {List|elems _v == []} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf C0, M0 |- {List|elems _v == []} <: {List|elems _v == vertices graph} ()
Constraints
  C0 && (M0 && (elems _v == [] && size graph >= 0)) ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}, M0 -> {}, U0 -> {}] (0 1)
Invalid Constraint: C0 && (M0 && (elems _v == [] && size graph >= 0)) ==> elems _v == vertices graph
Strengthening: C0 && (M0 && (elems _v == [] && size graph >= 0)) ==> elems _v == vertices graph
Instantiated axioms:
All assumptions:
elems _v == [], size graph >= 0
RHS: elems _v == vertices graph
assumption elems _v == [] && size graph >= 0
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Nil ::
{List Int|elems _v == vertices graph}
in
\graph . Nil
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A0|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {List Int|elems _v == vertices graph} in
\graph . ??
Adding constraint graph, nodesOf C0, M0 |- {Edges {A0|False}|_v == (NoEdge)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- {Edges {A0|False}|_v == (NoEdge)} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge ::
{List Int|elems _v == vertices graph}
in
\graph . NoEdge
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Graph ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x1:UnweightedGraph A0 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:UnweightedGraph A0 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH {a|False} PRODUCING {a|U0}
Type assignment
A0 -> {a|U0}
Typing Constraints
Type assignment
A0 -> {a|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {a|U0}
graph, nodesOf C0, M0 |- {List|False} <: List ()
graph, nodesOf C0, M0 |- {Int|False} <: Int ()
graph, nodesOf C0, M0 |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf C0, M0 |- {a|False} <: {a|U0} ()
X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf C0, M0 |- Int <: Int ()
graph, nodesOf, x1 C0, M0 |- {List|elems _v == vertices x1} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1 C0, M0 |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1 C0, M0 |- {List|elems _v == vertices x1} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && (elems _v == vertices graph && (elems _v == vertices x1 && (size graph >= 0 && (size x1 >= 0 && (size x1 >= 0 && size x1 < size graph))))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Trying graph
Checking graph :: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf ??
Adding constraint graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> {a|U0}
Simple Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- a <: {a|U0} ()
Pred assignment
After process simple constraints
graph, nodesOf C0, M0 |- a <: {a|U0} ()
graph, nodesOf C0, M0 |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
Constraints
  C0 && (M0 && (_v == graph && size graph >= 0)) ==> size _v >= 0 && size _v < size graph
  C0 && M0 ==> U0
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (2 1)
Chosen candidate: 0: [C0 -> {}, M0 -> {}, U0 -> {}] (2 1)
Invalid Constraint: C0 && (M0 && (_v == graph && size graph >= 0)) ==> size _v >= 0 && size _v < size graph
Strengthening: C0 && (M0 && (_v == graph && size graph >= 0)) ==> size _v >= 0 && size _v < size graph
Instantiated axioms:
All assumptions:
_v == graph, size graph >= 0
RHS: size _v >= 0 && size _v < size graph
assumption _v == graph && size graph >= 0
mustHave !(size _v >= 0 && size _v < size graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking graph ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf graph
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A1|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf ??
Adding constraint graph, nodesOf C0, M0 |- {List {A1|False}|_v == (Nil)} <: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- {List {A1|False}|_v == (Nil)} <: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Nil ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf Nil
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A1|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf ??
Adding constraint graph, nodesOf C0, M0 |- {Edges {A1|False}|_v == (NoEdge)} <: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- {Edges {A1|False}|_v == (NoEdge)} <: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf NoEdge
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {Int|U0}
X0, X1, graph, nodesOf C0, M0 |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {Int|U0} <: Int ()
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1, x2 C0, M0 |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && ([_v -> x1]U0 && (_v == (Cons x1 x2) && (elems _v == vertices graph && (len x2 >= 0 && size graph >= 0)))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Trying graph
Checking graph :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: A0 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . Cons graph ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A1|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {List {A1|False}|_v == (Nil)} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {List {A1|False}|_v == (Nil)} <: A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Nil :: Int in
\graph . Cons Nil ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A1|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {Edges {A1|False}|_v == (NoEdge)} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {Edges {A1|False}|_v == (NoEdge)} <: A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . Cons NoEdge ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . MoreEdge ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Graph ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x1:UnweightedGraph A0 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:UnweightedGraph A0 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH {a|False} PRODUCING {a|U0}
Type assignment
A0 -> {a|U0}
Typing Constraints
Type assignment
A0 -> {a|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {a|U0}
graph, nodesOf C0, M0 |- {List|False} <: List ()
graph, nodesOf C0, M0 |- {Int|False} <: Int ()
graph, nodesOf C0, M0 |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf C0, M0 |- {a|False} <: {a|U0} ()
X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf C0, M0 |- Int <: Int ()
graph, nodesOf, x1 C0, M0 |- {List|elems _v == vertices x1} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1 C0, M0 |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1 C0, M0 |- {List|elems _v == vertices x1} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && (elems _v == vertices graph && (elems _v == vertices x1 && (size graph >= 0 && (size x1 >= 0 && (size x1 >= 0 && size x1 < size graph))))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
Typing Constraints
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
Simple Constraints
graph, nodesOf |- {a|U1}
X1, graph, nodesOf C0, M0 |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf C0, M0 |- {a|U1} <: {a|U0} ()
graph, nodesOf, x2 C0, M0 |- {UnweightedGraph|_v == (Graph x2)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, M0 |- {a|U1} /\ {a|U0} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf C0, M0 |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2 C0, M0 |- {a|U1} /\ {a|U0} ()
graph, nodesOf, x2 C0, M0 |- {UnweightedGraph|_v == (Graph x2)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf C0, M0 |- {a|U1} <: {a|U0} ()
X1, graph, nodesOf C0, M0 |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C0 && (M0 && U1) ==> U0
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
  U1 -> {}
Checking consistency
  C0 && (M0 && (_v == (Graph x2) && (edgeNum x2 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph)))))
  C0 && (M0 && (U0 && U1))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Trying graph
Checking graph :: Edges A1 in
\graph . nodesOf (Graph ??)
Adding constraint graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: Edges A1 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . nodesOf (Graph graph)
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A2|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A1 in
\graph . nodesOf (Graph ??)
Adding constraint graph, nodesOf C0, M0 |- {List {A2|False}|_v == (Nil)} <: Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- {List {A2|False}|_v == (Nil)} <: Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . nodesOf (Graph Nil)
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A2|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A1 in
\graph . nodesOf (Graph ??)
Adding constraint graph, nodesOf C0, M0 |- {Edges {A2|False}|_v == (NoEdge)} <: Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- {Edges {A2|False}|_v == (NoEdge)} <: Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
A2 -> {a|U2}
Typing Constraints
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
A2 -> {a|U2}
Simple Constraints
graph, nodesOf |- {a|U2}
graph, nodesOf C0, M0 |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf C0, M0 |- {a|False} <: {a|U1} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (3 0)
Synthesized argument NoEdge of type {Edges {A2|False}|_v == (NoEdge)}
Checking Graph
           NoEdge :: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf ??
Adding constraint graph, nodesOf C0, M0 |- {UnweightedGraph A1|_v == (Graph (NoEdge))} <: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph A1|_v == (Graph (NoEdge))} <: {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
A2 -> {a|U2}
Simple Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph|_v == (Graph (NoEdge))} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- {a|U1} <: {a|U0} ()
Pred assignment
addSplitConstraint graph, nodesOf C0, M0 |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf C0, M0 |- {a|U1} <: {a|U0} ()
graph, nodesOf C0, M0 |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C0 && (M0 && (size _v == edgeNum (NoEdge) && size graph >= 0)) ==> size _v < size graph && size _v >= 0
  C0 && (M0 && U1) ==> U0
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (3 1)
Chosen candidate: 0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (3 1)
Invalid Constraint: C0 && (M0 && (size _v == edgeNum (NoEdge) && size graph >= 0)) ==> size _v < size graph && size _v >= 0
Strengthening: C0 && (M0 && (size _v == edgeNum (NoEdge) && size graph >= 0)) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum (NoEdge) == 0, nodeSet (NoEdge) == []
All assumptions:
edgeNum (NoEdge) == 0, size _v == edgeNum (NoEdge), nodeSet (NoEdge) == [], size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption edgeNum (NoEdge) == 0 && (size _v == edgeNum (NoEdge) && (nodeSet (NoEdge) == [] && size graph >= 0))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Graph NoEdge)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x2:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (nodesOf ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (MoreEdge ??
                    ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Edge ?? ?? ??)
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {Int|U0}
X0, X1, graph, nodesOf C0, M0 |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {Int|U0} <: Int ()
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1, x2 C0, M0 |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && ([_v -> x1]U0 && (_v == (Cons x1 x2) && (elems _v == vertices graph && (len x2 >= 0 && size graph >= 0)))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Trying graph
Checking graph :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: A0 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . Cons graph ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A1|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {List {A1|False}|_v == (Nil)} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {List {A1|False}|_v == (Nil)} <: A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Nil :: Int in
\graph . Cons Nil ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A1|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {Edges {A1|False}|_v == (NoEdge)} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {Edges {A1|False}|_v == (NoEdge)} <: A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . Cons NoEdge ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . MoreEdge ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {Int|U0}
X0, X1, graph, nodesOf C0, M0 |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {Int|U0} <: Int ()
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1, x2 C0, M0 |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && ([_v -> x1]U0 && (_v == (Cons x1 x2) && (elems _v == vertices graph && (len x2 >= 0 && size graph >= 0)))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)}
Trying Graph
Checking Graph :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'UnweightedGraph (A1)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . Cons (Graph ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . Cons (nodesOf ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . Cons (MoreEdge ?? ??)
           ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . MoreEdge ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Graph ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x1:UnweightedGraph A0 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:UnweightedGraph A0 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH {a|False} PRODUCING {a|U0}
Type assignment
A0 -> {a|U0}
Typing Constraints
Type assignment
A0 -> {a|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {a|U0}
graph, nodesOf C0, M0 |- {List|False} <: List ()
graph, nodesOf C0, M0 |- {Int|False} <: Int ()
graph, nodesOf C0, M0 |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf C0, M0 |- {a|False} <: {a|U0} ()
X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf C0, M0 |- Int <: Int ()
graph, nodesOf, x1 C0, M0 |- {List|elems _v == vertices x1} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1 C0, M0 |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1 C0, M0 |- {List|elems _v == vertices x1} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && (elems _v == vertices graph && (elems _v == vertices x1 && (size graph >= 0 && (size x1 >= 0 && (size x1 >= 0 && size x1 < size graph))))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
Typing Constraints
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
Simple Constraints
graph, nodesOf |- {a|U1}
X1, graph, nodesOf C0, M0 |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf C0, M0 |- {a|U1} <: {a|U0} ()
graph, nodesOf, x2 C0, M0 |- {UnweightedGraph|_v == (Graph x2)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, M0 |- {a|U1} /\ {a|U0} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf C0, M0 |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2 C0, M0 |- {a|U1} /\ {a|U0} ()
graph, nodesOf, x2 C0, M0 |- {UnweightedGraph|_v == (Graph x2)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf C0, M0 |- {a|U1} <: {a|U0} ()
X1, graph, nodesOf C0, M0 |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C0 && (M0 && U1) ==> U0
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
  U1 -> {}
Checking consistency
  C0 && (M0 && (_v == (Graph x2) && (edgeNum x2 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph)))))
  C0 && (M0 && (U0 && U1))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A2 -> {UnweightedGraph A2|_v == (Graph x3)}
Trying Graph
Checking Graph :: X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??))
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A2 -> {UnweightedGraph A2|_v == (Graph x3)} <: X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A2 -> {UnweightedGraph A2|_v == (Graph x3)} /\ X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edges A2 -> {UnweightedGraph A2|_v == (Graph x3)} /\ X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:Edges A2 -> {UnweightedGraph A2|_v == (Graph x3)} <: X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X2:_ -> Edges a in
\graph . nodesOf (Graph (Graph
                           ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x3:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??))
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A2
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X2:_ -> Edges a in
\graph . nodesOf (Graph (nodesOf
                           ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??
                           ??))
Adding constraint graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . nodesOf (Graph (Cons ??
                           ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??
                           ??))
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
A2 -> {a|U2}
Typing Constraints
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
A2 -> {a|U2}
Simple Constraints
graph, nodesOf |- {a|U2}
X2, X3, graph, nodesOf C0, M0 |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf C0, M0 |- {a|U2} <: {a|U1} ()
graph, nodesOf, x3, x4 C0, M0 |- {Edges|_v == (MoreEdge x3 x4)} /\ Edges ()
graph, nodesOf, x3, x4 C0, M0 |- {a|U2} /\ {a|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x3, x4 C0, M0 |- {a|U2} /\ {a|U1} ()
X2, X3, graph, nodesOf C0, M0 |- {a|U2} <: {a|U1} ()
Constraints
  C0 && (M0 && U2) ==> U1
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C0 && (M0 && (U1 && U2))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying graph
Checking graph :: Edge A2 in
\graph . nodesOf (Graph
                    (MoreEdge ?? ??))
Adding constraint graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: Edge A2 ()
Typing Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: Edge A2 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . nodesOf (Graph
                    (MoreEdge graph ??))
Adding constraint graph, nodesOf |- A3
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A3|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A2 in
\graph . nodesOf (Graph
                    (MoreEdge ?? ??))
Adding constraint graph, nodesOf C0, M0 |- {List {A3|False}|_v == (Nil)} <: Edge A2 ()
Typing Constraints
graph, nodesOf C0, M0 |- {List {A3|False}|_v == (Nil)} <: Edge A2 ()
graph, nodesOf |- A3
UNIFY A3 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . nodesOf (Graph
                    (MoreEdge Nil ??))
Adding constraint graph, nodesOf |- A3
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A3|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A2 in
\graph . nodesOf (Graph
                    (MoreEdge ?? ??))
Adding constraint graph, nodesOf C0, M0 |- {Edges {A3|False}|_v == (NoEdge)} <: Edge A2 ()
Typing Constraints
graph, nodesOf C0, M0 |- {Edges {A3|False}|_v == (NoEdge)} <: Edge A2 ()
graph, nodesOf |- A3
UNIFY A3 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . nodesOf (Graph
                    (MoreEdge NoEdge ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??
                           ?? ??))
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . nodesOf (Graph (Edge ??
                           ?? ??))
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x2:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (nodesOf ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (MoreEdge ??
                    ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Edge ?? ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (MoreEdge ??
                    ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Edge ?? ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Edge ?? ?? ??)
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {Int|U0}
X0, X1, graph, nodesOf C0, M0 |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {Int|U0} <: Int ()
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1, x2 C0, M0 |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && ([_v -> x1]U0 && (_v == (Cons x1 x2) && (elems _v == vertices graph && (len x2 >= 0 && size graph >= 0)))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Trying graph
Checking graph :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: A0 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . Cons graph ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A1|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {List {A1|False}|_v == (Nil)} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {List {A1|False}|_v == (Nil)} <: A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Nil :: Int in
\graph . Cons Nil ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A1|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {Edges {A1|False}|_v == (NoEdge)} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {Edges {A1|False}|_v == (NoEdge)} <: A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . Cons NoEdge ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . MoreEdge ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {Int|U0}
X0, X1, graph, nodesOf C0, M0 |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {Int|U0} <: Int ()
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1, x2 C0, M0 |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && ([_v -> x1]U0 && (_v == (Cons x1 x2) && (elems _v == vertices graph && (len x2 >= 0 && size graph >= 0)))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)}
Trying Graph
Checking Graph :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'UnweightedGraph (A1)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . Cons (Graph ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . Cons (nodesOf ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . Cons (MoreEdge ?? ??)
           ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . MoreEdge ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {Int|U0}
X0, X1, graph, nodesOf C0, M0 |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {Int|U0} <: Int ()
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1, x2 C0, M0 |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && ([_v -> x1]U0 && (_v == (Cons x1 x2) && (elems _v == vertices graph && (len x2 >= 0 && size graph >= 0)))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)}
Trying Graph
Checking Graph :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'UnweightedGraph (A1)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . Cons (Graph ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . Cons (nodesOf ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . Cons (MoreEdge ?? ??)
           ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . Cons (MoreEdge ?? ??)
           ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . MoreEdge ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Graph ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x1:UnweightedGraph A0 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:{UnweightedGraph A0|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x1} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:UnweightedGraph A0 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH {a|False} PRODUCING {a|U0}
Type assignment
A0 -> {a|U0}
Typing Constraints
Type assignment
A0 -> {a|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {a|U0}
graph, nodesOf C0, M0 |- {List|False} <: List ()
graph, nodesOf C0, M0 |- {Int|False} <: Int ()
graph, nodesOf C0, M0 |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf C0, M0 |- {a|False} <: {a|U0} ()
X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf C0, M0 |- Int <: Int ()
graph, nodesOf, x1 C0, M0 |- {List|elems _v == vertices x1} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1 C0, M0 |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1 C0, M0 |- {List|elems _v == vertices x1} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf C0, M0 |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && (elems _v == vertices graph && (elems _v == vertices x1 && (size graph >= 0 && (size x1 >= 0 && (size x1 >= 0 && size x1 < size graph))))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Edges A1 -> {UnweightedGraph A1|_v == (Graph x2)} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
Typing Constraints
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
Simple Constraints
graph, nodesOf |- {a|U1}
X1, graph, nodesOf C0, M0 |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf C0, M0 |- {a|U1} <: {a|U0} ()
graph, nodesOf, x2 C0, M0 |- {UnweightedGraph|_v == (Graph x2)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, M0 |- {a|U1} /\ {a|U0} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf C0, M0 |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2 C0, M0 |- {a|U1} /\ {a|U0} ()
graph, nodesOf, x2 C0, M0 |- {UnweightedGraph|_v == (Graph x2)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf C0, M0 |- {a|U1} <: {a|U0} ()
X1, graph, nodesOf C0, M0 |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C0 && (M0 && U1) ==> U0
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
  U1 -> {}
Checking consistency
  C0 && (M0 && (_v == (Graph x2) && (edgeNum x2 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph)))))
  C0 && (M0 && (U0 && U1))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A2 -> {UnweightedGraph A2|_v == (Graph x3)}
Trying Graph
Checking Graph :: X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??))
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A2 -> {UnweightedGraph A2|_v == (Graph x3)} <: X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A2 -> {UnweightedGraph A2|_v == (Graph x3)} /\ X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edges A2 -> {UnweightedGraph A2|_v == (Graph x3)} /\ X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:Edges A2 -> {UnweightedGraph A2|_v == (Graph x3)} <: X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X2:_ -> Edges a in
\graph . nodesOf (Graph (Graph
                           ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x3:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??))
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A2
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X2:_ -> Edges a in
\graph . nodesOf (Graph (nodesOf
                           ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??
                           ??))
Adding constraint graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . nodesOf (Graph (Cons ??
                           ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??
                           ??))
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
A2 -> {a|U2}
Typing Constraints
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
A2 -> {a|U2}
Simple Constraints
graph, nodesOf |- {a|U2}
X2, X3, graph, nodesOf C0, M0 |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf C0, M0 |- {a|U2} <: {a|U1} ()
graph, nodesOf, x3, x4 C0, M0 |- {Edges|_v == (MoreEdge x3 x4)} /\ Edges ()
graph, nodesOf, x3, x4 C0, M0 |- {a|U2} /\ {a|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x3, x4 C0, M0 |- {a|U2} /\ {a|U1} ()
X2, X3, graph, nodesOf C0, M0 |- {a|U2} <: {a|U1} ()
Constraints
  C0 && (M0 && U2) ==> U1
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C0 && (M0 && (U1 && U2))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying graph
Checking graph :: Edge A2 in
\graph . nodesOf (Graph
                    (MoreEdge ?? ??))
Adding constraint graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: Edge A2 ()
Typing Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: Edge A2 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . nodesOf (Graph
                    (MoreEdge graph ??))
Adding constraint graph, nodesOf |- A3
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A3|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A2 in
\graph . nodesOf (Graph
                    (MoreEdge ?? ??))
Adding constraint graph, nodesOf C0, M0 |- {List {A3|False}|_v == (Nil)} <: Edge A2 ()
Typing Constraints
graph, nodesOf C0, M0 |- {List {A3|False}|_v == (Nil)} <: Edge A2 ()
graph, nodesOf |- A3
UNIFY A3 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . nodesOf (Graph
                    (MoreEdge Nil ??))
Adding constraint graph, nodesOf |- A3
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A3|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A2 in
\graph . nodesOf (Graph
                    (MoreEdge ?? ??))
Adding constraint graph, nodesOf C0, M0 |- {Edges {A3|False}|_v == (NoEdge)} <: Edge A2 ()
Typing Constraints
graph, nodesOf C0, M0 |- {Edges {A3|False}|_v == (NoEdge)} <: Edge A2 ()
graph, nodesOf |- A3
UNIFY A3 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . nodesOf (Graph
                    (MoreEdge NoEdge ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??
                           ?? ??))
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . nodesOf (Graph (Edge ??
                           ?? ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??
                           ??))
Adding constraint graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:A2 -> x4:List A2 -> {List A2|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . nodesOf (Graph (Cons ??
                           ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??
                           ??))
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:Edge A2 -> x4:Edges A2 -> {Edges A2|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
A2 -> {a|U2}
Typing Constraints
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
A2 -> {a|U2}
Simple Constraints
graph, nodesOf |- {a|U2}
X2, X3, graph, nodesOf C0, M0 |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf C0, M0 |- {a|U2} <: {a|U1} ()
graph, nodesOf, x3, x4 C0, M0 |- {Edges|_v == (MoreEdge x3 x4)} /\ Edges ()
graph, nodesOf, x3, x4 C0, M0 |- {a|U2} /\ {a|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x3, x4 C0, M0 |- {a|U2} /\ {a|U1} ()
X2, X3, graph, nodesOf C0, M0 |- {a|U2} <: {a|U1} ()
Constraints
  C0 && (M0 && U2) ==> U1
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C0 && (M0 && (U1 && U2))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Adding constraint graph, nodesOf |- A3
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)}
Trying Graph
Checking Graph :: X4:_ -> Edge A2 in
\graph . nodesOf (Graph
                    (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf C0, M0 |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} <: X4:_ -> Edge A2 ()
Adding constraint graph, nodesOf C0, M0 |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} /\ X4:_ -> Edge A2 ()
Typing Constraints
graph, nodesOf C0, M0 |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} /\ X4:_ -> Edge A2 ()
graph, nodesOf C0, M0 |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} <: X4:_ -> Edge A2 ()
graph, nodesOf |- A3
UNIFY A3 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking Graph ::
X4:_ -> Edge a in
\graph . nodesOf (Graph
                    (MoreEdge (Graph ??) ??))
Adding constraint graph, nodesOf |- A3
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x5:UnweightedGraph A3 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> Edge A2 in
\graph . nodesOf (Graph
                    (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf C0, M0 |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X4:_ -> Edge A2 ()
Adding constraint graph, nodesOf C0, M0 |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X4:_ -> Edge A2 ()
Typing Constraints
graph, nodesOf C0, M0 |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X4:_ -> Edge A2 ()
graph, nodesOf C0, M0 |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X4:_ -> Edge A2 ()
graph, nodesOf C0, M0 |- x5:UnweightedGraph A3 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A3
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X4:_ -> Edge a in
\graph . nodesOf (Graph
                    (MoreEdge (nodesOf ??) ??))
Adding constraint graph, nodesOf |- A3
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> Edge A2 in
\graph . nodesOf (Graph
                    (MoreEdge (?? ?? ??) ??))
Adding constraint graph, nodesOf C0, M0 |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> Edge A2 ()
Adding constraint graph, nodesOf C0, M0 |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> Edge A2 ()
Typing Constraints
graph, nodesOf C0, M0 |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> Edge A2 ()
graph, nodesOf C0, M0 |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> Edge A2 ()
graph, nodesOf |- A3
UNIFY A3 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Cons ::
X5:_ -> X4:_ -> Edge a in
\graph . nodesOf (Graph
                    (MoreEdge (Cons ?? ??) ??))
Adding constraint graph, nodesOf |- A3
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> Edge A2 in
\graph . nodesOf (Graph
                    (MoreEdge (?? ?? ??) ??))
Adding constraint graph, nodesOf C0, M0 |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} <: X5:_ -> X4:_ -> Edge A2 ()
Adding constraint graph, nodesOf C0, M0 |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} /\ X5:_ -> X4:_ -> Edge A2 ()
Typing Constraints
graph, nodesOf C0, M0 |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} /\ X5:_ -> X4:_ -> Edge A2 ()
graph, nodesOf C0, M0 |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} <: X5:_ -> X4:_ -> Edge A2 ()
graph, nodesOf |- A3
UNIFY A3 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking MoreEdge ::
X5:_ -> X4:_ -> Edge a in
\graph . nodesOf (Graph
                    (MoreEdge (MoreEdge ?? ??) ??))
Adding constraint graph, nodesOf |- A3
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> Edge A2 in
\graph . nodesOf (Graph
                    (MoreEdge (?? ?? ?? ??) ??))
Adding constraint graph, nodesOf C0, M0 |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} <: X6:_ -> X5:_ -> X4:_ -> Edge A2 ()
Adding constraint graph, nodesOf C0, M0 |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} /\ X6:_ -> X5:_ -> X4:_ -> Edge A2 ()
Typing Constraints
graph, nodesOf C0, M0 |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} /\ X6:_ -> X5:_ -> X4:_ -> Edge A2 ()
graph, nodesOf C0, M0 |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} <: X6:_ -> X5:_ -> X4:_ -> Edge A2 ()
graph, nodesOf |- A3
UNIFY A3 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
A2 -> {a|U2}
A3 -> {a|U3}
Typing Constraints
Type assignment
A0 -> {a|U0}
A1 -> {a|U1}
A2 -> {a|U2}
A3 -> {a|U3}
Simple Constraints
graph, nodesOf |- {a|U3}
X4, X5, X6, graph, nodesOf C0, M0 |- {Edge|_v == (Edge X6 X5 X4)} <: Edge ()
X4, X5, X6, graph, nodesOf C0, M0 |- {a|U3} <: {a|U2} ()
graph, nodesOf, x5, x6, x7 C0, M0 |- {Edge|_v == (Edge x5 x6 x7)} /\ Edge ()
graph, nodesOf, x5, x6, x7 C0, M0 |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x5, x6, x7 C0, M0 |- {a|U3} /\ {a|U2} ()
X4, X5, X6, graph, nodesOf C0, M0 |- {a|U3} <: {a|U2} ()
Constraints
  C0 && (M0 && U3) ==> U2
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C0 && (M0 && (U2 && U3))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Trying graph
Checking graph :: Int in
\graph . nodesOf (Graph
                    (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: Int ()
Typing Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: Int ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . nodesOf (Graph
                    (MoreEdge (Edge graph ?? ??)
                       ??))
Adding constraint graph, nodesOf |- A4
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A4|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\graph . nodesOf (Graph
                    (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf C0, M0 |- {List {A4|False}|_v == (Nil)} <: Int ()
Typing Constraints
graph, nodesOf C0, M0 |- {List {A4|False}|_v == (Nil)} <: Int ()
graph, nodesOf |- A4
TYPE ERROR: Cannot match shape 'List (A4)'
with shape 'Int'
when checking Nil :: Int in
\graph . nodesOf (Graph
                    (MoreEdge (Edge Nil ?? ??) ??))
Adding constraint graph, nodesOf |- A4
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A4|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Int in
\graph . nodesOf (Graph
                    (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf C0, M0 |- {Edges {A4|False}|_v == (NoEdge)} <: Int ()
Typing Constraints
graph, nodesOf C0, M0 |- {Edges {A4|False}|_v == (NoEdge)} <: Int ()
graph, nodesOf |- A4
TYPE ERROR: Cannot match shape 'Edges (A4)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . nodesOf (Graph
                    (MoreEdge (Edge NoEdge ?? ??)
                       ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??
                           ?? ??))
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . nodesOf (Graph (Edge ??
                           ?? ??))
Adding constraint graph, nodesOf |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A1 in
\graph . nodesOf (Graph (?? ??
                           ?? ??))
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A2 -> {Edge A2|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> Edges A1 ()
graph, nodesOf |- A2
UNIFY A2 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . nodesOf (Graph (Edge ??
                           ?? ??))
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x2:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} /\ X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x2} <: X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (nodesOf ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (MoreEdge ??
                    ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Edge ?? ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (MoreEdge ??
                    ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Edge ?? ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Edge ?? ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:A1 -> x3:List A1 -> {List A1|_v == (Cons x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} /\ X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Edge A1 -> x3:Edges A1 -> {Edges A1|_v == (MoreEdge x2 x3)} <: X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (MoreEdge ??
                    ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Edge ?? ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Edge ?? ?? ??)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} in
\graph . nodesOf (?? ?? ?? ??)
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf C0, M0 |- x2:Int -> x3:Int -> x4:A1 -> {Edge A1|_v == (Edge x2 x3 x4)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A0|size _v >= 0 && size _v < size graph} ()
graph, nodesOf |- A1
UNIFY A1 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . nodesOf (Edge ?? ?? ??)
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {Int|U0}
X0, X1, graph, nodesOf C0, M0 |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {Int|U0} <: Int ()
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1, x2 C0, M0 |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && ([_v -> x1]U0 && (_v == (Cons x1 x2) && (elems _v == vertices graph && (len x2 >= 0 && size graph >= 0)))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Trying graph
Checking graph :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {UnweightedGraph a|_v == graph} <: A0 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . Cons graph ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A1|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {List {A1|False}|_v == (Nil)} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {List {A1|False}|_v == (Nil)} <: A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Nil :: Int in
\graph . Cons Nil ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A1|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A0 in
\graph . Cons ?? ??
Adding constraint graph, nodesOf C0, M0 |- {Edges {A1|False}|_v == (NoEdge)} <: A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- {Edges {A1|False}|_v == (NoEdge)} <: A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . Cons NoEdge ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . MoreEdge ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {Int|U0}
X0, X1, graph, nodesOf C0, M0 |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {Int|U0} <: Int ()
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1, x2 C0, M0 |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && ([_v -> x1]U0 && (_v == (Cons x1 x2) && (elems _v == vertices graph && (len x2 >= 0 && size graph >= 0)))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)}
Trying Graph
Checking Graph :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'UnweightedGraph (A1)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . Cons (Graph ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . Cons (nodesOf ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . Cons (MoreEdge ?? ??)
           ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . MoreEdge ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {Int|U0}
X0, X1, graph, nodesOf C0, M0 |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {Int|U0} <: Int ()
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1, x2 C0, M0 |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && ([_v -> x1]U0 && (_v == (Cons x1 x2) && (elems _v == vertices graph && (len x2 >= 0 && size graph >= 0)))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)}
Trying Graph
Checking Graph :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'UnweightedGraph (A1)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . Cons (Graph ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . Cons (nodesOf ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . Cons (MoreEdge ?? ??)
           ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . Cons (MoreEdge ?? ??)
           ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . MoreEdge ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:A0 -> x2:List A0 -> {List A0|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
graph, nodesOf |- (match) M0
graph, nodesOf |- C0
graph, nodesOf |- {Int|U0}
X0, X1, graph, nodesOf C0, M0 |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {Int|U0} <: Int ()
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x1, x2 C0, M0 |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x1, x2 C0, M0 |- {List|_v == (Cons x1 x2)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf C0, M0 |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  M0 -> {}
  U0 -> {}
Checking consistency
  C0 && (M0 && ([_v -> x1]U0 && (_v == (Cons x1 x2) && (elems _v == vertices graph && (len x2 >= 0 && size graph >= 0)))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)}
Trying Graph
Checking Graph :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'UnweightedGraph (A1)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . Cons (Graph ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A0 in
\graph . Cons (?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . Cons (nodesOf ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . Cons (MoreEdge ?? ??)
           ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . Cons (MoreEdge ?? ??)
           ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edges (A1)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . Cons (MoreEdge ?? ??)
           ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'List (A1)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A0 in
\graph . Cons (?? ?? ?? ??) ??
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
Adding constraint graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
Typing Constraints
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf C0, M0 |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X4:_ -> X3:_ -> X2:_ -> A0 ()
graph, nodesOf |- A1
TYPE ERROR: Cannot match shape 'Edge (A1)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . Cons (Edge ?? ?? ??) ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Edge A0 -> x2:Edges A0 -> {Edges A0|_v == (MoreEdge x1 x2)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . MoreEdge ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . ?? ?? ?? ??
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf C0, M0 |- x1:Int -> x2:Int -> x3:A0 -> {Edge A0|_v == (Edge x1 x2 x3)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf |- A0
graph, nodesOf |- C0
graph, nodesOf |- (match) M0
UNIFY A0 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . Edge ?? ?? ??
Looking for type _
Trying graph
Checking graph :: _ in
\graph . 
  match ?? with
Adding constraint graph, nodesOf |- {UnweightedGraph a|_v == graph} <: _ ()
Typing Constraints
graph, nodesOf |- {UnweightedGraph a|_v == graph} <: _ ()
Type assignment
Simple Constraints
Pred assignment
After process simple constraints
Constraints
QMap
Checking consistency
Candidates (1)
  0: [] (0 0)
Remaining Candidates (1)
  0: [] (0 0)
Typing Constraints
Type assignment
Simple Constraints
Pred assignment
After process simple constraints
Constraints
QMap
Checking consistency
Candidates (1)
  0: [] (0 0)
Remaining Candidates (1)
  0: [] (0 0)
Auxiliary goals are:
Adding constraint graph, nodesOf |- A0
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x1:Edges A0 -> {UnweightedGraph A0|_v == (Graph x1)}
Matching constructor type
{UnweightedGraph A0|_v == (Graph x1)}
with scrutinee
{UnweightedGraph a|_v == graph}
Adding constraint graph, nodesOf |- C0
Checking error in
\graph . 
  match graph with
    Graph x2 -> error
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|x2 == x2 && graph == graph} <: {Int|False} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|x2 == x2 && graph == graph} <: {Int|False} ()
graph, nodesOf |- C0
graph, nodesOf |- A0
Type assignment
A0 -> a
Simple Constraints
graph, nodesOf |- a
graph, nodesOf |- C0
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|x2 == x2 && graph == graph} <: {Int|False} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|x2 == x2 && graph == graph} <: {Int|False} ()
Constraints
  C0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (size graph >= 0 && (x2 == x2 && graph == graph)))) ==> False
QMap
  C0 -> {}
Candidates (1)
  0: [C0 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}] (0 1)
Invalid Constraint: C0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (size graph >= 0 && (x2 == x2 && graph == graph)))) ==> False
Strengthening: C0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (size graph >= 0 && (x2 == x2 && graph == graph)))) ==> False
Instantiated axioms:
size ((Graph x2)) == edgeNum x2, vertices ((Graph x2)) == nodeSet x2
All assumptions:
x2 == x2, graph == graph, graph == (Graph x2), size ((Graph x2)) == edgeNum x2, vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, size graph >= 0
RHS: False
assumption True
mustHave x2 == x2 && (graph == graph && (graph == (Graph x2) && (size ((Graph x2)) == edgeNum x2 && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && size graph >= 0)))))
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\graph . 
  match graph with
    Graph x2 -> error
Adding constraint graph, nodesOf, x2 |- C0
Looking for type {List Int|elems _v == vertices graph}
Trying x2
Checking x2 :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> x2
Trying graph
Checking graph :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> graph
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A1|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A1|False}|_v == (Nil)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A1|False}|_v == (Nil)} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {Int|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|_v == (Nil)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|False} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == []} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == []} <: {List|elems _v == vertices graph} ()
Constraints
  C0 && (graph == (Graph x2) && (elems _v == [] && (edgeNum x2 >= 0 && size graph >= 0))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}, U0 -> {}] (0 1)
Invalid Constraint: C0 && (graph == (Graph x2) && (elems _v == [] && (edgeNum x2 >= 0 && size graph >= 0))) ==> elems _v == vertices graph
Strengthening: C0 && (graph == (Graph x2) && (elems _v == [] && (edgeNum x2 >= 0 && size graph >= 0))) ==> elems _v == vertices graph
Instantiated axioms:
size ((Graph x2)) == edgeNum x2, vertices ((Graph x2)) == nodeSet x2
All assumptions:
graph == (Graph x2), size ((Graph x2)) == edgeNum x2, elems _v == [], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption graph == (Graph x2) && (size ((Graph x2)) == edgeNum x2 && (elems _v == [] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && size graph >= 0))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Nil ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Nil
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A1|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A1|False}|_v == (NoEdge)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A1|False}|_v == (NoEdge)} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> NoEdge
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Graph ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH {a|False} PRODUCING {a|U0}
Type assignment
A0 -> a
A1 -> {a|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {a|U0}
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|False} <: {a|U0} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- {List|elems _v == vertices x3} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- {List|elems _v == vertices x3} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x3 && (edgeNum x2 >= 0 && (size graph >= 0 && (size x3 >= 0 && (size x3 >= 0 && size x3 < size graph)))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Trying x2
Checking x2 :: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf x2
Trying graph
Checking graph :: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> {a|U0}
Simple Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- a <: {a|U0} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- a <: {a|U0} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
Constraints
  C0 && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> size _v >= 0 && size _v < size graph
  C0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0)) ==> U0
QMap
  C0 -> {}
  U0 -> {}
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (2 1)
Chosen candidate: 0: [C0 -> {}, U0 -> {}] (2 1)
Invalid Constraint: C0 && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> size _v >= 0 && size _v < size graph
Strengthening: C0 && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> size _v >= 0 && size _v < size graph
Instantiated axioms:
size ((Graph x2)) == edgeNum x2, vertices ((Graph x2)) == nodeSet x2
All assumptions:
_v == graph, graph == (Graph x2), size ((Graph x2)) == edgeNum x2, vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, size graph >= 0
RHS: size _v >= 0 && size _v < size graph
assumption _v == graph && (graph == (Graph x2) && (size ((Graph x2)) == edgeNum x2 && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && size graph >= 0))))
mustHave !(size _v >= 0 && size _v < size graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking graph ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf graph
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A2|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Nil ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf Nil
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A2|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A2|False}|_v == (NoEdge)} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A2|False}|_v == (NoEdge)} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf NoEdge
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {Int|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|U0} <: Int ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && ([_v -> x3]U0 && (_v == (Cons x3 x4) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (len x4 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Trying x2
Checking x2 :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: A1 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons x2 ??
Trying graph
Checking graph :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A1 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons graph ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A2|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons Nil ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A2|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A2|False}|_v == (NoEdge)} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A2|False}|_v == (NoEdge)} <: A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons NoEdge ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Graph ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH {a|False} PRODUCING {a|U0}
Type assignment
A0 -> a
A1 -> {a|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {a|U0}
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|False} <: {a|U0} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- {List|elems _v == vertices x3} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- {List|elems _v == vertices x3} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x3 && (edgeNum x2 >= 0 && (size graph >= 0 && (size x3 >= 0 && (size x3 >= 0 && size x3 < size graph)))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
Simple Constraints
graph, nodesOf, x2 |- {a|U1}
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U1} <: {a|U0} ()
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x4)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {a|U1} /\ {a|U0} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {a|U1} /\ {a|U0} ()
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x4)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U1} <: {a|U0} ()
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C0 && (U1 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> U0
QMap
  C0 -> {}
  U0 -> {}
  U1 -> {}
Checking consistency
  C0 && (_v == (Graph x4) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x4 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph))))))
  C0 && (U0 && (U1 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Trying x2
Checking x2 :: Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A2 ()
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
Simple Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- a <: {a|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- a <: {a|U1} ()
Constraints
  C0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0)) ==> U1
QMap
  C0 -> {}
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}] (4 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking Graph
           x2 :: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph A2|_v == (Graph x2)} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph A2|_v == (Graph x2)} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
Simple Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x2)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U1} <: {a|U0} ()
Pred assignment
addSplitConstraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x2} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U1} <: {a|U0} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x2} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C0 && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && size graph >= 0))) ==> size _v < size graph && size _v >= 0
  C0 && (U1 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> U0
QMap
  C0 -> {}
  U0 -> {}
  U1 -> {}
Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}] (4 1)
Chosen candidate: 0: [C0 -> {}, U0 -> {}, U1 -> {}] (4 1)
Invalid Constraint: C0 && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && size graph >= 0))) ==> size _v < size graph && size _v >= 0
Strengthening: C0 && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && size graph >= 0))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
size ((Graph x2)) == edgeNum x2, vertices ((Graph x2)) == nodeSet x2
All assumptions:
graph == (Graph x2), size _v == edgeNum x2, size ((Graph x2)) == edgeNum x2, vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption graph == (Graph x2) && (size _v == edgeNum x2 && (size ((Graph x2)) == edgeNum x2 && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && size graph >= 0))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph x2)
Trying graph
Checking graph :: Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A2 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           graph)
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A3|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A3|False}|_v == (Nil)} <: Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A3|False}|_v == (Nil)} <: Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph Nil)
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A3|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A3|False}|_v == (NoEdge)} <: Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A3|False}|_v == (NoEdge)} <: Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
A3 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
A3 -> {a|U2}
Simple Constraints
graph, nodesOf, x2 |- {a|U2}
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|False} <: {a|U1} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (3 0)
Synthesized argument NoEdge of type {Edges {A3|False}|_v == (NoEdge)}
Checking Graph
           NoEdge :: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph A2|_v == (Graph (NoEdge))} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph A2|_v == (Graph (NoEdge))} <: {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
A3 -> {a|U2}
Simple Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph (NoEdge))} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U1} <: {a|U0} ()
Pred assignment
addSplitConstraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U1} <: {a|U0} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C0 && (graph == (Graph x2) && (size _v == edgeNum (NoEdge) && (edgeNum x2 >= 0 && size graph >= 0))) ==> size _v < size graph && size _v >= 0
  C0 && (U1 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> U0
QMap
  C0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (3 1)
Chosen candidate: 0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (3 1)
Invalid Constraint: C0 && (graph == (Graph x2) && (size _v == edgeNum (NoEdge) && (edgeNum x2 >= 0 && size graph >= 0))) ==> size _v < size graph && size _v >= 0
Strengthening: C0 && (graph == (Graph x2) && (size _v == edgeNum (NoEdge) && (edgeNum x2 >= 0 && size graph >= 0))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet (NoEdge) == [], vertices ((Graph x2)) == nodeSet x2
All assumptions:
graph == (Graph x2), edgeNum (NoEdge) == 0, size _v == edgeNum (NoEdge), size ((Graph x2)) == edgeNum x2, nodeSet (NoEdge) == [], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption graph == (Graph x2) && (edgeNum (NoEdge) == 0 && (size _v == edgeNum (NoEdge) && (size ((Graph x2)) == edgeNum x2 && (nodeSet (NoEdge) == [] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && size graph >= 0))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           NoEdge)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (nodesOf ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (MoreEdge ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Edge ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {Int|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|U0} <: Int ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && ([_v -> x3]U0 && (_v == (Cons x3 x4) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (len x4 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Trying x2
Checking x2 :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: A1 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons x2 ??
Trying graph
Checking graph :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A1 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons graph ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A2|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons Nil ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A2|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A2|False}|_v == (NoEdge)} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A2|False}|_v == (NoEdge)} <: A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons NoEdge ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {Int|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|U0} <: Int ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && ([_v -> x3]U0 && (_v == (Cons x3 x4) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (len x4 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)}
Trying Graph
Checking Graph :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'UnweightedGraph (A2)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Graph ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (nodesOf ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (MoreEdge ??
                        ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Graph ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH {a|False} PRODUCING {a|U0}
Type assignment
A0 -> a
A1 -> {a|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {a|U0}
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|False} <: {a|U0} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- {List|elems _v == vertices x3} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- {List|elems _v == vertices x3} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x3 && (edgeNum x2 >= 0 && (size graph >= 0 && (size x3 >= 0 && (size x3 >= 0 && size x3 < size graph)))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
Simple Constraints
graph, nodesOf, x2 |- {a|U1}
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U1} <: {a|U0} ()
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x4)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {a|U1} /\ {a|U0} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {a|U1} /\ {a|U0} ()
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x4)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U1} <: {a|U0} ()
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C0 && (U1 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> U0
QMap
  C0 -> {}
  U0 -> {}
  U1 -> {}
Checking consistency
  C0 && (_v == (Graph x4) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x4 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph))))))
  C0 && (U0 && (U1 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)}
Trying Graph
Checking Graph :: X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} <: X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} /\ X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} /\ X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} <: X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (Graph ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A3 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A3 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A3
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (nodesOf ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (Cons
                                  ?? ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
A3 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
A3 -> {a|U2}
Simple Constraints
graph, nodesOf, x2 |- {a|U2}
X2, X3, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6 C0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} /\ Edges ()
graph, nodesOf, x2, x5, x6 C0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 C0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
X2, X3, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Constraints
  C0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> U1
QMap
  C0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C0 && (U1 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying x2
Checking x2 :: Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A3 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge x2 ??))
Trying graph
Checking graph :: Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A3 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge graph ??))
Adding constraint graph, nodesOf, x2 |- A4
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A4|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A4|False}|_v == (Nil)} <: Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A4|False}|_v == (Nil)} <: Edge A3 ()
graph, nodesOf, x2 |- A4
UNIFY A4 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge Nil ??))
Adding constraint graph, nodesOf, x2 |- A4
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A4|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A4|False}|_v == (NoEdge)} <: Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A4|False}|_v == (NoEdge)} <: Edge A3 ()
graph, nodesOf, x2 |- A4
UNIFY A4 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge NoEdge ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ?? ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (Edge
                                  ?? ?? ??))
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (nodesOf ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (MoreEdge ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Edge ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (MoreEdge ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Edge ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Edge ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {Int|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|U0} <: Int ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && ([_v -> x3]U0 && (_v == (Cons x3 x4) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (len x4 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Trying x2
Checking x2 :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: A1 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons x2 ??
Trying graph
Checking graph :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A1 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons graph ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A2|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons Nil ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A2|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A2|False}|_v == (NoEdge)} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A2|False}|_v == (NoEdge)} <: A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons NoEdge ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {Int|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|U0} <: Int ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && ([_v -> x3]U0 && (_v == (Cons x3 x4) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (len x4 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)}
Trying Graph
Checking Graph :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'UnweightedGraph (A2)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Graph ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (nodesOf ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (MoreEdge ??
                        ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {Int|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|U0} <: Int ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && ([_v -> x3]U0 && (_v == (Cons x3 x4) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (len x4 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)}
Trying Graph
Checking Graph :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'UnweightedGraph (A2)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Graph ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (nodesOf ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (MoreEdge ??
                        ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (MoreEdge ??
                        ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edges A1 -> {UnweightedGraph A1|_v == (Graph x3)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Graph ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:{UnweightedGraph A1|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x3} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:UnweightedGraph A1 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH {a|False} PRODUCING {a|U0}
Type assignment
A0 -> a
A1 -> {a|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {a|U0}
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|False} <: {a|U0} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- {List|elems _v == vertices x3} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3 C0, graph == (Graph x2) |- {List|elems _v == vertices x3} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x3 && (edgeNum x2 >= 0 && (size graph >= 0 && (size x3 >= 0 && (size x3 >= 0 && size x3 < size graph)))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edges A2 -> {UnweightedGraph A2|_v == (Graph x4)} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
Simple Constraints
graph, nodesOf, x2 |- {a|U1}
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U1} <: {a|U0} ()
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x4)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {a|U1} /\ {a|U0} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {a|U1} /\ {a|U0} ()
graph, nodesOf, x2, x4 C0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x4)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U1} <: {a|U0} ()
X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C0 && (U1 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> U0
QMap
  C0 -> {}
  U0 -> {}
  U1 -> {}
Checking consistency
  C0 && (_v == (Graph x4) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x4 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph))))))
  C0 && (U0 && (U1 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}] (3 0)
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)}
Trying Graph
Checking Graph :: X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} <: X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} /\ X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} /\ X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A3 -> {UnweightedGraph A3|_v == (Graph x5)} <: X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (Graph ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A3 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A3|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A3 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A3
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (nodesOf ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (Cons
                                  ?? ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
A3 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
A3 -> {a|U2}
Simple Constraints
graph, nodesOf, x2 |- {a|U2}
X2, X3, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6 C0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} /\ Edges ()
graph, nodesOf, x2, x5, x6 C0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 C0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
X2, X3, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Constraints
  C0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> U1
QMap
  C0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C0 && (U1 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying x2
Checking x2 :: Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A3 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge x2 ??))
Trying graph
Checking graph :: Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A3 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge graph ??))
Adding constraint graph, nodesOf, x2 |- A4
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A4|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A4|False}|_v == (Nil)} <: Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A4|False}|_v == (Nil)} <: Edge A3 ()
graph, nodesOf, x2 |- A4
UNIFY A4 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge Nil ??))
Adding constraint graph, nodesOf, x2 |- A4
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A4|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A4|False}|_v == (NoEdge)} <: Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A4|False}|_v == (NoEdge)} <: Edge A3 ()
graph, nodesOf, x2 |- A4
UNIFY A4 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge NoEdge ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ?? ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (Edge
                                  ?? ?? ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (Cons
                                  ?? ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A3 -> x6:Edges A3 -> {Edges A3|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
A3 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
A3 -> {a|U2}
Simple Constraints
graph, nodesOf, x2 |- {a|U2}
X2, X3, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6 C0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} /\ Edges ()
graph, nodesOf, x2, x5, x6 C0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 C0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
X2, X3, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Constraints
  C0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> U1
QMap
  C0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C0 && (U1 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Adding constraint graph, nodesOf, x2 |- A4
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)}
Trying Graph
Checking Graph :: X4:_ -> Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} <: X4:_ -> Edge A3 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} /\ X4:_ -> Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} /\ X4:_ -> Edge A3 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} <: X4:_ -> Edge A3 ()
graph, nodesOf, x2 |- A4
UNIFY A4 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking Graph ::
X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (Graph ??) ??))
Adding constraint graph, nodesOf, x2 |- A4
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:UnweightedGraph A4 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} <: X4:_ -> Edge A3 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} /\ X4:_ -> Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} /\ X4:_ -> Edge A3 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} <: X4:_ -> Edge A3 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:UnweightedGraph A4 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A4
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (nodesOf ??) ??))
Adding constraint graph, nodesOf, x2 |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (?? ?? ??) ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X5:_ -> X4:_ -> Edge A3 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X5:_ -> X4:_ -> Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X5:_ -> X4:_ -> Edge A3 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X5:_ -> X4:_ -> Edge A3 ()
graph, nodesOf, x2 |- A4
UNIFY A4 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Cons ::
X5:_ -> X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (Cons ?? ??) ??))
Adding constraint graph, nodesOf, x2 |- A4
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (?? ?? ??) ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X5:_ -> X4:_ -> Edge A3 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X5:_ -> X4:_ -> Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X5:_ -> X4:_ -> Edge A3 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X5:_ -> X4:_ -> Edge A3 ()
graph, nodesOf, x2 |- A4
UNIFY A4 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking MoreEdge ::
X5:_ -> X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (MoreEdge ?? ??) ??))
Adding constraint graph, nodesOf, x2 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> Edge A3 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (?? ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X6:_ -> X5:_ -> X4:_ -> Edge A3 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X6:_ -> X5:_ -> X4:_ -> Edge A3 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X6:_ -> X5:_ -> X4:_ -> Edge A3 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X6:_ -> X5:_ -> X4:_ -> Edge A3 ()
graph, nodesOf, x2 |- A4
UNIFY A4 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
A3 -> {a|U2}
A4 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> {a|U0}
A2 -> {a|U1}
A3 -> {a|U2}
A4 -> {a|U3}
Simple Constraints
graph, nodesOf, x2 |- {a|U3}
X4, X5, X6, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edge|_v == (Edge X6 X5 X4)} <: Edge ()
X4, X5, X6, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x2, x7, x8, x9 C0, graph == (Graph x2) |- {Edge|_v == (Edge x7 x8 x9)} /\ Edge ()
graph, nodesOf, x2, x7, x8, x9 C0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x7, x8, x9 C0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X4, X5, X6, graph, nodesOf, x2 C0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))) ==> U2
QMap
  C0 -> {}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C0 && (U2 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && size graph >= 0))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Trying x2
Checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: Int ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: Int ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (Edge x2 ?? ??) ??))
Trying graph
Checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Int ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Int ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (Edge graph ?? ??)
                              ??))
Adding constraint graph, nodesOf, x2 |- A5
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A5|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: Int ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: Int ()
graph, nodesOf, x2 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (Edge Nil ?? ??) ??))
Adding constraint graph, nodesOf, x2 |- A5
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A5|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: Int ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: Int ()
graph, nodesOf, x2 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph
                           (MoreEdge (Edge NoEdge ?? ??)
                              ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ?? ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (Edge
                                  ?? ?? ??))
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A2 in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (??
                                  ?? ?? ??))
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A3 -> {Edge A3|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> Edges A2 ()
graph, nodesOf, x2 |- A3
UNIFY A3 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Graph (Edge
                                  ?? ?? ??))
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} /\ X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x4} <: X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (nodesOf ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (MoreEdge ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Edge ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (MoreEdge ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Edge ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Edge ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:A2 -> x5:List A2 -> {List A2|_v == (Cons x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Cons ?? ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} /\ X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Edge A2 -> x5:Edges A2 -> {Edges A2|_v == (MoreEdge x4 x5)} <: X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (MoreEdge ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Edge ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Edge ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> nodesOf (?? ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x4:Int -> x5:Int -> x6:A2 -> {Edge A2|_v == (Edge x4 x5 x6)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A1|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2 |- A2
UNIFY A2 WITH {a|U0} PRODUCING {a|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> nodesOf (Edge ?? ??
                           ??)
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {Int|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|U0} <: Int ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && ([_v -> x3]U0 && (_v == (Cons x3 x4) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (len x4 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Trying x2
Checking x2 :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges a|_v == x2} <: A1 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons x2 ??
Trying graph
Checking graph :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A1 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons graph ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A2|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons Nil ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A2|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A1 in
\graph . 
  match graph with
    Graph x2 -> Cons ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A2|False}|_v == (NoEdge)} <: A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- {Edges {A2|False}|_v == (NoEdge)} <: A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> Cons NoEdge ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {Int|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|U0} <: Int ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && ([_v -> x3]U0 && (_v == (Cons x3 x4) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (len x4 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)}
Trying Graph
Checking Graph :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'UnweightedGraph (A2)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Graph ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (nodesOf ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (MoreEdge ??
                        ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {Int|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|U0} <: Int ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && ([_v -> x3]U0 && (_v == (Cons x3 x4) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (len x4 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)}
Trying Graph
Checking Graph :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'UnweightedGraph (A2)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Graph ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (nodesOf ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (MoreEdge ??
                        ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (MoreEdge ??
                        ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:A1 -> x4:List A1 -> {List A1|_v == (Cons x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> {Int|U0}
Simple Constraints
graph, nodesOf |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {Int|U0} <: Int ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {Int|U0} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x3, x4 C0, graph == (Graph x2) |- {List|_v == (Cons x3 x4)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2 C0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
  C0 && ([_v -> x3]U0 && (_v == (Cons x3 x4) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (len x4 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)}
Trying Graph
Checking Graph :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edges A2 -> {UnweightedGraph A2|_v == (Graph x5)} <: X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'UnweightedGraph (A2)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Graph ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5}
Trying nodesOf
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} /\ X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:{UnweightedGraph A2|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x5} <: X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:UnweightedGraph A2 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (nodesOf ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (MoreEdge ??
                        ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (MoreEdge ??
                        ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Edge A2 -> x6:Edges A2 -> {Edges A2|_v == (MoreEdge x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edges (A2)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (MoreEdge ??
                        ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ??) ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} /\ X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:A2 -> x6:List A2 -> {List A2|_v == (Cons x5 x6)} <: X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'List (A2)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Cons ?? ??) ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A1 in
\graph . 
  match graph with
    Graph x2 -> Cons (?? ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} /\ X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x5:Int -> x6:Int -> x7:A2 -> {Edge A2|_v == (Edge x5 x6 x7)} <: X4:_ -> X3:_ -> X2:_ -> A1 ()
graph, nodesOf, x2 |- A2
TYPE ERROR: Cannot match shape 'Edge (A2)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> Cons (Edge ?? ?? ??)
                  ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Edge A1 -> x4:Edges A1 -> {Edges A1|_v == (MoreEdge x3 x4)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, graph == (Graph x2) |- x3:Int -> x4:Int -> x5:A1 -> {Edge A1|_v == (Edge x3 x4 x5)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A1
graph, nodesOf, x2 |- C0
graph, nodesOf |- A0
UNIFY A1 WITH Int PRODUCING {Int|U0}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> Edge ?? ?? ??
Looking for type _
Trying x2
Checking x2 :: _ in
\graph . 
  match graph with
    Graph x2 -> 
      match ?? with
Adding constraint graph, nodesOf, x2 graph == (Graph x2) |- {Edges a|_v == x2} <: _ ()
Typing Constraints
graph, nodesOf, x2 graph == (Graph x2) |- {Edges a|_v == x2} <: _ ()
graph, nodesOf |- A0
Type assignment
A0 -> a
Simple Constraints
graph, nodesOf |- a
Pred assignment
After process simple constraints
Constraints
QMap
Checking consistency
Candidates (1)
  0: [] (0 0)
Remaining Candidates (1)
  0: [] (0 0)
Typing Constraints
Type assignment
A0 -> a
Simple Constraints
Pred assignment
After process simple constraints
Constraints
QMap
Checking consistency
Candidates (1)
  0: [] (0 0)
Remaining Candidates (1)
  0: [] (0 0)
Auxiliary goals are:
Adding constraint graph, nodesOf, x2 |- A1
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges A1|_v == (NoEdge)}
Matching constructor type
{Edges A1|_v == (NoEdge)}
with scrutinee
{Edges a|_v == x2}
Adding constraint graph, nodesOf, x2 |- C0
Checking error in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        NoEdge -> error
Adding constraint graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {Int|x2 == x2 && graph == graph} <: {Int|False} ()
Typing Constraints
graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {Int|x2 == x2 && graph == graph} <: {Int|False} ()
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- A1
Type assignment
A0 -> a
A1 -> a
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {Int|x2 == x2 && graph == graph} <: {Int|False} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {Int|x2 == x2 && graph == graph} <: {Int|False} ()
Constraints
  C0 && (x2 == (NoEdge) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (size graph >= 0 && (x2 == x2 && graph == graph))))) ==> False
QMap
  C0 -> {}
Candidates (1)
  0: [C0 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}] (0 1)
Invalid Constraint: C0 && (x2 == (NoEdge) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (size graph >= 0 && (x2 == x2 && graph == graph))))) ==> False
Strengthening: C0 && (x2 == (NoEdge) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (size graph >= 0 && (x2 == x2 && graph == graph))))) ==> False
Instantiated axioms:
edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet (NoEdge) == [], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x2 == x2, x2 == (NoEdge), graph == graph, graph == (Graph x2), edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet (NoEdge) == [], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, size graph >= 0
RHS: False
assumption True
mustHave x2 == x2 && (x2 == (NoEdge) && (graph == graph && (graph == (Graph x2) && (edgeNum (NoEdge) == 0 && (size ((Graph x2)) == edgeNum x2 && (nodeSet (NoEdge) == [] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && size graph >= 0))))))))
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        NoEdge -> error
Adding constraint graph, nodesOf, x2 |- C0
Looking for type {List Int|elems _v == vertices graph}
Trying graph
Checking graph :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        NoEdge -> ??
Adding constraint graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- A1
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        NoEdge -> graph
Trying x2
Checking x2 :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        NoEdge -> ??
Adding constraint graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {Edges a|_v == x2} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {Edges a|_v == x2} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- A1
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        NoEdge -> x2
Adding constraint graph, nodesOf, x2 |- A2
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A2|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        NoEdge -> ??
Adding constraint graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {List {A2|False}|_v == (Nil)} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2 |- A2
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- A1
UNIFY A2 WITH Int PRODUCING {Int|U0}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2 |- C0
graph, nodesOf, x2 |- {Int|U0}
graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {List|_v == (Nil)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {Int|False} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {List|elems _v == []} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2 C0, x2 == (NoEdge), graph == (Graph x2) |- {List|elems _v == []} <: {List|elems _v == vertices graph} ()
Constraints
  C0 && (x2 == (NoEdge) && (graph == (Graph x2) && (elems _v == [] && (edgeNum x2 >= 0 && size graph >= 0)))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
Simple Constraints
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  U0 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, U0 -> {}] (1 0)
Auxiliary goals are:
Adding constraint graph, nodesOf, x2 |- A3
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x3:Edge A3 -> x4:Edges A3 -> {Edges A3|_v == (MoreEdge x3 x4)}
Matching constructor type
{Edges A3|_v == (MoreEdge x3 x4)}
with scrutinee
{Edges a|_v == x2}
Checking error in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> error
Adding constraint graph, nodesOf, x2, x5, x6 True, M0, graph == (Graph x2) |- {Int|x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph))} <: {Int|False} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, M0, graph == (Graph x2) |- {Int|x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph))} <: {Int|False} ()
graph, nodesOf, x2 |- A3
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 True, M0, graph == (Graph x2) |- {Int|x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph))} <: {Int|False} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, M0, graph == (Graph x2) |- {Int|x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph))} <: {Int|False} ()
Constraints
  M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph))))))) ==> False
QMap
  C0 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
Candidates (1)
  0: [C0 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}] (1 1)
Chosen candidate: 0: [C0 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}] (1 1)
Invalid Constraint: M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph))))))) ==> False
Strengthening: M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph))))))) ==> False
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == x5, x2 == x2, x2 == (MoreEdge x5 x6), x6 == x6, graph == graph, graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: False
assumption True
mustHave x5 == x5 && (x2 == x2 && (x2 == (MoreEdge x5 x6) && (x6 == x6 && (graph == graph && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))))
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> error
Adding constraint graph, nodesOf, x2, x5, x6 |- C1
Looking for type {List Int|elems _v == vertices graph}
Trying x5
Checking x5 :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> x5
Trying x6
Checking x6 :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> x6
Trying graph
Checking graph :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> graph
Trying x2
Checking x2 :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> x2
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A4|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A4|False}|_v == (NoEdge)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A4|False}|_v == (NoEdge)} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> NoEdge
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A4|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A4|False}|_v == (Nil)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A4|False}|_v == (Nil)} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {Int|U1}
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|_v == (Nil)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|False} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == []} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == []} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (elems _v == [] && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (1 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (1 1)
Invalid Constraint: C1 && (M0 && (graph == (Graph x2) && (elems _v == [] && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (graph == (Graph x2) && (elems _v == [] && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2
All assumptions:
x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, elems _v == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Nil ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Nil
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Graph ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:UnweightedGraph A4 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:UnweightedGraph A4 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH {a|False} PRODUCING {a|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {a|U1}
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|False} <: {a|U1} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x7 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size x7 >= 0 && (size x7 >= 0 && size x7 < size graph)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Trying x5
Checking x5 :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking x5 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf x5
Trying x6
Checking x6 :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x6 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf x6
Trying graph
Checking graph :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U1} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
Constraints
  C1 && (M0 && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> size _v >= 0 && size _v < size graph
  C1 && (M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 1)
Invalid Constraint: C1 && (M0 && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> size _v >= 0 && size _v < size graph
Strengthening: C1 && (M0 && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> size _v >= 0 && size _v < size graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2
All assumptions:
x2 == (MoreEdge x5 x6), _v == graph, graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v >= 0 && size _v < size graph
assumption x2 == (MoreEdge x5 x6) && (_v == graph && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))
mustHave !(size _v >= 0 && size _v < size graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking graph ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf graph
Trying x2
Checking x2 :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf x2
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A5|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf NoEdge
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A5|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Nil ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf Nil
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x7]U1 && (_v == (Cons x7 x8) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x8 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Trying x5
Checking x5 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: A4 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x5 ??
Trying x6
Checking x6 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: A4 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x6 ??
Trying graph
Checking graph :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A4 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons graph ??
Trying x2
Checking x2 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: A4 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x2 ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A5|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons NoEdge ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A5|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons Nil ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Graph ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:UnweightedGraph A4 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:UnweightedGraph A4 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH {a|False} PRODUCING {a|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {a|U1}
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|False} <: {a|U1} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x7 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size x7 >= 0 && (size x7 >= 0 && size x7 < size graph)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- {a|U2}
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (_v == (Graph x8) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph))))))))
  C1 && (M0 && (U1 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying x5
Checking x5 :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A5 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     x5)
Trying x6
Checking x6 :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U2} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking Graph
           x6 :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph A5|_v == (Graph x6)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph A5|_v == (Graph x6)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x6)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x6} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x6} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (size _v == edgeNum x6 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (6 0)
Synthesized argument Graph
                       x6 of type {UnweightedGraph A5|_v == (Graph x6)}
Checking nodesOf (Graph
                    x6) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x7:({UnweightedGraph A5|_v == (Graph x6)}) IN {List Int|elems _v == vertices x7} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x7:({UnweightedGraph A5|_v == (Graph x6)}) IN {List Int|elems _v == vertices x7} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
Simple Constraints
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- Int <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (x7 == (Graph x6) && (elems _v == vertices x7 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x7 >= 0))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (M0 && (graph == (Graph x2) && (x7 == (Graph x6) && (elems _v == vertices x7 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x7 >= 0))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (graph == (Graph x2) && (x7 == (Graph x6) && (elems _v == vertices x7 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x7 >= 0))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, size ((Graph x6)) == edgeNum x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2, vertices ((Graph x6)) == nodeSet x6
All assumptions:
x2 == (MoreEdge x5 x6), graph == (Graph x2), x7 == (Graph x6), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, size ((Graph x6)) == edgeNum x6, elems _v == vertices x7, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2, vertices ((Graph x6)) == nodeSet x6, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0, size x7 >= 0
RHS: elems _v == vertices graph
assumption x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (x7 == (Graph x6) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (size ((Graph x6)) == edgeNum x6 && (elems _v == vertices x7 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (vertices ((Graph x2)) == nodeSet x2 && (vertices ((Graph x6)) == nodeSet x6 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x7 >= 0))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking nodesOf (Graph x6)
::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     x6)
Trying graph
Checking graph :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A5 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     graph)
Trying x2
Checking x2 :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U2} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking Graph
           x2 :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph A5|_v == (Graph x2)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph A5|_v == (Graph x2)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x2)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x2} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x2} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 1)
Invalid Constraint: C1 && (M0 && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2
All assumptions:
x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x2, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x2 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     x2)
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A6|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- {a|U3}
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|False} <: {a|U2} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (4 0)
Synthesized argument NoEdge of type {Edges {A6|False}|_v == (NoEdge)}
Checking Graph
           NoEdge :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph A5|_v == (Graph (NoEdge))} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph A5|_v == (Graph (NoEdge))} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph (NoEdge))} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (size _v == edgeNum (NoEdge) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Synthesized argument Graph
                       NoEdge of type {UnweightedGraph A5|_v == (Graph (NoEdge))}
Checking nodesOf (Graph
                    NoEdge) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x7:({UnweightedGraph A5|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x7} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x7:({UnweightedGraph A5|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x7} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- Int <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (x7 == (Graph (NoEdge)) && (elems _v == vertices x7 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x7 >= 0))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Invalid Constraint: C1 && (M0 && (graph == (Graph x2) && (x7 == (Graph (NoEdge)) && (elems _v == vertices x7 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x7 >= 0))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (graph == (Graph x2) && (x7 == (Graph (NoEdge)) && (elems _v == vertices x7 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x7 >= 0))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, size ((Graph (NoEdge))) == edgeNum (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph (NoEdge))) == nodeSet (NoEdge)
All assumptions:
x2 == (MoreEdge x5 x6), graph == (Graph x2), x7 == (Graph (NoEdge)), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, size ((Graph (NoEdge))) == edgeNum (NoEdge), elems _v == vertices x7, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph (NoEdge))) == nodeSet (NoEdge), edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0, size x7 >= 0
RHS: elems _v == vertices graph
assumption x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (x7 == (Graph (NoEdge)) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum (NoEdge) == 0 && (size ((Graph x2)) == edgeNum x2 && (size ((Graph (NoEdge))) == edgeNum (NoEdge) && (elems _v == vertices x7 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet (NoEdge) == [] && (vertices ((Graph x2)) == nodeSet x2 && (vertices ((Graph (NoEdge))) == nodeSet (NoEdge) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x7 >= 0))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking nodesOf (Graph
                         NoEdge) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     NoEdge)
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     Nil)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf
                            (nodesOf ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Cons
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf
                            (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Edge
                                     ?? ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x7]U1 && (_v == (Cons x7 x8) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x8 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Trying x5
Checking x5 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: A4 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x5 ??
Trying x6
Checking x6 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: A4 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x6 ??
Trying graph
Checking graph :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A4 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons graph ??
Trying x2
Checking x2 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: A4 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x2 ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A5|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons NoEdge ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A5|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons Nil ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x7]U1 && (_v == (Cons x7 x8) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x8 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)}
Trying Graph
Checking Graph :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'UnweightedGraph (A5)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Graph
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (nodesOf
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (MoreEdge
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Cons ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Graph ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:UnweightedGraph A4 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:UnweightedGraph A4 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH {a|False} PRODUCING {a|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {a|U1}
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|False} <: {a|U1} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x7 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size x7 >= 0 && (size x7 >= 0 && size x7 < size graph)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- {a|U2}
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (_v == (Graph x8) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph))))))))
  C1 && (M0 && (U1 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x9:Edges A6 -> {UnweightedGraph A6|_v == (Graph x9)}
Trying Graph
Checking Graph :: X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A6 -> {UnweightedGraph A6|_v == (Graph x9)} <: X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A6 -> {UnweightedGraph A6|_v == (Graph x9)} /\ X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A6 -> {UnweightedGraph A6|_v == (Graph x9)} /\ X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A6 -> {UnweightedGraph A6|_v == (Graph x9)} <: X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (Graph ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x9:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (nodesOf ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (Cons ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- {a|U3}
X2, X3, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x2, x5, x6, x9 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x9 x10)} /\ Edges ()
graph, nodesOf, x10, x2, x5, x6, x9 True, C1, M0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x2, x5, x6, x9 True, C1, M0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, X3, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Trying x5
Checking x5 :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge|_v == x5} <: Edge ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument x5 of type {Edge a|_v == x5}
Checking MoreEdge
           x5 :: X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x10:Edges A6 -> {Edges A6|_v == (MoreEdge x5 x10)} <: X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x10:Edges A6 -> {Edges A6|_v == (MoreEdge x5 x10)} /\ X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x10:Edges A6 -> {Edges A6|_v == (MoreEdge x5 x10)} /\ X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x10:Edges A6 -> {Edges A6|_v == (MoreEdge x5 x10)} <: X2:_ -> Edges A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
X2, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 X2)} <: Edges ()
X2, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x10)} /\ Edges ()
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x6
Checking x6 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge x5
           x6 :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A6|_v == (MoreEdge x5 x6)} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A6|_v == (MoreEdge x5 x6)} <: Edges A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument MoreEdge x5
                       x6 of type {Edges A6|_v == (MoreEdge x5 x6)}
Checking Graph (MoreEdge x5
                  x6) :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:({Edges A6|_v == (MoreEdge x5 x6)}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:({Edges A6|_v == (MoreEdge x5 x6)}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x8 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 1)
Invalid Constraint: C1 && (M0 && (x8 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x8 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2
All assumptions:
x2 == (MoreEdge x5 x6), x8 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x8, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, edgeNum x8 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x2 == (MoreEdge x5 x6) && (x8 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x8 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       x6) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 x6))
Trying graph
Checking graph :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A6 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 graph))
Trying x2
Checking x2 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge x5
           x2 :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A6|_v == (MoreEdge x5 x2)} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A6|_v == (MoreEdge x5 x2)} <: Edges A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x2)} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument MoreEdge x5
                       x2 of type {Edges A6|_v == (MoreEdge x5 x2)}
Checking Graph (MoreEdge x5
                  x2) :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:({Edges A6|_v == (MoreEdge x5 x2)}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:({Edges A6|_v == (MoreEdge x5 x2)}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x8 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 1)
Invalid Constraint: C1 && (M0 && (x8 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x8 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2
All assumptions:
x2 == (MoreEdge x5 x6), x8 == (MoreEdge x5 x2), graph == (Graph x2), edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x8, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, edgeNum x8 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x2 == (MoreEdge x5 x6) && (x8 == (MoreEdge x5 x2) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x8 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       x2) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 x2))
Trying x5
Checking x5 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A6 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 x5))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: Edges A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- {a|U4}
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|False} <: {a|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument NoEdge of type {Edges {A7|False}|_v == (NoEdge)}
Checking MoreEdge x5
           NoEdge :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A6|_v == (MoreEdge x5 (NoEdge))} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A6|_v == (MoreEdge x5 (NoEdge))} <: Edges A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 (NoEdge))} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument MoreEdge x5
                       NoEdge of type {Edges A6|_v == (MoreEdge x5 (NoEdge))}
Checking Graph (MoreEdge x5
                  NoEdge) :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:({Edges A6|_v == (MoreEdge x5 (NoEdge))}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:({Edges A6|_v == (MoreEdge x5 (NoEdge))}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x8 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 1)
Invalid Constraint: C1 && (M0 && (x8 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x8 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x2 == (MoreEdge x5 x6), x8 == (MoreEdge x5 (NoEdge)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size _v == edgeNum x8, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, edgeNum x8 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x2 == (MoreEdge x5 x6) && (x8 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x8 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge) && (nodeSet (NoEdge) == [] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       NoEdge) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 NoEdge))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: Edges A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 Nil))
Trying x6
Checking x6 :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A6 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x6 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x6 ??))
Trying graph
Checking graph :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A6 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge graph ??))
Trying x2
Checking x2 :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A6 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x2 ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: Edge A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge NoEdge ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: Edge A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge Nil ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf
                            (nodesOf ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Cons
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf
                            (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Edge
                                     ?? ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Cons
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf
                            (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Edge
                                     ?? ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Edge
                                     ?? ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x7]U1 && (_v == (Cons x7 x8) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x8 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Trying x5
Checking x5 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: A4 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x5 ??
Trying x6
Checking x6 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: A4 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x6 ??
Trying graph
Checking graph :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A4 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons graph ??
Trying x2
Checking x2 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: A4 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x2 ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A5|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons NoEdge ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A5|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons Nil ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x7]U1 && (_v == (Cons x7 x8) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x8 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)}
Trying Graph
Checking Graph :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'UnweightedGraph (A5)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Graph
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (nodesOf
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (MoreEdge
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Cons ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x7]U1 && (_v == (Cons x7 x8) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x8 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)}
Trying Graph
Checking Graph :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'UnweightedGraph (A5)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Graph
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (nodesOf
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (MoreEdge
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Cons ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (MoreEdge
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Cons ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edges A4 -> {UnweightedGraph A4|_v == (Graph x7)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Graph ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:UnweightedGraph A4 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:{UnweightedGraph A4|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x7} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:UnweightedGraph A4 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH {a|False} PRODUCING {a|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {a|U1}
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|False} <: {a|U1} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices x7} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x7 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size x7 >= 0 && (size x7 >= 0 && size x7 < size graph)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edges A5 -> {UnweightedGraph A5|_v == (Graph x8)} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- {a|U2}
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (_v == (Graph x8) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph))))))))
  C1 && (M0 && (U1 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x9:Edges A6 -> {UnweightedGraph A6|_v == (Graph x9)}
Trying Graph
Checking Graph :: X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A6 -> {UnweightedGraph A6|_v == (Graph x9)} <: X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A6 -> {UnweightedGraph A6|_v == (Graph x9)} /\ X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A6 -> {UnweightedGraph A6|_v == (Graph x9)} /\ X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A6 -> {UnweightedGraph A6|_v == (Graph x9)} <: X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (Graph ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x9:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (nodesOf ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (Cons ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- {a|U3}
X2, X3, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x2, x5, x6, x9 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x9 x10)} /\ Edges ()
graph, nodesOf, x10, x2, x5, x6, x9 True, C1, M0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x2, x5, x6, x9 True, C1, M0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, X3, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Trying x5
Checking x5 :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge|_v == x5} <: Edge ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument x5 of type {Edge a|_v == x5}
Checking MoreEdge
           x5 :: X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x10:Edges A6 -> {Edges A6|_v == (MoreEdge x5 x10)} <: X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x10:Edges A6 -> {Edges A6|_v == (MoreEdge x5 x10)} /\ X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x10:Edges A6 -> {Edges A6|_v == (MoreEdge x5 x10)} /\ X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x10:Edges A6 -> {Edges A6|_v == (MoreEdge x5 x10)} <: X2:_ -> Edges A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
X2, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 X2)} <: Edges ()
X2, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x10)} /\ Edges ()
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x11:Edges A7 -> {UnweightedGraph A7|_v == (Graph x11)}
Trying Graph
Checking Graph :: X4:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edges A7 -> {UnweightedGraph A7|_v == (Graph x11)} <: X4:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edges A7 -> {UnweightedGraph A7|_v == (Graph x11)} /\ X4:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edges A7 -> {UnweightedGraph A7|_v == (Graph x11)} /\ X4:_ -> Edges A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edges A7 -> {UnweightedGraph A7|_v == (Graph x11)} <: X4:_ -> Edges A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X4:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (Graph ??)))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x11:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x11}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x11} <: X4:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x11} /\ X4:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x11} /\ X4:_ -> Edges A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x11} <: X4:_ -> Edges A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X4:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (nodesOf ??)))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x11:A7 -> x12:List A7 -> {List A7|_v == (Cons x11 x12)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (?? ?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:A7 -> x12:List A7 -> {List A7|_v == (Cons x11 x12)} <: X5:_ -> X4:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:A7 -> x12:List A7 -> {List A7|_v == (Cons x11 x12)} /\ X5:_ -> X4:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:A7 -> x12:List A7 -> {List A7|_v == (Cons x11 x12)} /\ X5:_ -> X4:_ -> Edges A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:A7 -> x12:List A7 -> {List A7|_v == (Cons x11 x12)} <: X5:_ -> X4:_ -> Edges A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X5:_ -> X4:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (Cons ?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x11:Edge A7 -> x12:Edges A7 -> {Edges A7|_v == (MoreEdge x11 x12)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (?? ?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edge A7 -> x12:Edges A7 -> {Edges A7|_v == (MoreEdge x11 x12)} <: X5:_ -> X4:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edge A7 -> x12:Edges A7 -> {Edges A7|_v == (MoreEdge x11 x12)} /\ X5:_ -> X4:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edge A7 -> x12:Edges A7 -> {Edges A7|_v == (MoreEdge x11 x12)} /\ X5:_ -> X4:_ -> Edges A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edge A7 -> x12:Edges A7 -> {Edges A7|_v == (MoreEdge x11 x12)} <: X5:_ -> X4:_ -> Edges A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- {a|U4}
X4, X5, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge X5 X4)} <: Edges ()
X4, X5, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x11, x12, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x11 x12)} /\ Edges ()
graph, nodesOf, x11, x12, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x11, x12, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, X5, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Trying x6
Checking x6 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x6 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x6 ??)))
Trying graph
Checking graph :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge graph
                                                     ??)))
Trying x2
Checking x2 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x2 ??)))
Trying x5
Checking x5 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge|_v == x5} <: Edge ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U4} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x5 of type {Edge a|_v == x5}
Checking MoreEdge
           x5 :: X4:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x12:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x12)} <: X4:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x12:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x12)} /\ X4:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x12:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x12)} /\ X4:_ -> Edges A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x12:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x12)} <: X4:_ -> Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
X4, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 X4)} <: Edges ()
X4, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x12, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x12)} /\ Edges ()
graph, nodesOf, x12, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x12, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Trying x6
Checking x6 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U4} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge x5
           x6 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 x6)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 x6)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       x6 of type {Edges A7|_v == (MoreEdge x5 x6)}
Checking MoreEdge x5 (MoreEdge
                        x5 x6) :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x10:({Edges A7|_v == (MoreEdge x5 x6)}) IN {Edges A6|_v == (MoreEdge x5 x10)} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x10:({Edges A7|_v == (MoreEdge x5 x6)}) IN {Edges A6|_v == (MoreEdge x5 x10)} <: Edges A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x10)} <: Edges ()
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       (MoreEdge x5
                          x6) of type LET x10:({Edges A7|_v == (MoreEdge x5 x6)}) IN {Edges A6|_v == (MoreEdge x5 x10)}
Checking Graph (MoreEdge x5
                  (MoreEdge x5
                     x6)) :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:(LET x10:({Edges A7|_v == (MoreEdge x5 x6)}) IN {Edges A6|_v == (MoreEdge x5 x10)}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:(LET x10:({Edges A7|_v == (MoreEdge x5 x6)}) IN {Edges A6|_v == (MoreEdge x5 x10)}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x10 == (MoreEdge x5 x6) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x10 == (MoreEdge x5 x6) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x10 == (MoreEdge x5 x6) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x10)) == 1 + edgeNum x10, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x10)) == nodes x5 + nodeSet x10, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2
All assumptions:
x10 == (MoreEdge x5 x6), x2 == (MoreEdge x5 x6), x8 == (MoreEdge x5 x10), graph == (Graph x2), edgeNum ((MoreEdge x5 x10)) == 1 + edgeNum x10, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x8, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x10)) == nodes x5 + nodeSet x10, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2, edgeNum x10 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, edgeNum x8 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x10 == (MoreEdge x5 x6) && (x2 == (MoreEdge x5 x6) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x10)) == 1 + edgeNum x10 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x8 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x10)) == nodes x5 + nodeSet x10 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       (MoreEdge x5 x6)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5 x6)))
Trying graph
Checking graph :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5
                                                     graph)))
Trying x2
Checking x2 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- a <: {a|U4} ()
Constraints
  C1 && (M0 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge x5
           x2 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 x2)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 x2)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x2)} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       x2 of type {Edges A7|_v == (MoreEdge x5 x2)}
Checking MoreEdge x5 (MoreEdge
                        x5 x2) :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x10:({Edges A7|_v == (MoreEdge x5 x2)}) IN {Edges A6|_v == (MoreEdge x5 x10)} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x10:({Edges A7|_v == (MoreEdge x5 x2)}) IN {Edges A6|_v == (MoreEdge x5 x10)} <: Edges A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x10)} <: Edges ()
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       (MoreEdge x5
                          x2) of type LET x10:({Edges A7|_v == (MoreEdge x5 x2)}) IN {Edges A6|_v == (MoreEdge x5 x10)}
Checking Graph (MoreEdge x5
                  (MoreEdge x5
                     x2)) :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:(LET x10:({Edges A7|_v == (MoreEdge x5 x2)}) IN {Edges A6|_v == (MoreEdge x5 x10)}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:(LET x10:({Edges A7|_v == (MoreEdge x5 x2)}) IN {Edges A6|_v == (MoreEdge x5 x10)}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x10 == (MoreEdge x5 x2) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x10 == (MoreEdge x5 x2) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x10 == (MoreEdge x5 x2) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x10)) == 1 + edgeNum x10, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x10)) == nodes x5 + nodeSet x10, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2
All assumptions:
x10 == (MoreEdge x5 x2), x2 == (MoreEdge x5 x6), x8 == (MoreEdge x5 x10), graph == (Graph x2), edgeNum ((MoreEdge x5 x10)) == 1 + edgeNum x10, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x8, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x10)) == nodes x5 + nodeSet x10, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, vertices ((Graph x2)) == nodeSet x2, edgeNum x10 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, edgeNum x8 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x10 == (MoreEdge x5 x2) && (x2 == (MoreEdge x5 x6) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x10)) == 1 + edgeNum x10 && (edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x8 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x10)) == nodes x5 + nodeSet x10 && (nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       (MoreEdge x5 x2)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5 x2)))
Trying x5
Checking x5 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5 x5)))
Adding constraint graph, nodesOf, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edges A7 ()
graph, nodesOf, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
A8 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
A8 -> {a|U5}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- {a|U5}
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|False} <: {a|U4} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Synthesized argument NoEdge of type {Edges {A8|False}|_v == (NoEdge)}
Checking MoreEdge x5
           NoEdge :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 (NoEdge))} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 (NoEdge))} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
A8 -> {a|U5}
Simple Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 (NoEdge))} <: Edges ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       NoEdge of type {Edges A7|_v == (MoreEdge x5 (NoEdge))}
Checking MoreEdge x5 (MoreEdge
                        x5 NoEdge) :: Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x10:({Edges A7|_v == (MoreEdge x5 (NoEdge))}) IN {Edges A6|_v == (MoreEdge x5 x10)} <: Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x10:({Edges A7|_v == (MoreEdge x5 (NoEdge))}) IN {Edges A6|_v == (MoreEdge x5 x10)} <: Edges A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
A8 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x10)} <: Edges ()
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       (MoreEdge x5
                          NoEdge) of type LET x10:({Edges A7|_v == (MoreEdge x5 (NoEdge))}) IN {Edges A6|_v == (MoreEdge x5 x10)}
Checking Graph (MoreEdge x5
                  (MoreEdge x5
                     NoEdge)) :: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:(LET x10:({Edges A7|_v == (MoreEdge x5 (NoEdge))}) IN {Edges A6|_v == (MoreEdge x5 x10)}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- LET x8:(LET x10:({Edges A7|_v == (MoreEdge x5 (NoEdge))}) IN {Edges A6|_v == (MoreEdge x5 x10)}) IN {UnweightedGraph A5|_v == (Graph x8)} <: {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
A8 -> {a|U5}
Simple Constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x8)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x2, x5, x6, x8 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x8} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x10 == (MoreEdge x5 (NoEdge)) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x10 == (MoreEdge x5 (NoEdge)) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x10 == (MoreEdge x5 (NoEdge)) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (size _v == edgeNum x8 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x10)) == 1 + edgeNum x10, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x10)) == nodes x5 + nodeSet x10, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x10 == (MoreEdge x5 (NoEdge)), x2 == (MoreEdge x5 x6), x8 == (MoreEdge x5 x10), graph == (Graph x2), edgeNum ((MoreEdge x5 x10)) == 1 + edgeNum x10, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size _v == edgeNum x8, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x10)) == nodes x5 + nodeSet x10, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], vertices ((Graph x2)) == nodeSet x2, edgeNum x10 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, edgeNum x8 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x10 == (MoreEdge x5 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (x8 == (MoreEdge x5 x10) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x10)) == 1 + edgeNum x10 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x8 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x10)) == nodes x5 + nodeSet x10 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge) && (nodeSet (NoEdge) == [] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x10 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (edgeNum x8 >= 0 && size graph >= 0))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       (MoreEdge x5 NoEdge)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5
                                                     NoEdge)))
Adding constraint graph, nodesOf, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edges A7 ()
graph, nodesOf, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U4} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge x5 Nil)))
Adding constraint graph, nodesOf, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edge A7 ()
graph, nodesOf, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U4} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge NoEdge
                                                     ??)))
Adding constraint graph, nodesOf, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edge A7 ()
graph, nodesOf, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U4} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (MoreEdge Nil ??)))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x11:Int -> x12:Int -> x13:A7 -> {Edge A7|_v == (Edge x11 x12 x13)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (?? ?? ?? ??)))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Int -> x12:Int -> x13:A7 -> {Edge A7|_v == (Edge x11 x12 x13)} <: X6:_ -> X5:_ -> X4:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Int -> x12:Int -> x13:A7 -> {Edge A7|_v == (Edge x11 x12 x13)} /\ X6:_ -> X5:_ -> X4:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Int -> x12:Int -> x13:A7 -> {Edge A7|_v == (Edge x11 x12 x13)} /\ X6:_ -> X5:_ -> X4:_ -> Edges A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Int -> x12:Int -> x13:A7 -> {Edge A7|_v == (Edge x11 x12 x13)} <: X6:_ -> X5:_ -> X4:_ -> Edges A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X6:_ -> X5:_ -> X4:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x5 (Edge ?? ?? ??)))
Trying x6
Checking x6 :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A6 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x6 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x6 ??))
Trying graph
Checking graph :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A6 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge graph ??))
Trying x2
Checking x2 :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A6 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge x2 ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: Edge A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge NoEdge ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: Edge A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge Nil ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A6 -> x10:List A6 -> {List A6|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (Cons ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A6 -> x10:Edges A6 -> {Edges A6|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- {a|U3}
X2, X3, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x2, x5, x6, x9 True, C1, M0, graph == (Graph x2) |- {Edges|_v == (MoreEdge x9 x10)} /\ Edges ()
graph, nodesOf, x10, x2, x5, x6, x9 True, C1, M0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x2, x5, x6, x9 True, C1, M0, graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, X3, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x11:Edges A7 -> {UnweightedGraph A7|_v == (Graph x11)}
Trying Graph
Checking Graph :: X4:_ -> Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edges A7 -> {UnweightedGraph A7|_v == (Graph x11)} <: X4:_ -> Edge A6 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edges A7 -> {UnweightedGraph A7|_v == (Graph x11)} /\ X4:_ -> Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edges A7 -> {UnweightedGraph A7|_v == (Graph x11)} /\ X4:_ -> Edge A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edges A7 -> {UnweightedGraph A7|_v == (Graph x11)} <: X4:_ -> Edge A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking Graph ::
X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Graph ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x11:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x11}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x11} <: X4:_ -> Edge A6 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x11} /\ X4:_ -> Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x11} /\ X4:_ -> Edge A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x11} <: X4:_ -> Edge A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (nodesOf ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x11:A7 -> x12:List A7 -> {List A7|_v == (Cons x11 x12)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (?? ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:A7 -> x12:List A7 -> {List A7|_v == (Cons x11 x12)} <: X5:_ -> X4:_ -> Edge A6 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:A7 -> x12:List A7 -> {List A7|_v == (Cons x11 x12)} /\ X5:_ -> X4:_ -> Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:A7 -> x12:List A7 -> {List A7|_v == (Cons x11 x12)} /\ X5:_ -> X4:_ -> Edge A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:A7 -> x12:List A7 -> {List A7|_v == (Cons x11 x12)} <: X5:_ -> X4:_ -> Edge A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Cons ::
X5:_ -> X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Cons ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x11:Edge A7 -> x12:Edges A7 -> {Edges A7|_v == (MoreEdge x11 x12)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (?? ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edge A7 -> x12:Edges A7 -> {Edges A7|_v == (MoreEdge x11 x12)} <: X5:_ -> X4:_ -> Edge A6 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edge A7 -> x12:Edges A7 -> {Edges A7|_v == (MoreEdge x11 x12)} /\ X5:_ -> X4:_ -> Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edge A7 -> x12:Edges A7 -> {Edges A7|_v == (MoreEdge x11 x12)} /\ X5:_ -> X4:_ -> Edge A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Edge A7 -> x12:Edges A7 -> {Edges A7|_v == (MoreEdge x11 x12)} <: X5:_ -> X4:_ -> Edge A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking MoreEdge ::
X5:_ -> X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (MoreEdge ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x11:Int -> x12:Int -> x13:A7 -> {Edge A7|_v == (Edge x11 x12 x13)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> Edge A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (?? ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Int -> x12:Int -> x13:A7 -> {Edge A7|_v == (Edge x11 x12 x13)} <: X6:_ -> X5:_ -> X4:_ -> Edge A6 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Int -> x12:Int -> x13:A7 -> {Edge A7|_v == (Edge x11 x12 x13)} /\ X6:_ -> X5:_ -> X4:_ -> Edge A6 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Int -> x12:Int -> x13:A7 -> {Edge A7|_v == (Edge x11 x12 x13)} /\ X6:_ -> X5:_ -> X4:_ -> Edge A6 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x11:Int -> x12:Int -> x13:A7 -> {Edge A7|_v == (Edge x11 x12 x13)} <: X6:_ -> X5:_ -> X4:_ -> Edge A6 ()
graph, nodesOf, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {a|U1}
A5 -> {a|U2}
A6 -> {a|U3}
A7 -> {a|U4}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- {a|U4}
X4, X5, X6, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge|_v == (Edge X6 X5 X4)} <: Edge ()
X4, X5, X6, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x11, x12, x13, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge|_v == (Edge x11 x12 x13)} /\ Edge ()
graph, nodesOf, x11, x12, x13, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x11, x12, x13, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, X5, X6, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Trying x5
Checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Int ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: Int ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge x5 ?? ??) ??))
Trying x6
Checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Int ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: Int ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge x6 ?? ??) ??))
Trying graph
Checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Int ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Int ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge graph ?? ??)
                                        ??))
Trying x2
Checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Int ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: Int ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge x2 ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Int ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Int ()
graph, nodesOf, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'Edges (A8)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge NoEdge ?? ??)
                                        ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge ?? ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Int ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Int ()
graph, nodesOf, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'List (A8)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (MoreEdge (Edge Nil ?? ??) ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (?? ?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A6 -> {Edge A6|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> Edges A5 ()
graph, nodesOf, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Graph
                                     (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} /\ X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x8} <: X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf
                            (nodesOf ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Cons
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf
                            (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Edge
                                     ?? ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Cons
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf
                            (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Edge
                                     ?? ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Edge
                                     ?? ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:A5 -> x9:List A5 -> {List A5|_v == (Cons x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Cons
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} /\ X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Edge A5 -> x9:Edges A5 -> {Edges A5|_v == (MoreEdge x8 x9)} <: X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf
                            (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Edge
                                     ?? ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Edge
                                     ?? ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (?? ??
                                     ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x8:Int -> x9:Int -> x10:A5 -> {Edge A5|_v == (Edge x8 x9 x10)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A4|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x2, x5, x6 |- A5
UNIFY A5 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> nodesOf (Edge
                                     ?? ?? ??)
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x7]U1 && (_v == (Cons x7 x8) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x8 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Trying x5
Checking x5 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: A4 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x5 ??
Trying x6
Checking x6 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x6} <: A4 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x6 ??
Trying graph
Checking graph :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A4 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons graph ??
Trying x2
Checking x2 :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges a|_v == x2} <: A4 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons x2 ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A5|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons NoEdge ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A5|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons Nil ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x7]U1 && (_v == (Cons x7 x8) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x8 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)}
Trying Graph
Checking Graph :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'UnweightedGraph (A5)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Graph
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (nodesOf
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (MoreEdge
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Cons ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x7]U1 && (_v == (Cons x7 x8) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x8 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)}
Trying Graph
Checking Graph :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'UnweightedGraph (A5)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Graph
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (nodesOf
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (MoreEdge
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Cons ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (MoreEdge
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Cons ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:A4 -> x8:List A4 -> {List A4|_v == (Cons x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x2, x5, x6, x7, x8 True, C1, M0, graph == (Graph x2) |- {List|_v == (Cons x7 x8)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x7]U1 && (_v == (Cons x7 x8) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x8 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)}
Trying Graph
Checking Graph :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edges A5 -> {UnweightedGraph A5|_v == (Graph x9)} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'UnweightedGraph (A5)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Graph
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9}
Trying nodesOf
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??)
                            ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} /\ X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x9} <: X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (nodesOf
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (MoreEdge
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Cons ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (MoreEdge
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Cons ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Edge A5 -> x10:Edges A5 -> {Edges A5|_v == (MoreEdge x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edges (A5)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (MoreEdge
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} /\ X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:A5 -> x10:List A5 -> {List A5|_v == (Cons x9 x10)} <: X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'List (A5)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Cons ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A4 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (?? ?? ??
                                  ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} /\ X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x9:Int -> x10:Int -> x11:A5 -> {Edge A5|_v == (Edge x9 x10 x11)} <: X4:_ -> X3:_ -> X2:_ -> A4 ()
graph, nodesOf, x2, x5, x6 |- A5
TYPE ERROR: Cannot match shape 'Edge (A5)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Cons (Edge ??
                                  ?? ??) ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Edge A4 -> x8:Edges A4 -> {Edges A4|_v == (MoreEdge x7 x8)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> MoreEdge ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 True, C1, M0, graph == (Graph x2) |- x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x2, x5, x6 |- A4
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2 |- A3
UNIFY A4 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> Edge ?? ?? ??
Looking for type _
Trying x5
Checking x5 :: _ in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match ?? with
Adding constraint graph, nodesOf, x2, x5, x6 True, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: _ ()
Typing Constraints
graph, nodesOf, x2, x5, x6 True, M0, graph == (Graph x2) |- {Edge a|_v == x5} <: _ ()
graph, nodesOf, x2 |- A3
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
Simple Constraints
graph, nodesOf, x2 |- a
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}] (1 0)
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
Simple Constraints
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}] (1 0)
Auxiliary goals are:
Adding constraint graph, nodesOf, x2, x5, x6 |- A4
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x7:Int -> x8:Int -> x9:A4 -> {Edge A4|_v == (Edge x7 x8 x9)}
Matching constructor type
{Edge A4|_v == (Edge x7 x8 x9)}
with scrutinee
{Edge a|_v == x5}
Adding constraint graph, nodesOf, x2, x5, x6 |- C1
Checking error in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> error
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|x10 == x10 && (x11 == x11 && (x12 == x12 && (x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph)))))} <: {Int|False} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|x10 == x10 && (x11 == x11 && (x12 == x12 && (x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph)))))} <: {Int|False} ()
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|x10 == x10 && (x11 == x11 && (x12 == x12 && (x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph)))))} <: {Int|False} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|x10 == x10 && (x11 == x11 && (x12 == x12 && (x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph)))))} <: {Int|False} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (x10 == x10 && (x11 == x11 && (x12 == x12 && (x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph)))))))))))) ==> False
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}] (1 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}] (1 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (x10 == x10 && (x11 == x11 && (x12 == x12 && (x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph)))))))))))) ==> False
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (x10 == x10 && (x11 == x11 && (x12 == x12 && (x5 == x5 && (x2 == x2 && (x6 == x6 && graph == graph)))))))))))) ==> False
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x10 == x10, x11 == x11, x12 == x12, x5 == x5, x5 == (Edge x10 x11 x12), x2 == x2, x2 == (MoreEdge x5 x6), x6 == x6, graph == graph, graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: False
assumption True
mustHave x10 == x10 && (x11 == x11 && (x12 == x12 && (x5 == x5 && (x5 == (Edge x10 x11 x12) && (x2 == x2 && (x2 == (MoreEdge x5 x6) && (x6 == x6 && (graph == graph && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> error
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
Looking for type {List Int|elems _v == vertices graph}
Trying x10
Checking x10 :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (Int)'
when checking x10 ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> x10
Trying x11
Checking x11 :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (Int)'
when checking x11 ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> x11
Trying x12
Checking x12 :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
TYPE ERROR: Cannot match shape 'a'
with shape 'List (Int)'
when checking x12 ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> x12
Trying x6
Checking x6 :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> x6
Trying graph
Checking graph :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> graph
Trying x2
Checking x2 :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> x2
Trying x5
Checking x5 :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> x5
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A5|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A5|False}|_v == (NoEdge)} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> NoEdge
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A5|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A5|False}|_v == (Nil)} <: {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U1}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == []} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == []} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == [] && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (1 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (1 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == [] && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == [] && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, elems _v == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Nil ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Nil
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Graph ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH {a|False} PRODUCING {a|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U1}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U1} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x13 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size x13 >= 0 && (size x13 >= 0 && size x13 < size graph))))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Trying x10
Checking x10 :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A5)'
when checking x10 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf x10
Trying x11
Checking x11 :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A5)'
when checking x11 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf x11
Trying x12
Checking x12 :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'UnweightedGraph (A5)'
when checking x12 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf x12
Trying x6
Checking x6 :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x6 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf x6
Trying graph
Checking graph :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), _v == graph, graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v >= 0 && size _v < size graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (_v == graph && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))
mustHave !(size _v >= 0 && size _v < size graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking graph ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  graph
Trying x2
Checking x2 :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf x2
Trying x5
Checking x5 :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking x5 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf x5
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A6|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  NoEdge
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Nil ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf Nil
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x13]U1 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x13 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Trying x10
Checking x10 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U1} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X0)} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x10 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Trying x11
Checking x11 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A5 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A5)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 x11
Trying x12
Checking x12 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A5)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 x12
Trying x6
Checking x6 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 x6
Trying graph
Checking graph :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  graph
Trying x10
Checking x10 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A5 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A5)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 x10
Trying x2
Checking x2 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 x2
Trying x5
Checking x5 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 x5
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A6|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  NoEdge
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U2}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U1} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (3 0)
Synthesized argument Nil of type {List {A6|False}|_v == (Nil)}
Checking Cons x10
           Nil :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A5|_v == (Cons x10 (Nil))} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A5|_v == (Cons x10 (Nil))} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 (Nil))} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems (Nil)} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems (Nil)} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == [x10] + elems (Nil) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (3 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (3 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == [x10] + elems (Nil) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == [x10] + elems (Nil) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x10] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x10] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x10 Nil ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 Nil
Trying x11
Checking x11 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U1} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X0)} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x11 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Trying x10
Checking x10 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A5 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A5)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 x10
Trying x12
Checking x12 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A5)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 x12
Trying x6
Checking x6 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 x6
Trying graph
Checking graph :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  graph
Trying x11
Checking x11 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A5 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A5)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 x11
Trying x2
Checking x2 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 x2
Trying x5
Checking x5 :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 x5
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A6|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  NoEdge
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U2}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U1} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (3 0)
Synthesized argument Nil of type {List {A6|False}|_v == (Nil)}
Checking Cons x11
           Nil :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A5|_v == (Cons x11 (Nil))} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A5|_v == (Cons x11 (Nil))} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 (Nil))} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems (Nil)} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems (Nil)} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == [x11] + elems (Nil) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (3 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (3 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == [x11] + elems (Nil) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == [x11] + elems (Nil) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x11] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x11 Nil ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 Nil
Trying x12
Checking x12 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x12 ??
Trying x6
Checking x6 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A5 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x6 ??
Trying graph
Checking graph :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A5 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons graph
                                  ??
Trying x2
Checking x2 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A5 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x2 ??
Trying x5
Checking x5 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A5 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x5 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A6|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edges (A6)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons NoEdge
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'List (A6)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons Nil ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> MoreEdge ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Edge ?? ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Graph ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH {a|False} PRODUCING {a|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U1}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U1} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x13 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size x13 >= 0 && (size x13 >= 0 && size x13 < size graph))))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U2}
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Graph x14) && (graph == (Graph x2) && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph)))))))))
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying x10
Checking x10 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A6 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A6)'
when checking x10 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph x10)
Trying x11
Checking x11 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A6 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A6)'
when checking x11 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph x11)
Trying x12
Checking x12 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A6)'
when checking x12 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph x12)
Trying x6
Checking x6 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U2} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking Graph
           x6 :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A6|_v == (Graph x6)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A6|_v == (Graph x6)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x6)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x6} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x6} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x6 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (6 0)
Synthesized argument Graph
                       x6 of type {UnweightedGraph A6|_v == (Graph x6)}
Checking nodesOf (Graph
                    x6) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x13:({UnweightedGraph A6|_v == (Graph x6)}) IN {List Int|elems _v == vertices x13} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x13:({UnweightedGraph A6|_v == (Graph x6)}) IN {List Int|elems _v == vertices x13} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x13 == (Graph x6) && (elems _v == vertices x13 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x13 >= 0)))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x13 == (Graph x6) && (elems _v == vertices x13 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x13 >= 0)))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x13 == (Graph x6) && (elems _v == vertices x13 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x13 >= 0)))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, size ((Graph x6)) == edgeNum x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph x6)) == nodeSet x6
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), x13 == (Graph x6), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, size ((Graph x6)) == edgeNum x6, elems _v == vertices x13, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph x6)) == nodeSet x6, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0, size x13 >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (x13 == (Graph x6) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (size ((Graph x6)) == edgeNum x6 && (elems _v == vertices x13 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (vertices ((Graph x6)) == nodeSet x6 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x13 >= 0))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking nodesOf (Graph x6)
::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph x6)
Trying graph
Checking graph :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A6 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph graph)
Trying x2
Checking x2 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U2} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking Graph
           x2 :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A6|_v == (Graph x2)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A6|_v == (Graph x2)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x2)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x2} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x2} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x2, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x2 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph x2)
Trying x5
Checking x5 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A6 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph x5)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U2} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (4 0)
Synthesized argument NoEdge of type {Edges {A7|False}|_v == (NoEdge)}
Checking Graph
           NoEdge :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A6|_v == (Graph (NoEdge))} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A6|_v == (Graph (NoEdge))} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph (NoEdge))} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum (NoEdge) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Synthesized argument Graph
                       NoEdge of type {UnweightedGraph A6|_v == (Graph (NoEdge))}
Checking nodesOf (Graph
                    NoEdge) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x13:({UnweightedGraph A6|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x13} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x13:({UnweightedGraph A6|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x13} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x13 == (Graph (NoEdge)) && (elems _v == vertices x13 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x13 >= 0)))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x13 == (Graph (NoEdge)) && (elems _v == vertices x13 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x13 >= 0)))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x13 == (Graph (NoEdge)) && (elems _v == vertices x13 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x13 >= 0)))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, size ((Graph (NoEdge))) == edgeNum (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph (NoEdge))) == nodeSet (NoEdge)
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), x13 == (Graph (NoEdge)), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, size ((Graph (NoEdge))) == edgeNum (NoEdge), elems _v == vertices x13, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph (NoEdge))) == nodeSet (NoEdge), edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0, size x13 >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (x13 == (Graph (NoEdge)) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum (NoEdge) == 0 && (size ((Graph x2)) == edgeNum x2 && (size ((Graph (NoEdge))) == edgeNum (NoEdge) && (elems _v == vertices x13 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (vertices ((Graph (NoEdge))) == nodeSet (NoEdge) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && size x13 >= 0))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking nodesOf (Graph
                         NoEdge) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph NoEdge)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph Nil)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x13]U1 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x13 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Trying x10
Checking x10 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U1} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X0)} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x10 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)}
Trying Graph
Checking Graph :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|False} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U2}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U2} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X2} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x15} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ {Int|U1} ()
Pred assignment
After process simple constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying x11
Checking x11 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A6)'
when checking x11 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf x11)
Trying x12
Checking x12 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'UnweightedGraph (A6)'
when checking x12 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf x12)
Trying x6
Checking x6 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x6 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf x6)
Trying graph
Checking graph :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), _v == graph, graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v >= 0 && size _v < size graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (_v == graph && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))
mustHave !(size _v >= 0 && size _v < size graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking graph ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf graph)
Trying x10
Checking x10 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A6)'
when checking x10 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf x10)
Trying x2
Checking x2 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf x2)
Trying x5
Checking x5 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking x5 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf x5)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf NoEdge)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Nil ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf Nil)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X3:_ -> X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U2}
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X3 X2)} <: List ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x15 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying x11
Checking x11 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U2} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} <: X2:_ -> List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X2)} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Trying x12
Checking x12 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 x12)
Trying x6
Checking x6 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 x6)
Trying graph
Checking graph :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 graph)
Trying x10
Checking x10 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A6 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A6)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 x10)
Trying x11
Checking x11 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A6 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A6)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 x11)
Trying x2
Checking x2 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 x2)
Trying x5
Checking x5 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 x5)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 NoEdge)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U3}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U2} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons x11
           Nil :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A6|_v == (Cons x11 (Nil))} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A6|_v == (Cons x11 (Nil))} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Synthesized argument Cons x11
                       Nil of type {List A6|_v == (Cons x11 (Nil))}
Checking Cons x10 (Cons x11
                     Nil) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({List A6|_v == (Cons x11 (Nil))}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({List A6|_v == (Cons x11 (Nil))}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x11 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x10] + elems x14, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x11 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x11 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x10] + elems x14 && (elems ((Cons x11 (Nil))) == [x11] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x10 (Cons x11
                          Nil) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 Nil)
Trying x12
Checking x12 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x12 ??)
Trying x6
Checking x6 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A6 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x6 ??)
Trying graph
Checking graph :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A6 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons graph ??)
Trying x10
Checking x10 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U2} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} <: X2:_ -> List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X2)} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Trying x11
Checking x11 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A6 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A6)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 x11)
Trying x12
Checking x12 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 x12)
Trying x6
Checking x6 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 x6)
Trying graph
Checking graph :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 graph)
Trying x2
Checking x2 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 x2)
Trying x5
Checking x5 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 x5)
Trying x10
Checking x10 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A6 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A6)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 x10)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 NoEdge)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U3}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U2} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons x10
           Nil :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A6|_v == (Cons x10 (Nil))} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A6|_v == (Cons x10 (Nil))} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Synthesized argument Cons x10
                       Nil of type {List A6|_v == (Cons x10 (Nil))}
Checking Cons x10 (Cons x10
                     Nil) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({List A6|_v == (Cons x10 (Nil))}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({List A6|_v == (Cons x10 (Nil))}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x10 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x10] + elems x14, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x10 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x10 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x10] + elems x14 && (elems ((Cons x10 (Nil))) == [x10] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x10 (Cons x10
                          Nil) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 Nil)
Trying x2
Checking x2 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A6 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x2 ??)
Trying x5
Checking x5 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A6 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x5 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Edges (A7)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons NoEdge ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'List (A7)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons Nil ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Edge ?? ?? ??)
Trying x11
Checking x11 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U1} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X0)} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x11 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)}
Trying Graph
Checking Graph :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|False} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U2}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U2} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X2} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x15} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ {Int|U1} ()
Pred assignment
After process simple constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying x10
Checking x10 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A6)'
when checking x10 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf x10)
Trying x12
Checking x12 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'UnweightedGraph (A6)'
when checking x12 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf x12)
Trying x6
Checking x6 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x6 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf x6)
Trying graph
Checking graph :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), _v == graph, graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v >= 0 && size _v < size graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (_v == graph && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))
mustHave !(size _v >= 0 && size _v < size graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking graph ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf graph)
Trying x11
Checking x11 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A6)'
when checking x11 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf x11)
Trying x2
Checking x2 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf x2)
Trying x5
Checking x5 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking x5 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf x5)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf NoEdge)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Nil ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf Nil)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X3:_ -> X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U2}
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X3 X2)} <: List ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x15 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying x10
Checking x10 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U2} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} <: X2:_ -> List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X2)} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Trying x12
Checking x12 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 x12)
Trying x6
Checking x6 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 x6)
Trying graph
Checking graph :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 graph)
Trying x10
Checking x10 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A6 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A6)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 x10)
Trying x11
Checking x11 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A6 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A6)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 x11)
Trying x2
Checking x2 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 x2)
Trying x5
Checking x5 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 x5)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 NoEdge)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U3}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U2} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons x10
           Nil :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A6|_v == (Cons x10 (Nil))} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A6|_v == (Cons x10 (Nil))} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Synthesized argument Cons x10
                       Nil of type {List A6|_v == (Cons x10 (Nil))}
Checking Cons x11 (Cons x10
                     Nil) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({List A6|_v == (Cons x10 (Nil))}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({List A6|_v == (Cons x10 (Nil))}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x10 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x11] + elems x14, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x10 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x10 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x11] + elems x14 && (elems ((Cons x10 (Nil))) == [x10] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x11 (Cons x10
                          Nil) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 Nil)
Trying x12
Checking x12 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x12 ??)
Trying x6
Checking x6 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A6 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x6 ??)
Trying graph
Checking graph :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A6 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons graph ??)
Trying x11
Checking x11 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U2} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} <: X2:_ -> List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X2)} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Trying x10
Checking x10 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A6 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A6)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 x10)
Trying x12
Checking x12 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 x12)
Trying x6
Checking x6 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 x6)
Trying graph
Checking graph :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 graph)
Trying x2
Checking x2 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 x2)
Trying x5
Checking x5 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 x5)
Trying x11
Checking x11 :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A6 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A6)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 x11)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 NoEdge)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U3}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U2} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons x11
           Nil :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A6|_v == (Cons x11 (Nil))} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A6|_v == (Cons x11 (Nil))} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Synthesized argument Cons x11
                       Nil of type {List A6|_v == (Cons x11 (Nil))}
Checking Cons x11 (Cons x11
                     Nil) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({List A6|_v == (Cons x11 (Nil))}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({List A6|_v == (Cons x11 (Nil))}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x11 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x11] + elems x14, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x11 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x11 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x11] + elems x14 && (elems ((Cons x11 (Nil))) == [x11] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x11 (Cons x11
                          Nil) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 Nil)
Trying x2
Checking x2 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A6 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x2 ??)
Trying x5
Checking x5 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A6 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x5 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Edges (A7)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons NoEdge ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'List (A7)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons Nil ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Edge ?? ?? ??)
Trying x12
Checking x12 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x12 ??
Trying x6
Checking x6 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A5 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x6 ??
Trying graph
Checking graph :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A5 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons graph
                                  ??
Trying x2
Checking x2 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A5 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x2 ??
Trying x5
Checking x5 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A5 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x5 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A6|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edges (A6)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons NoEdge
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'List (A6)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons Nil ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> MoreEdge ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Edge ?? ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x13]U1 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x13 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)}
Trying Graph
Checking Graph :: X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??)
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'UnweightedGraph (A6)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Graph
                                        ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??)
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons
                                  (nodesOf ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edges (A6)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons
                                  (MoreEdge ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'List (A6)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Cons
                                        ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edge (A6)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Edge
                                        ?? ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> MoreEdge ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Edge ?? ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Edge ?? ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Graph ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH {a|False} PRODUCING {a|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U1}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U1} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x13 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size x13 >= 0 && (size x13 >= 0 && size x13 < size graph))))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U2}
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Graph x14) && (graph == (Graph x2) && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph)))))))))
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x15:Edges A7 -> {UnweightedGraph A7|_v == (Graph x15)}
Trying Graph
Checking Graph :: X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A7 -> {UnweightedGraph A7|_v == (Graph x15)} <: X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A7 -> {UnweightedGraph A7|_v == (Graph x15)} /\ X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A7 -> {UnweightedGraph A7|_v == (Graph x15)} /\ X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A7 -> {UnweightedGraph A7|_v == (Graph x15)} <: X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x15:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Trying x10
Checking x10 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A7)'
when checking x10 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x10 ??))
Trying x11
Checking x11 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A7)'
when checking x11 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x11 ??))
Trying x12
Checking x12 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edge (A7)'
when checking x12 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x12 ??))
Trying x6
Checking x6 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x6 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x6 ??))
Trying graph
Checking graph :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge graph ??))
Trying x2
Checking x2 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x2 ??))
Trying x5
Checking x5 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == x5} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument x5 of type {Edge a|_v == x5}
Checking MoreEdge
           x5 :: X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x16)} <: X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x16)} /\ X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x16)} /\ X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x16)} <: X2:_ -> Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 X2)} <: Edges ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x16)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x10
Checking x10 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x10 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 x10))
Trying x11
Checking x11 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x11 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 x11))
Trying x12
Checking x12 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A7)'
when checking x12 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 x12))
Trying x6
Checking x6 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge x5
           x6 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 x6)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 x6)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument MoreEdge x5
                       x6 of type {Edges A7|_v == (MoreEdge x5 x6)}
Checking Graph (MoreEdge x5
                  x6) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({Edges A7|_v == (MoreEdge x5 x6)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({Edges A7|_v == (MoreEdge x5 x6)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x14 == (MoreEdge x5 x6), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x6) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       x6) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 x6))
Trying graph
Checking graph :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 graph))
Trying x2
Checking x2 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge x5
           x2 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 x2)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 x2)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x2)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument MoreEdge x5
                       x2 of type {Edges A7|_v == (MoreEdge x5 x2)}
Checking Graph (MoreEdge x5
                  x2) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({Edges A7|_v == (MoreEdge x5 x2)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({Edges A7|_v == (MoreEdge x5 x2)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x14 == (MoreEdge x5 x2), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x2) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       x2) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 x2))
Trying x5
Checking x5 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 x5))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U4}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument NoEdge of type {Edges {A8|False}|_v == (NoEdge)}
Checking MoreEdge x5
           NoEdge :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 (NoEdge))} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A7|_v == (MoreEdge x5 (NoEdge))} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 (NoEdge))} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument MoreEdge x5
                       NoEdge of type {Edges A7|_v == (MoreEdge x5 (NoEdge))}
Checking Graph (MoreEdge x5
                  NoEdge) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({Edges A7|_v == (MoreEdge x5 (NoEdge))}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:({Edges A7|_v == (MoreEdge x5 (NoEdge))}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x14 == (MoreEdge x5 (NoEdge)), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge) && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       NoEdge) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge NoEdge ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge Nil ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x13]U1 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x13 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Trying x10
Checking x10 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U1} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X0)} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x10 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)}
Trying Graph
Checking Graph :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|False} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U2}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U2} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X2} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x15} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ {Int|U1} ()
Pred assignment
After process simple constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)}
Trying Graph
Checking Graph :: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X3)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x16)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
addSplitConstraint X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X3} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x16)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X3} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Graph x16) && (graph == (Graph x2) && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph)))))))))
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x11
Checking x11 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x11 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph x11))
Trying x12
Checking x12 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A7)'
when checking x12 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph x12))
Trying x6
Checking x6 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking Graph
           x6 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph x6)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph x6)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x6)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x6} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x6} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x6 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument Graph
                       x6 of type {UnweightedGraph A7|_v == (Graph x6)}
Checking nodesOf (Graph
                    x6) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({UnweightedGraph A7|_v == (Graph x6)}) IN {List Int|elems _v == vertices x15} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({UnweightedGraph A7|_v == (Graph x6)}) IN {List Int|elems _v == vertices x15} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x15} <: List ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument nodesOf
                       (Graph
                          x6) of type LET x15:({UnweightedGraph A7|_v == (Graph x6)}) IN {List Int|elems _v == vertices x15}
Checking Cons x10 (nodesOf
                     (Graph
                        x6)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({UnweightedGraph A7|_v == (Graph x6)}) IN {List Int|elems _v == vertices x15}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({UnweightedGraph A7|_v == (Graph x6)}) IN {List Int|elems _v == vertices x15}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph x6) && (elems _v == [x10] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph x6) && (elems _v == [x10] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph x6) && (elems _v == [x10] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, size ((Graph x6)) == edgeNum x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph x6)) == nodeSet x6
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), x15 == (Graph x6), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, size ((Graph x6)) == edgeNum x6, elems _v == [x10] + elems x14, elems x14 == vertices x15, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph x6)) == nodeSet x6, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, size graph >= 0, size x15 >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (x15 == (Graph x6) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (size ((Graph x6)) == edgeNum x6 && (elems _v == [x10] + elems x14 && (elems x14 == vertices x15 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (vertices ((Graph x6)) == nodeSet x6 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x10 (nodesOf
                          (Graph x6)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph x6))
Trying graph
Checking graph :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph graph))
Trying x10
Checking x10 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x10 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph x10))
Trying x2
Checking x2 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking Graph
           x2 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph x2)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph x2)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x2)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x2} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x2} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x2, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x2 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph x2))
Trying x5
Checking x5 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph x5))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U4}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument NoEdge of type {Edges {A8|False}|_v == (NoEdge)}
Checking Graph
           NoEdge :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph (NoEdge))} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph (NoEdge))} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph (NoEdge))} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum (NoEdge) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Graph
                       NoEdge of type {UnweightedGraph A7|_v == (Graph (NoEdge))}
Checking nodesOf (Graph
                    NoEdge) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({UnweightedGraph A7|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x15} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({UnweightedGraph A7|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x15} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x15} <: List ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument nodesOf
                       (Graph
                          NoEdge) of type LET x15:({UnweightedGraph A7|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x15}
Checking Cons x10 (nodesOf
                     (Graph
                        NoEdge)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({UnweightedGraph A7|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x15}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({UnweightedGraph A7|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x15}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph (NoEdge)) && (elems _v == [x10] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph (NoEdge)) && (elems _v == [x10] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph (NoEdge)) && (elems _v == [x10] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, size ((Graph (NoEdge))) == edgeNum (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph (NoEdge))) == nodeSet (NoEdge)
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), x15 == (Graph (NoEdge)), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, size ((Graph (NoEdge))) == edgeNum (NoEdge), elems _v == [x10] + elems x14, elems x14 == vertices x15, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph (NoEdge))) == nodeSet (NoEdge), edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, size graph >= 0, size x15 >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (x15 == (Graph (NoEdge)) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum (NoEdge) == 0 && (size ((Graph x2)) == edgeNum x2 && (size ((Graph (NoEdge))) == edgeNum (NoEdge) && (elems _v == [x10] + elems x14 && (elems x14 == vertices x15 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (vertices ((Graph (NoEdge))) == nodeSet (NoEdge) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0))))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x10 (nodesOf
                          (Graph NoEdge)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)}
Trying MoreEdge
Checking MoreEdge :: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)}
Trying Cons
Checking Cons :: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)}
Trying Edge
Checking Edge :: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} <: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} /\ X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} /\ X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} <: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X3:_ -> X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U2}
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X3 X2)} <: List ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x15 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying x11
Checking x11 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U2} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} <: X2:_ -> List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X2)} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)}
Trying Graph
Checking Graph :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X4:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|False} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X4} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x17} /\ List ()
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ {Int|U2} ()
Pred assignment
After process simple constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x12
Checking x12 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'UnweightedGraph (A7)'
when checking x12 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf x12))
Trying x6
Checking x6 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x6 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf x6))
Trying graph
Checking graph :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), _v == graph, graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v >= 0 && size _v < size graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (_v == graph && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))
mustHave !(size _v >= 0 && size _v < size graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking graph ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf graph))
Trying x10
Checking x10 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A7)'
when checking x10 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf x10))
Trying x11
Checking x11 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A7)'
when checking x11 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf x11))
Trying x2
Checking x2 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf x2))
Trying x5
Checking x5 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking x5 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf x5))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Nil ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X5:_ -> X4:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U3}
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X5 X4)} <: List ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x17 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x12
Checking x12 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x12 ??))
Trying x6
Checking x6 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A7 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x6 ??))
Trying graph
Checking graph :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons graph ??))
Trying x10
Checking x10 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U3} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} <: X4:_ -> List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X4)} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Trying x12
Checking x12 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 x12))
Trying x6
Checking x6 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 x6))
Trying graph
Checking graph :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 graph))
Trying x11
Checking x11 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 x11))
Trying x2
Checking x2 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 x2))
Trying x5
Checking x5 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 x5))
Trying x10
Checking x10 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 x10))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U4}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking Cons x10
           Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x10 (Nil))} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x10 (Nil))} <: List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x10
                       Nil of type {List A7|_v == (Cons x10 (Nil))}
Checking Cons x11 (Cons x10
                     Nil) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x11 x16)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x11 x16)} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x16)} <: List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x11
                       (Cons x10
                          Nil) of type LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x11 x16)}
Checking Cons x10 (Cons x11
                     (Cons x10
                        Nil)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x11 x16)}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x11 x16)}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 (Nil))) == 1 + len (Nil), len ((Cons x11 x16)) == 1 + len x16, len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems ((Cons x11 x16)) == [x11] + elems x16, elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x11 x16), x16 == (Cons x10 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 (Nil))) == 1 + len (Nil), len ((Cons x11 x16)) == 1 + len x16, len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x10] + elems x14, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems ((Cons x11 x16)) == [x11] + elems x16, elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, len x16 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x11 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x10 (Nil))) == 1 + len (Nil) && (len ((Cons x11 x16)) == 1 + len x16 && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x10] + elems x14 && (elems ((Cons x10 (Nil))) == [x10] + elems (Nil) && (elems ((Cons x11 x16)) == [x11] + elems x16 && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x10 (Cons x11
                          (Cons x10 Nil)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x10 Nil))
Trying x11
Checking x11 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U3} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} <: X4:_ -> List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X4)} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Trying x12
Checking x12 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 x12))
Trying x6
Checking x6 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 x6))
Trying graph
Checking graph :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 graph))
Trying x10
Checking x10 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 x10))
Trying x2
Checking x2 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 x2))
Trying x5
Checking x5 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 x5))
Trying x11
Checking x11 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 x11))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U4}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking Cons x11
           Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x11 (Nil))} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x11 (Nil))} <: List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x11
                       Nil of type {List A7|_v == (Cons x11 (Nil))}
Checking Cons x11 (Cons x11
                     Nil) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x11 x16)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x11 x16)} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x16)} <: List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x11
                       (Cons x11
                          Nil) of type LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x11 x16)}
Checking Cons x10 (Cons x11
                     (Cons x11
                        Nil)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x11 x16)}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x11 x16)}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x11 x16)) == 1 + len x16, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x11 x16)) == [x11] + elems x16, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x11 x16), x16 == (Cons x11 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x11 x16)) == 1 + len x16, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x10] + elems x14, elems ((Cons x11 x16)) == [x11] + elems x16, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, len x16 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x11 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x11 x16)) == 1 + len x16 && (len ((Cons x11 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x10] + elems x14 && (elems ((Cons x11 x16)) == [x11] + elems x16 && (elems ((Cons x11 (Nil))) == [x11] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x10 (Cons x11
                          (Cons x11 Nil)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x11 Nil))
Trying x2
Checking x2 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A7 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x2 ??))
Trying x5
Checking x5 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A7 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'Edges (A8)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons NoEdge ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'List (A8)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Cons Nil ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X6:_ -> X5:_ -> X4:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Edge ?? ?? ??))
Trying x12
Checking x12 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x12 ??)
Trying x6
Checking x6 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A6 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x6 ??)
Trying graph
Checking graph :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A6 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons graph ??)
Trying x10
Checking x10 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U2} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} <: X2:_ -> List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X2)} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)}
Trying Graph
Checking Graph :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X4:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|False} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X4} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x17} /\ List ()
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ {Int|U2} ()
Pred assignment
After process simple constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x11
Checking x11 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A7)'
when checking x11 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf x11))
Trying x12
Checking x12 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'UnweightedGraph (A7)'
when checking x12 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf x12))
Trying x6
Checking x6 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x6 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf x6))
Trying graph
Checking graph :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), _v == graph, graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v >= 0 && size _v < size graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (_v == graph && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))
mustHave !(size _v >= 0 && size _v < size graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking graph ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf graph))
Trying x2
Checking x2 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf x2))
Trying x5
Checking x5 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking x5 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf x5))
Trying x10
Checking x10 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A7)'
when checking x10 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf x10))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Nil ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (nodesOf Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X5:_ -> X4:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U3}
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X5 X4)} <: List ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x17 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x11
Checking x11 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U3} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} <: X4:_ -> List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X4)} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Trying x12
Checking x12 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 x12))
Trying x6
Checking x6 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 x6))
Trying graph
Checking graph :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 graph))
Trying x11
Checking x11 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 x11))
Trying x2
Checking x2 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 x2))
Trying x5
Checking x5 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 x5))
Trying x10
Checking x10 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 x10))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U4}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking Cons x11
           Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x11 (Nil))} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x11 (Nil))} <: List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x11
                       Nil of type {List A7|_v == (Cons x11 (Nil))}
Checking Cons x10 (Cons x11
                     Nil) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x10 x16)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x10 x16)} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x16)} <: List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x10
                       (Cons x11
                          Nil) of type LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x10 x16)}
Checking Cons x10 (Cons x10
                     (Cons x11
                        Nil)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x10 x16)}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x10 x16)}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 x16)) == 1 + len x16, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x10 x16)) == [x10] + elems x16, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x10 x16), x16 == (Cons x11 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 x16)) == 1 + len x16, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x10] + elems x14, elems ((Cons x10 x16)) == [x10] + elems x16, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, len x16 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x10 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x10 x16)) == 1 + len x16 && (len ((Cons x11 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x10] + elems x14 && (elems ((Cons x10 x16)) == [x10] + elems x16 && (elems ((Cons x11 (Nil))) == [x11] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x10 (Cons x10
                          (Cons x11 Nil)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x11 Nil))
Trying x12
Checking x12 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x12 ??))
Trying x6
Checking x6 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A7 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x6 ??))
Trying graph
Checking graph :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons graph ??))
Trying x2
Checking x2 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A7 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x2 ??))
Trying x5
Checking x5 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A7 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x5 ??))
Trying x10
Checking x10 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U3} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} <: X4:_ -> List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X4)} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Trying x11
Checking x11 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 x11))
Trying x12
Checking x12 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 x12))
Trying x6
Checking x6 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 x6))
Trying graph
Checking graph :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 graph))
Trying x2
Checking x2 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 x2))
Trying x5
Checking x5 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 x5))
Trying x10
Checking x10 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 x10))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U4}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking Cons x10
           Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x10 (Nil))} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x10 (Nil))} <: List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x10
                       Nil of type {List A7|_v == (Cons x10 (Nil))}
Checking Cons x10 (Cons x10
                     Nil) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x10 x16)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x10 x16)} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x16)} <: List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x10
                       (Cons x10
                          Nil) of type LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x10 x16)}
Checking Cons x10 (Cons x10
                     (Cons x10
                        Nil)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x10 x16)}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x10 x16)}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x10] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 x16)) == 1 + len x16, len ((Cons x10 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x10 x16)) == [x10] + elems x16, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x10 x16), x16 == (Cons x10 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 x16)) == 1 + len x16, len ((Cons x10 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x10] + elems x14, elems ((Cons x10 x16)) == [x10] + elems x16, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, len x16 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x10 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x10 x16)) == 1 + len x16 && (len ((Cons x10 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x10] + elems x14 && (elems ((Cons x10 x16)) == [x10] + elems x16 && (elems ((Cons x10 (Nil))) == [x10] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x10 (Cons x10
                          (Cons x10 Nil)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons x10 Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'Edges (A8)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons NoEdge ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'List (A8)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Cons Nil ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X6:_ -> X5:_ -> X4:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x10 (Edge ?? ?? ??))
Trying x2
Checking x2 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A6 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x2 ??)
Trying x5
Checking x5 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A6 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x5 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Edges (A7)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons NoEdge ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'List (A7)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons Nil ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X3:_ -> X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U2}
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X3 X2)} <: List ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x15 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)}
Trying Graph
Checking Graph :: X4:_ -> A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons (?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'UnweightedGraph (A7)'
with shape 'Int'
when checking Graph ::
X4:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons (Graph ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons (?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X4:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons (nodesOf ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons (?? ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Edges (A7)'
with shape 'Int'
when checking MoreEdge ::
X5:_ -> X4:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons (MoreEdge ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons (?? ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'List (A7)'
with shape 'Int'
when checking Cons ::
X5:_ -> X4:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons (Cons ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons (?? ?? ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Edge (A7)'
with shape 'Int'
when checking Edge ::
X6:_ -> X5:_ -> X4:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons (Edge ?? ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Edge ?? ?? ??)
Trying x11
Checking x11 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U1} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x11 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X0)} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x11 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)}
Trying Graph
Checking Graph :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|False} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U2}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U2} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X2} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x15} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ {Int|U1} ()
Pred assignment
After process simple constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)}
Trying Graph
Checking Graph :: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X3)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x16)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
addSplitConstraint X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X3} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x16)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X3} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Graph x16) && (graph == (Graph x2) && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph)))))))))
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x10
Checking x10 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x10 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph x10))
Trying x12
Checking x12 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A7)'
when checking x12 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph x12))
Trying x6
Checking x6 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking Graph
           x6 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph x6)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph x6)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x6)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x6} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x6} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x6 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument Graph
                       x6 of type {UnweightedGraph A7|_v == (Graph x6)}
Checking nodesOf (Graph
                    x6) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({UnweightedGraph A7|_v == (Graph x6)}) IN {List Int|elems _v == vertices x15} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({UnweightedGraph A7|_v == (Graph x6)}) IN {List Int|elems _v == vertices x15} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x15} <: List ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 0)
Synthesized argument nodesOf
                       (Graph
                          x6) of type LET x15:({UnweightedGraph A7|_v == (Graph x6)}) IN {List Int|elems _v == vertices x15}
Checking Cons x11 (nodesOf
                     (Graph
                        x6)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({UnweightedGraph A7|_v == (Graph x6)}) IN {List Int|elems _v == vertices x15}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({UnweightedGraph A7|_v == (Graph x6)}) IN {List Int|elems _v == vertices x15}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph x6) && (elems _v == [x11] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph x6) && (elems _v == [x11] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph x6) && (elems _v == [x11] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, size ((Graph x6)) == edgeNum x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph x6)) == nodeSet x6
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), x15 == (Graph x6), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, size ((Graph x6)) == edgeNum x6, elems _v == [x11] + elems x14, elems x14 == vertices x15, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph x6)) == nodeSet x6, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, size graph >= 0, size x15 >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (x15 == (Graph x6) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (size ((Graph x6)) == edgeNum x6 && (elems _v == [x11] + elems x14 && (elems x14 == vertices x15 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (vertices ((Graph x6)) == nodeSet x6 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x11 (nodesOf
                          (Graph x6)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph x6))
Trying graph
Checking graph :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph graph))
Trying x11
Checking x11 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x11 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph x11))
Trying x2
Checking x2 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking Graph
           x2 :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph x2)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph x2)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x2)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x2} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x2} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x2, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x2 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph x2))
Trying x5
Checking x5 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A7 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph x5))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U4}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument NoEdge of type {Edges {A8|False}|_v == (NoEdge)}
Checking Graph
           NoEdge :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph (NoEdge))} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A7|_v == (Graph (NoEdge))} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph (NoEdge))} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum (NoEdge)} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum (NoEdge) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Graph
                       NoEdge of type {UnweightedGraph A7|_v == (Graph (NoEdge))}
Checking nodesOf (Graph
                    NoEdge) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({UnweightedGraph A7|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x15} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({UnweightedGraph A7|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x15} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x15} <: List ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument nodesOf
                       (Graph
                          NoEdge) of type LET x15:({UnweightedGraph A7|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x15}
Checking Cons x11 (nodesOf
                     (Graph
                        NoEdge)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({UnweightedGraph A7|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x15}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({UnweightedGraph A7|_v == (Graph (NoEdge))}) IN {List Int|elems _v == vertices x15}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph (NoEdge)) && (elems _v == [x11] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph (NoEdge)) && (elems _v == [x11] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (x15 == (Graph (NoEdge)) && (elems _v == [x11] + elems x14 && (elems x14 == vertices x15 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, size ((Graph (NoEdge))) == edgeNum (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph (NoEdge))) == nodeSet (NoEdge)
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), graph == (Graph x2), x15 == (Graph (NoEdge)), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, size ((Graph (NoEdge))) == edgeNum (NoEdge), elems _v == [x11] + elems x14, elems x14 == vertices x15, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, vertices ((Graph (NoEdge))) == nodeSet (NoEdge), edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, size graph >= 0, size x15 >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (x15 == (Graph (NoEdge)) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum (NoEdge) == 0 && (size ((Graph x2)) == edgeNum x2 && (size ((Graph (NoEdge))) == edgeNum (NoEdge) && (elems _v == [x11] + elems x14 && (elems x14 == vertices x15 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (vertices ((Graph (NoEdge))) == nodeSet (NoEdge) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (size graph >= 0 && size x15 >= 0))))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x11 (nodesOf
                          (Graph NoEdge)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Graph Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)}
Trying MoreEdge
Checking MoreEdge :: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)}
Trying Cons
Checking Cons :: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)}
Trying Edge
Checking Edge :: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} <: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} /\ X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} /\ X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} <: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (nodesOf (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X3:_ -> X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U2}
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X3 X2)} <: List ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x15 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying x10
Checking x10 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U2} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x10 x16)} <: X2:_ -> List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X2)} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)}
Trying Graph
Checking Graph :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X4:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|False} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X4} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x17} /\ List ()
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ {Int|U2} ()
Pred assignment
After process simple constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x12
Checking x12 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'UnweightedGraph (A7)'
when checking x12 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf x12))
Trying x6
Checking x6 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x6 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf x6))
Trying graph
Checking graph :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), _v == graph, graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v >= 0 && size _v < size graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (_v == graph && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))
mustHave !(size _v >= 0 && size _v < size graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking graph ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf graph))
Trying x10
Checking x10 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A7)'
when checking x10 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf x10))
Trying x11
Checking x11 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A7)'
when checking x11 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf x11))
Trying x2
Checking x2 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf x2))
Trying x5
Checking x5 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking x5 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf x5))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Nil ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (nodesOf Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X5:_ -> X4:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U3}
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X5 X4)} <: List ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x17 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x12
Checking x12 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x12 ??))
Trying x6
Checking x6 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A7 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x6 ??))
Trying graph
Checking graph :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons graph ??))
Trying x10
Checking x10 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U3} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} <: X4:_ -> List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X4)} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Trying x12
Checking x12 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 x12))
Trying x6
Checking x6 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 x6))
Trying graph
Checking graph :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 graph))
Trying x11
Checking x11 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 x11))
Trying x2
Checking x2 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 x2))
Trying x5
Checking x5 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 x5))
Trying x10
Checking x10 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 x10))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U4}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking Cons x10
           Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x10 (Nil))} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x10 (Nil))} <: List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x10
                       Nil of type {List A7|_v == (Cons x10 (Nil))}
Checking Cons x10 (Cons x10
                     Nil) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x10 x16)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x10 x16)} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x16)} <: List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x10
                       (Cons x10
                          Nil) of type LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x10 x16)}
Checking Cons x11 (Cons x10
                     (Cons x10
                        Nil)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x10 x16)}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x10 x16)}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 x16)) == 1 + len x16, len ((Cons x10 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x10 x16)) == [x10] + elems x16, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x10 x16), x16 == (Cons x10 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 x16)) == 1 + len x16, len ((Cons x10 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x11] + elems x14, elems ((Cons x10 x16)) == [x10] + elems x16, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, len x16 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x10 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x10 x16)) == 1 + len x16 && (len ((Cons x10 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x11] + elems x14 && (elems ((Cons x10 x16)) == [x10] + elems x16 && (elems ((Cons x10 (Nil))) == [x10] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x11 (Cons x10
                          (Cons x10 Nil)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x10 Nil))
Trying x11
Checking x11 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U3} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} <: X4:_ -> List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X4)} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Trying x12
Checking x12 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 x12))
Trying x6
Checking x6 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 x6))
Trying graph
Checking graph :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 graph))
Trying x10
Checking x10 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 x10))
Trying x2
Checking x2 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 x2))
Trying x5
Checking x5 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 x5))
Trying x11
Checking x11 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 x11))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U4}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking Cons x11
           Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x11 (Nil))} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x11 (Nil))} <: List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x11
                       Nil of type {List A7|_v == (Cons x11 (Nil))}
Checking Cons x10 (Cons x11
                     Nil) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x10 x16)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x10 x16)} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x16)} <: List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x10
                       (Cons x11
                          Nil) of type LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x10 x16)}
Checking Cons x11 (Cons x10
                     (Cons x11
                        Nil)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x10 x16)}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x10 x16)}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x10 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 x16)) == 1 + len x16, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x10 x16)) == [x10] + elems x16, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x10 x16), x16 == (Cons x11 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 x16)) == 1 + len x16, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x11] + elems x14, elems ((Cons x10 x16)) == [x10] + elems x16, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, len x16 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x10 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x10 x16)) == 1 + len x16 && (len ((Cons x11 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x11] + elems x14 && (elems ((Cons x10 x16)) == [x10] + elems x16 && (elems ((Cons x11 (Nil))) == [x11] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x11 (Cons x10
                          (Cons x11 Nil)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x11 Nil))
Trying x2
Checking x2 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A7 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x2 ??))
Trying x5
Checking x5 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A7 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'Edges (A8)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons NoEdge ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'List (A8)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Cons Nil ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X6:_ -> X5:_ -> X4:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x10 (Edge ?? ?? ??))
Trying x12
Checking x12 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x12 ??)
Trying x6
Checking x6 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A6 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x6 ??)
Trying graph
Checking graph :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A6 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons graph ??)
Trying x11
Checking x11 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U2} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} <: X2:_ -> List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X2)} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)}
Trying Graph
Checking Graph :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X4:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|False} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X4} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x17} /\ List ()
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ {Int|U2} ()
Pred assignment
After process simple constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x10
Checking x10 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A7)'
when checking x10 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf x10))
Trying x12
Checking x12 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'UnweightedGraph (A7)'
when checking x12 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf x12))
Trying x6
Checking x6 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x6 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf x6))
Trying graph
Checking graph :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == graph} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == graph && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v >= 0 && size _v < size graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), _v == graph, graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v >= 0 && size _v < size graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (_v == graph && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))
mustHave !(size _v >= 0 && size _v < size graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking graph ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf graph))
Trying x2
Checking x2 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking x2 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf x2))
Trying x5
Checking x5 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking x5 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf x5))
Trying x11
Checking x11 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'UnweightedGraph (A7)'
when checking x11 ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf x11))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking NoEdge ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Nil ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (nodesOf Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X5:_ -> X4:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U3}
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X5 X4)} <: List ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x17 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Trying x10
Checking x10 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U3} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x10 x18)} <: X4:_ -> List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X4)} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Trying x12
Checking x12 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 x12))
Trying x6
Checking x6 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 x6))
Trying graph
Checking graph :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 graph))
Trying x10
Checking x10 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 x10))
Trying x2
Checking x2 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 x2))
Trying x5
Checking x5 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 x5))
Trying x11
Checking x11 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 x11))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U4}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking Cons x10
           Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x10 (Nil))} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x10 (Nil))} <: List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x10
                       Nil of type {List A7|_v == (Cons x10 (Nil))}
Checking Cons x11 (Cons x10
                     Nil) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x11 x16)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x11 x16)} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x16)} <: List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x11
                       (Cons x10
                          Nil) of type LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x11 x16)}
Checking Cons x11 (Cons x11
                     (Cons x10
                        Nil)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x11 x16)}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x10 (Nil))}) IN {List A6|_v == (Cons x11 x16)}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 (Nil))) == 1 + len (Nil), len ((Cons x11 x16)) == 1 + len x16, len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems ((Cons x11 x16)) == [x11] + elems x16, elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x11 x16), x16 == (Cons x10 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x10 (Nil))) == 1 + len (Nil), len ((Cons x11 x16)) == 1 + len x16, len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x11] + elems x14, elems ((Cons x10 (Nil))) == [x10] + elems (Nil), elems ((Cons x11 x16)) == [x11] + elems x16, elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, len x16 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x11 x16) && (x16 == (Cons x10 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x10 (Nil))) == 1 + len (Nil) && (len ((Cons x11 x16)) == 1 + len x16 && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x11] + elems x14 && (elems ((Cons x10 (Nil))) == [x10] + elems (Nil) && (elems ((Cons x11 x16)) == [x11] + elems x16 && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x11 (Cons x11
                          (Cons x10 Nil)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x10 Nil))
Trying x12
Checking x12 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x12 ??))
Trying x6
Checking x6 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A7 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x6 ??))
Trying graph
Checking graph :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons graph ??))
Trying x2
Checking x2 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A7 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x2 ??))
Trying x5
Checking x5 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A7 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x5 ??))
Trying x11
Checking x11 :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U3} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:List A7 -> {List A7|_v == (Cons x11 x18)} <: X4:_ -> List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X4)} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x18)} /\ List ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} /\ {Int|U2} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (7 0)
Trying x10
Checking x10 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x10 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 x10))
Trying x12
Checking x12 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x12 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 x12))
Trying x6
Checking x6 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x6 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 x6))
Trying graph
Checking graph :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking graph :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 graph))
Trying x2
Checking x2 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x2 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 x2))
Trying x5
Checking x5 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x5 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 x5))
Trying x11
Checking x11 :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: List A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'List (A7)'
when checking x11 :: List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 x11))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking NoEdge :: List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: List A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {Int|U3} PRODUCING {Int|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U4}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Nil)} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: {Int|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking Cons x11
           Nil :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x11 (Nil))} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List A7|_v == (Cons x11 (Nil))} <: List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 (Nil))} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U3} <: {Int|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x11
                       Nil of type {List A7|_v == (Cons x11 (Nil))}
Checking Cons x11 (Cons x11
                     Nil) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x11 x16)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x11 x16)} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x16)} <: List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Cons x11
                       (Cons x11
                          Nil) of type LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x11 x16)}
Checking Cons x11 (Cons x11
                     (Cons x11
                        Nil)) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x11 x16)}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({List A7|_v == (Cons x11 (Nil))}) IN {List A6|_v == (Cons x11 x16)}) IN {List A5|_v == (Cons x11 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {Int|U3}
A8 -> {Int|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x11] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (elems _v == [x11] + elems x14 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0)))))))))) ==> elems _v == vertices graph
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x11 x16)) == 1 + len x16, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems ((Cons x11 x16)) == [x11] + elems x16, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x2 == (MoreEdge x5 x6), x14 == (Cons x11 x16), x16 == (Cons x11 (Nil)), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, len ((Cons x11 x16)) == 1 + len x16, len ((Cons x11 (Nil))) == 1 + len (Nil), len (Nil) == 0, size ((Graph x2)) == edgeNum x2, elems _v == [x11] + elems x14, elems ((Cons x11 x16)) == [x11] + elems x16, elems ((Cons x11 (Nil))) == [x11] + elems (Nil), elems (Nil) == [], nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x2 >= 0, edgeNum x6 >= 0, len x14 >= 0, len x16 >= 0, size graph >= 0
RHS: elems _v == vertices graph
assumption x5 == (Edge x10 x11 x12) && (x2 == (MoreEdge x5 x6) && (x14 == (Cons x11 x16) && (x16 == (Cons x11 (Nil)) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (len ((Cons x11 x16)) == 1 + len x16 && (len ((Cons x11 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (size ((Graph x2)) == edgeNum x2 && (elems _v == [x11] + elems x14 && (elems ((Cons x11 x16)) == [x11] + elems x16 && (elems ((Cons x11 (Nil))) == [x11] + elems (Nil) && (elems (Nil) == [] && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(elems _v == vertices graph)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons x11 (Cons x11
                          (Cons x11 Nil)) ::
{List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons x11 Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'Edges (A8)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons NoEdge ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'List (A8)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Cons Nil ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X6:_ -> X5:_ -> X4:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x11 (Edge ?? ?? ??))
Trying x2
Checking x2 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A6 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x2 ??)
Trying x5
Checking x5 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A6 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons x5 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A7|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A7|False}|_v == (NoEdge)} <: A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Edges (A7)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons NoEdge ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A7|False}|_v == (Nil)} <: A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'List (A7)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons Nil ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X3:_ -> X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U2}
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X3 X2)} <: List ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x15 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)}
Trying Graph
Checking Graph :: X4:_ -> A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons (?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'UnweightedGraph (A7)'
with shape 'Int'
when checking Graph ::
X4:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons (Graph ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons (?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X4:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons (nodesOf ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons (?? ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A7 -> x18:Edges A7 -> {Edges A7|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Edges (A7)'
with shape 'Int'
when checking MoreEdge ::
X5:_ -> X4:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons (MoreEdge ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons (?? ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A7 -> x18:List A7 -> {List A7|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'List (A7)'
with shape 'Int'
when checking Cons ::
X5:_ -> X4:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons (Cons ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons (?? ?? ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A7 -> {Edge A7|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Edge (A7)'
with shape 'Int'
when checking Edge ::
X6:_ -> X5:_ -> X4:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Cons (Edge ?? ?? ??) ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11 (??
                                            ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> List Int
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x11
                                  (Edge ?? ?? ??)
Trying x12
Checking x12 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x12 ??
Trying x6
Checking x6 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A5 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x6 ??
Trying graph
Checking graph :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A5 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons graph
                                  ??
Trying x2
Checking x2 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A5 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x2 ??
Trying x5
Checking x5 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A5 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x5 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A6|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A6|False}|_v == (NoEdge)} <: A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edges (A6)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons NoEdge
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A6|False}|_v == (Nil)} <: A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'List (A6)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons Nil ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> MoreEdge ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Edge ?? ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x13]U1 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x13 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)}
Trying Graph
Checking Graph :: X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??)
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'UnweightedGraph (A6)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Graph
                                        ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??)
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons
                                  (nodesOf ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edges (A6)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons
                                  (MoreEdge ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'List (A6)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Cons
                                        ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edge (A6)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Edge
                                        ?? ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> MoreEdge ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Edge ?? ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Edge ?? ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x13]U1 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x13 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)}
Trying Graph
Checking Graph :: X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??)
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'UnweightedGraph (A6)'
with shape 'Int'
when checking Graph ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Graph
                                        ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??)
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'List (Int)'
with shape 'Int'
when checking nodesOf ::
X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons
                                  (nodesOf ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edges (A6)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons
                                  (MoreEdge ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'List (A6)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Cons
                                        ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edge (A6)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Edge
                                        ?? ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edges (A6)'
with shape 'Int'
when checking MoreEdge ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons
                                  (MoreEdge ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'List (A6)'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Cons
                                        ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edge (A6)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Edge
                                        ?? ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (?? ??
                                        ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A6 -> {Edge A6|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Edge (A6)'
with shape 'Int'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons (Edge
                                        ?? ?? ??) ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)}
Trying MoreEdge
Checking MoreEdge :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edge A5 -> x14:Edges A5 -> {Edges A5|_v == (MoreEdge x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> MoreEdge ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Edge ?? ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Edge ?? ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)}
Trying Edge
Checking Edge :: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} /\ X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Int -> x14:Int -> x15:A5 -> {Edge A5|_v == (Edge x13 x14 x15)} <: X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'List'
when checking Edge ::
X2:_ -> X1:_ -> X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Edge ?? ??
                                  ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)}
Trying Graph
Checking Graph :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:Edges A5 -> {UnweightedGraph A5|_v == (Graph x13)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X0:_ -> {List Int|elems _v == vertices graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Graph ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:{UnweightedGraph A5|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x13} <: X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:UnweightedGraph A5 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH {a|False} PRODUCING {a|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U1}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U1} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: Int ()
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x13} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (elems _v == vertices graph && (elems _v == vertices x13 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size x13 >= 0 && (size x13 >= 0 && size x13 < size graph))))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)}
Trying Graph
Checking Graph :: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edges A6 -> {UnweightedGraph A6|_v == (Graph x14)} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U2}
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X1)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} /\ {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X1} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Graph x14) && (graph == (Graph x2) && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph)))))))))
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x15:Edges A7 -> {UnweightedGraph A7|_v == (Graph x15)}
Trying Graph
Checking Graph :: X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A7 -> {UnweightedGraph A7|_v == (Graph x15)} <: X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A7 -> {UnweightedGraph A7|_v == (Graph x15)} /\ X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A7 -> {UnweightedGraph A7|_v == (Graph x15)} /\ X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A7 -> {UnweightedGraph A7|_v == (Graph x15)} <: X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x15:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Trying x10
Checking x10 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A7)'
when checking x10 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x10 ??))
Trying x11
Checking x11 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A7)'
when checking x11 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x11 ??))
Trying x12
Checking x12 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edge (A7)'
when checking x12 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x12 ??))
Trying x6
Checking x6 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x6 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x6 ??))
Trying graph
Checking graph :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge graph ??))
Trying x2
Checking x2 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A7 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x2 ??))
Trying x5
Checking x5 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == x5} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Synthesized argument x5 of type {Edge a|_v == x5}
Checking MoreEdge
           x5 :: X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x16)} <: X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x16)} /\ X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x16)} /\ X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {Edges A7|_v == (MoreEdge x5 x16)} <: X2:_ -> Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 X2)} <: Edges ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x16)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)}
Trying Graph
Checking Graph :: X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} <: X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} /\ X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} /\ X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} <: X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X4:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (Graph ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A8 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A8 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X4:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (nodesOf
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X5:_ -> X4:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (Cons ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U4}
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge X5 X4)} <: Edges ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x17 x18)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Trying x10
Checking x10 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A8)'
when checking x10 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge
                                                         x10 ??)))
Trying x11
Checking x11 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A8)'
when checking x11 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge
                                                         x11 ??)))
Trying x12
Checking x12 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edge (A8)'
when checking x12 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge
                                                         x12 ??)))
Trying x6
Checking x6 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x6 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x6
                                                         ??)))
Trying graph
Checking graph :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge
                                                         graph ??)))
Trying x2
Checking x2 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x2
                                                         ??)))
Trying x5
Checking x5 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A8 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == x5} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x5 of type {Edge a|_v == x5}
Checking MoreEdge
           x5 :: X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {Edges A8|_v == (MoreEdge x5 x18)} <: X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {Edges A8|_v == (MoreEdge x5 x18)} /\ X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {Edges A8|_v == (MoreEdge x5 x18)} /\ X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {Edges A8|_v == (MoreEdge x5 x18)} <: X4:_ -> Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 X4)} <: Edges ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x18)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Trying x10
Checking x10 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A8)'
when checking x10 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         x10)))
Trying x11
Checking x11 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A8)'
when checking x11 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         x11)))
Trying x12
Checking x12 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A8)'
when checking x12 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         x12)))
Trying x6
Checking x6 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A8 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge x5
           x6 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 x6)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 x6)} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       x6 of type {Edges A8|_v == (MoreEdge x5 x6)}
Checking MoreEdge x5 (MoreEdge
                        x5 x6) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 x6)}) IN {Edges A7|_v == (MoreEdge x5 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 x6)}) IN {Edges A7|_v == (MoreEdge x5 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       (MoreEdge x5
                          x6) of type LET x16:({Edges A8|_v == (MoreEdge x5 x6)}) IN {Edges A7|_v == (MoreEdge x5 x16)}
Checking Graph (MoreEdge x5
                  (MoreEdge x5
                     x6)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A8|_v == (MoreEdge x5 x6)}) IN {Edges A7|_v == (MoreEdge x5 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A8|_v == (MoreEdge x5 x6)}) IN {Edges A7|_v == (MoreEdge x5 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x16)) == nodes x5 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x14 == (MoreEdge x5 x16), x16 == (MoreEdge x5 x6), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x16)) == nodes x5 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 x6) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x16)) == nodes x5 + nodeSet x16 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       (MoreEdge x5 x6)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         x6)))
Trying graph
Checking graph :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A8 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         graph)))
Trying x2
Checking x2 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A8 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge x5
           x2 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 x2)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 x2)} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x2)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       x2 of type {Edges A8|_v == (MoreEdge x5 x2)}
Checking MoreEdge x5 (MoreEdge
                        x5 x2) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 x2)}) IN {Edges A7|_v == (MoreEdge x5 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 x2)}) IN {Edges A7|_v == (MoreEdge x5 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       (MoreEdge x5
                          x2) of type LET x16:({Edges A8|_v == (MoreEdge x5 x2)}) IN {Edges A7|_v == (MoreEdge x5 x16)}
Checking Graph (MoreEdge x5
                  (MoreEdge x5
                     x2)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A8|_v == (MoreEdge x5 x2)}) IN {Edges A7|_v == (MoreEdge x5 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A8|_v == (MoreEdge x5 x2)}) IN {Edges A7|_v == (MoreEdge x5 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x16)) == nodes x5 + nodeSet x16, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x14 == (MoreEdge x5 x16), x16 == (MoreEdge x5 x2), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x16)) == nodes x5 + nodeSet x16, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 x2) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x16)) == nodes x5 + nodeSet x16 && (nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       (MoreEdge x5 x2)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         x2)))
Trying x5
Checking x5 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A8 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         x5)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Edges A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U5}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U4} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Synthesized argument NoEdge of type {Edges {A9|False}|_v == (NoEdge)}
Checking MoreEdge x5
           NoEdge :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 (NoEdge))} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 (NoEdge))} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 (NoEdge))} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       NoEdge of type {Edges A8|_v == (MoreEdge x5 (NoEdge))}
Checking MoreEdge x5 (MoreEdge
                        x5 NoEdge) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 (NoEdge))}) IN {Edges A7|_v == (MoreEdge x5 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 (NoEdge))}) IN {Edges A7|_v == (MoreEdge x5 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       (MoreEdge x5
                          NoEdge) of type LET x16:({Edges A8|_v == (MoreEdge x5 (NoEdge))}) IN {Edges A7|_v == (MoreEdge x5 x16)}
Checking Graph (MoreEdge x5
                  (MoreEdge x5
                     NoEdge)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A8|_v == (MoreEdge x5 (NoEdge))}) IN {Edges A7|_v == (MoreEdge x5 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A8|_v == (MoreEdge x5 (NoEdge))}) IN {Edges A7|_v == (MoreEdge x5 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x16)) == nodes x5 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x14 == (MoreEdge x5 x16), x16 == (MoreEdge x5 (NoEdge)), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x16)) == nodes x5 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x5 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x16)) == nodes x5 + nodeSet x16 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge) && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       (MoreEdge x5 NoEdge)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         NoEdge)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Edges A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U4} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge x5
                                                         Nil)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Edge A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U4} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge
                                                         NoEdge ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Edge A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U4} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (MoreEdge
                                                         Nil ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (?? ?? ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X6:_ -> X5:_ -> X4:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge x5 (Edge ?? ??
                                                         ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A8|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A8|False}|_v == (NoEdge)} <: Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge NoEdge ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A8|False}|_v == (Nil)} <: Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge Nil ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A7 -> x16:List A7 -> {List A7|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X3:_ -> X2:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A7 -> x16:Edges A7 -> {Edges A7|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge X3 X2)} <: Edges ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (5 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)}
Trying Graph
Checking Graph :: X4:_ -> Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} <: X4:_ -> Edge A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} /\ X4:_ -> Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} /\ X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} <: X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking Graph ::
X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Graph ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A8 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> Edge A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A8 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (nodesOf ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (?? ?? ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> Edge A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Cons ::
X5:_ -> X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Cons ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (?? ?? ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> Edge A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking MoreEdge ::
X5:_ -> X4:_ -> Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (MoreEdge ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (?? ?? ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> Edge A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U4}
X4, X5, X6, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge X6 X5 X4)} <: Edge ()
X4, X5, X6, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x17, x18, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x17 x18 x19)} /\ Edge ()
graph, nodesOf, x10, x11, x12, x17, x18, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x17, x18, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, X5, X6, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Trying x10
Checking x10 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge ?? ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Int ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Int ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Edge
           x10 :: X5:_ -> X4:_ -> Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (?? ?? ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x10 x18 x19)} <: X5:_ -> X4:_ -> Edge A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x10 x18 x19)} /\ X5:_ -> X4:_ -> Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x10 x18 x19)} /\ X5:_ -> X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x10 x18 x19)} <: X5:_ -> X4:_ -> Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x10 X5 X4)} <: Edge ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x18, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x10 x18 x19)} /\ Edge ()
graph, nodesOf, x10, x11, x12, x18, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Trying x11
Checking x11 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Int ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Int ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Edge x10
           x11 :: X4:_ -> Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x10 x11 x19)} <: X4:_ -> Edge A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x10 x11 x19)} /\ X4:_ -> Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x10 x11 x19)} /\ X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x10 x11 x19)} <: X4:_ -> Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x10 x11 X4)} <: Edge ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x10 x11 x19)} /\ Edge ()
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Trying x12
Checking x12 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A8 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {a|U4} ()
Constraints
  C1 && (M0 && (_v == x12 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument x12 of type {a|_v == x12}
Checking Edge x10 x11
           x12 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge A8|_v == (Edge x10 x11 x12)} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge A8|_v == (Edge x10 x11 x12)} <: Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x10 x11 x12)} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Edge x10
                       x11
                       x12 of type {Edge A8|_v == (Edge x10 x11 x12)}
Checking MoreEdge (Edge x10 x11
                     x12) :: X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} /\ X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} /\ X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: X2:_ -> Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 X2)} <: Edges ()
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Trying x6
Checking x6 :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge (Edge x10 x11
                     x12) x6 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x6)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge
                       (Edge x10 x11 x12)
                       x6 of type LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}
Checking Graph (MoreEdge (Edge
                            x10 x11 x12)
                  x6) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x6), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x11 x12) x6) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) x6))
Trying graph
Checking graph :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph ::
x15:{Edge a|_v == (Edge x10 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) graph))
Trying x10
Checking x10 :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x10 ::
x15:{Edge a|_v == (Edge x10 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) x10))
Trying x11
Checking x11 :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x11 ::
x15:{Edge a|_v == (Edge x10 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) x11))
Trying x12
Checking x12 :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A7)'
when checking x12 ::
x15:{Edge a|_v == (Edge x10 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) x12))
Trying x2
Checking x2 :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge (Edge x10 x11
                     x12) x2 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x2)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge
                       (Edge x10 x11 x12)
                       x2 of type LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}
Checking Graph (MoreEdge (Edge
                            x10 x11 x12)
                  x2) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x2), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x11 x12) x2) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) x2))
Trying x5
Checking x5 :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 ::
x15:{Edge a|_v == (Edge x10 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) x5))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U5}
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Synthesized argument NoEdge of type {Edges {A9|False}|_v == (NoEdge)}
Checking MoreEdge (Edge x10 x11
                     x12) NoEdge :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 (NoEdge))} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Synthesized argument MoreEdge
                       (Edge x10 x11 x12)
                       NoEdge of type LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}
Checking Graph (MoreEdge (Edge
                            x10 x11 x12)
                  NoEdge) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 (NoEdge)), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge) && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x11 x12) NoEdge) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil ::
x15:{Edge a|_v == (Edge x10 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)}
Trying Graph
Checking Graph :: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X7:_ -> x15:{Edge a|_v == (Edge x10 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (Graph ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:UnweightedGraph A9 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:UnweightedGraph A9 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X7:_ -> x15:{Edge a|_v == (Edge x10 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (nodesOf ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)}
Trying Cons
Checking Cons :: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X8:_ -> X7:_ -> x15:{Edge a|_v == (Edge x10 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (Cons ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)}
Trying MoreEdge
Checking MoreEdge :: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U5}
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge X8 X7)} <: Edges ()
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x20 x21)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Trying x6
Checking x6 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x6 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x6 ??)))
Trying graph
Checking graph :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge graph ??)))
Trying x10
Checking x10 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A9)'
when checking x10 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x10 ??)))
Trying x11
Checking x11 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A9)'
when checking x11 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x11 ??)))
Trying x12
Checking x12 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edge (A9)'
when checking x12 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x12 ??)))
Trying x2
Checking x2 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x2 ??)))
Trying x5
Checking x5 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == x5} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x5 of type {Edge a|_v == x5}
Checking MoreEdge
           x5 :: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 X7)} <: Edges ()
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x21)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Trying x6
Checking x6 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge x5
           x6 :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x6)} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x6)} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       x6 of type {Edges A9|_v == (MoreEdge x5 x6)}
Checking MoreEdge (Edge x10 x11
                     x12) (MoreEdge x5
                             x6) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x10 x11 x12) (MoreEdge x5
                                             x6) of type LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x10 x11 x12) (MoreEdge x5
                                            x6)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 x6), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x11 x12) (MoreEdge x5
                                             x6)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 x6)))
Trying graph
Checking graph :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 graph)))
Trying x10
Checking x10 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A9)'
when checking x10 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 x10)))
Trying x11
Checking x11 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A9)'
when checking x11 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 x11)))
Trying x12
Checking x12 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A9)'
when checking x12 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 x12)))
Trying x2
Checking x2 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge x5
           x2 :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x2)} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x2)} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x2)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       x2 of type {Edges A9|_v == (MoreEdge x5 x2)}
Checking MoreEdge (Edge x10 x11
                     x12) (MoreEdge x5
                             x2) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x10 x11 x12) (MoreEdge x5
                                             x2) of type LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x10 x11 x12) (MoreEdge x5
                                            x2)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 x2), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x11 x12) (MoreEdge x5
                                             x2)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 x2)))
Trying x5
Checking x5 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 x5)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A10|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edges A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U6}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U5} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument NoEdge of type {Edges {A10|False}|_v == (NoEdge)}
Checking MoreEdge x5
           NoEdge :: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 (NoEdge))} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 (NoEdge))} <: LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 (NoEdge))} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       NoEdge of type {Edges A9|_v == (MoreEdge x5 (NoEdge))}
Checking MoreEdge (Edge x10 x11
                     x12) (MoreEdge x5
                             NoEdge) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x10 x11 x12) (MoreEdge x5
                                             NoEdge) of type LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x10 x11 x12) (MoreEdge x5
                                            NoEdge)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 (NoEdge)), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge) && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x11 x12) (MoreEdge x5
                                             NoEdge)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5
                                                              NoEdge)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edges A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge x5 Nil)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A10|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edge A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge NoEdge
                                                              ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edge A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (MoreEdge Nil ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)}
Trying Edge
Checking Edge :: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (?? ?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} <: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} /\ X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} /\ X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} <: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X9:_ -> X8:_ -> X7:_ -> x15:{Edge a|_v == (Edge x10 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x12) (Edge ?? ?? ??)))
Trying x6
Checking x6 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A8 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'a'
when checking x6 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x6) ??))
Trying graph
Checking graph :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A8 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'a'
when checking graph :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      graph) ??))
Trying x10
Checking x10 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking x10 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x10) ??))
Trying x11
Checking x11 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking x11 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x11) ??))
Trying x2
Checking x2 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A8 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'a'
when checking x2 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x2) ??))
Trying x5
Checking x5 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A8 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'a'
when checking x5 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      x5) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'Edges (A9)'
with shape 'a'
when checking NoEdge :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      NoEdge) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'List (A9)'
with shape 'a'
when checking Nil :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x11
                                                      Nil) ??))
Trying x12
Checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Int ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x12
                                                      ??) ??))
Trying x6
Checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Int ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x6
                                                      ??) ??))
Trying graph
Checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Int ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 graph
                                                      ??) ??))
Trying x10
Checking x10 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Int ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Int ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Edge x10
           x10 :: X4:_ -> Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x10 x10 x19)} <: X4:_ -> Edge A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x10 x10 x19)} /\ X4:_ -> Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x10 x10 x19)} /\ X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x10 x10 x19)} <: X4:_ -> Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x10 x10 X4)} <: Edge ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x10 x10 x19)} /\ Edge ()
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Trying x11
Checking x11 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking x11 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x11) ??))
Trying x12
Checking x12 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A8 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {a|U4} ()
Constraints
  C1 && (M0 && (_v == x12 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument x12 of type {a|_v == x12}
Checking Edge x10 x10
           x12 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge A8|_v == (Edge x10 x10 x12)} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge A8|_v == (Edge x10 x10 x12)} <: Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x10 x10 x12)} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Edge x10
                       x10
                       x12 of type {Edge A8|_v == (Edge x10 x10 x12)}
Checking MoreEdge (Edge x10 x10
                     x12) :: X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} /\ X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} /\ X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: X2:_ -> Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 X2)} <: Edges ()
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Trying x11
Checking x11 :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x11 ::
x15:{Edge a|_v == (Edge x10 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) x11))
Trying x6
Checking x6 :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge (Edge x10 x10
                     x12) x6 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x6)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge
                       (Edge x10 x10 x12)
                       x6 of type LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}
Checking Graph (MoreEdge (Edge
                            x10 x10 x12)
                  x6) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x6), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x10 x12)) == [x10] + [x10] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x10 x12) x6) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) x6))
Trying graph
Checking graph :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph ::
x15:{Edge a|_v == (Edge x10 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) graph))
Trying x12
Checking x12 :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A7)'
when checking x12 ::
x15:{Edge a|_v == (Edge x10 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) x12))
Trying x2
Checking x2 :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge (Edge x10 x10
                     x12) x2 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x2)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge
                       (Edge x10 x10 x12)
                       x2 of type LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}
Checking Graph (MoreEdge (Edge
                            x10 x10 x12)
                  x2) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x2), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x10 x12)) == [x10] + [x10] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x10 x12) x2) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) x2))
Trying x5
Checking x5 :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 ::
x15:{Edge a|_v == (Edge x10 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) x5))
Trying x10
Checking x10 :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x10 ::
x15:{Edge a|_v == (Edge x10 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) x10))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U5}
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Synthesized argument NoEdge of type {Edges {A9|False}|_v == (NoEdge)}
Checking MoreEdge (Edge x10 x10
                     x12) NoEdge :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 (NoEdge))} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Synthesized argument MoreEdge
                       (Edge x10 x10 x12)
                       NoEdge of type LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}
Checking Graph (MoreEdge (Edge
                            x10 x10 x12)
                  NoEdge) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 (NoEdge)), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge) && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x10 x12)) == [x10] + [x10] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x10 x12) NoEdge) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil ::
x15:{Edge a|_v == (Edge x10 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)}
Trying Graph
Checking Graph :: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X7:_ -> x15:{Edge a|_v == (Edge x10 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (Graph ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:UnweightedGraph A9 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:UnweightedGraph A9 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X7:_ -> x15:{Edge a|_v == (Edge x10 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (nodesOf ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)}
Trying Cons
Checking Cons :: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X8:_ -> X7:_ -> x15:{Edge a|_v == (Edge x10 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (Cons ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)}
Trying MoreEdge
Checking MoreEdge :: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U5}
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge X8 X7)} <: Edges ()
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x20 x21)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Trying x11
Checking x11 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A9)'
when checking x11 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x11 ??)))
Trying x6
Checking x6 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x6 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x6 ??)))
Trying graph
Checking graph :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge graph ??)))
Trying x12
Checking x12 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edge (A9)'
when checking x12 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x12 ??)))
Trying x2
Checking x2 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x2 ??)))
Trying x5
Checking x5 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == x5} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x5 of type {Edge a|_v == x5}
Checking MoreEdge
           x5 :: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 X7)} <: Edges ()
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x21)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Trying x11
Checking x11 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A9)'
when checking x11 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 x11)))
Trying x6
Checking x6 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge x5
           x6 :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x6)} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x6)} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       x6 of type {Edges A9|_v == (MoreEdge x5 x6)}
Checking MoreEdge (Edge x10 x10
                     x12) (MoreEdge x5
                             x6) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x10 x10 x12) (MoreEdge x5
                                             x6) of type LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x10 x10 x12) (MoreEdge x5
                                            x6)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 x6), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x10 x12)) == [x10] + [x10] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x10 x12) (MoreEdge x5
                                             x6)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 x6)))
Trying graph
Checking graph :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 graph)))
Trying x12
Checking x12 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A9)'
when checking x12 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 x12)))
Trying x2
Checking x2 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge x5
           x2 :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x2)} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x2)} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x2)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       x2 of type {Edges A9|_v == (MoreEdge x5 x2)}
Checking MoreEdge (Edge x10 x10
                     x12) (MoreEdge x5
                             x2) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x10 x10 x12) (MoreEdge x5
                                             x2) of type LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x10 x10 x12) (MoreEdge x5
                                            x2)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 x2), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x10 x12)) == [x10] + [x10] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x10 x12) (MoreEdge x5
                                             x2)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 x2)))
Trying x10
Checking x10 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A9)'
when checking x10 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 x10)))
Trying x5
Checking x5 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 x5)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A10|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edges A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U6}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U5} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument NoEdge of type {Edges {A10|False}|_v == (NoEdge)}
Checking MoreEdge x5
           NoEdge :: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 (NoEdge))} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 (NoEdge))} <: LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 (NoEdge))} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       NoEdge of type {Edges A9|_v == (MoreEdge x5 (NoEdge))}
Checking MoreEdge (Edge x10 x10
                     x12) (MoreEdge x5
                             NoEdge) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x10 x10 x12) (MoreEdge x5
                                             NoEdge) of type LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x10 x10 x12) (MoreEdge x5
                                            NoEdge)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x10 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 (NoEdge)), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x10 x12)) == [x10] + [x10], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x10 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge) && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x10 x12)) == [x10] + [x10] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x10 x10 x12) (MoreEdge x5
                                             NoEdge)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5
                                                              NoEdge)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edges A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x5 Nil)))
Trying x10
Checking x10 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A9)'
when checking x10 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge x10 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A10|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edge A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge NoEdge
                                                              ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edge A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (MoreEdge Nil ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)}
Trying Edge
Checking Edge :: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (?? ?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} <: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} /\ X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} /\ X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} <: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x10 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X9:_ -> X8:_ -> X7:_ -> x15:{Edge a|_v == (Edge x10 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x12) (Edge ?? ?? ??)))
Trying x6
Checking x6 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A8 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'a'
when checking x6 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x6) ??))
Trying graph
Checking graph :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A8 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'a'
when checking graph :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      graph) ??))
Trying x2
Checking x2 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A8 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'a'
when checking x2 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x2) ??))
Trying x5
Checking x5 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A8 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'a'
when checking x5 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x5) ??))
Trying x10
Checking x10 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking x10 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      x10) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'Edges (A9)'
with shape 'a'
when checking NoEdge :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      NoEdge) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'List (A9)'
with shape 'a'
when checking Nil :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x10
                                                      Nil) ??))
Trying x2
Checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Int ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x2
                                                      ??) ??))
Trying x5
Checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Int ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 x5
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'Edges (A9)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10
                                                      NoEdge ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'List (A9)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x10 Nil
                                                      ??) ??))
Trying x11
Checking x11 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge ?? ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Int ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Int ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Edge
           x11 :: X5:_ -> X4:_ -> Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (?? ?? ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x11 x18 x19)} <: X5:_ -> X4:_ -> Edge A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x11 x18 x19)} /\ X5:_ -> X4:_ -> Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x11 x18 x19)} /\ X5:_ -> X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x11 x18 x19)} <: X5:_ -> X4:_ -> Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x11 X5 X4)} <: Edge ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x18, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x11 x18 x19)} /\ Edge ()
graph, nodesOf, x10, x11, x12, x18, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Trying x10
Checking x10 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Int ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Int ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Edge x11
           x10 :: X4:_ -> Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x11 x10 x19)} <: X4:_ -> Edge A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x11 x10 x19)} /\ X4:_ -> Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x11 x10 x19)} /\ X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x11 x10 x19)} <: X4:_ -> Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x11 x10 X4)} <: Edge ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x11 x10 x19)} /\ Edge ()
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Trying x12
Checking x12 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A8 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {a|U4} ()
Constraints
  C1 && (M0 && (_v == x12 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument x12 of type {a|_v == x12}
Checking Edge x11 x10
           x12 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge A8|_v == (Edge x11 x10 x12)} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge A8|_v == (Edge x11 x10 x12)} <: Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x11 x10 x12)} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Edge x11
                       x10
                       x12 of type {Edge A8|_v == (Edge x11 x10 x12)}
Checking MoreEdge (Edge x11 x10
                     x12) :: X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} /\ X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} /\ X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: X2:_ -> Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 X2)} <: Edges ()
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Trying x6
Checking x6 :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge (Edge x11 x10
                     x12) x6 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x6)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge
                       (Edge x11 x10 x12)
                       x6 of type LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}
Checking Graph (MoreEdge (Edge
                            x11 x10 x12)
                  x6) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x6), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x10 x12)) == [x11] + [x10] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x10 x12) x6) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) x6))
Trying graph
Checking graph :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph ::
x15:{Edge a|_v == (Edge x11 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) graph))
Trying x10
Checking x10 :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x10 ::
x15:{Edge a|_v == (Edge x11 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) x10))
Trying x11
Checking x11 :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x11 ::
x15:{Edge a|_v == (Edge x11 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) x11))
Trying x12
Checking x12 :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A7)'
when checking x12 ::
x15:{Edge a|_v == (Edge x11 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) x12))
Trying x2
Checking x2 :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge (Edge x11 x10
                     x12) x2 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x2)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge
                       (Edge x11 x10 x12)
                       x2 of type LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}
Checking Graph (MoreEdge (Edge
                            x11 x10 x12)
                  x2) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x2), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x10 x12)) == [x11] + [x10] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x10 x12) x2) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) x2))
Trying x5
Checking x5 :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 ::
x15:{Edge a|_v == (Edge x11 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) x5))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U5}
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Synthesized argument NoEdge of type {Edges {A9|False}|_v == (NoEdge)}
Checking MoreEdge (Edge x11 x10
                     x12) NoEdge :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 (NoEdge))} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Synthesized argument MoreEdge
                       (Edge x11 x10 x12)
                       NoEdge of type LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}
Checking Graph (MoreEdge (Edge
                            x11 x10 x12)
                  NoEdge) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 (NoEdge)), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge) && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x10 x12)) == [x11] + [x10] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x10 x12) NoEdge) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil ::
x15:{Edge a|_v == (Edge x11 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)}
Trying Graph
Checking Graph :: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X7:_ -> x15:{Edge a|_v == (Edge x11 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (Graph ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:UnweightedGraph A9 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:UnweightedGraph A9 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X7:_ -> x15:{Edge a|_v == (Edge x11 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (nodesOf ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)}
Trying Cons
Checking Cons :: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X8:_ -> X7:_ -> x15:{Edge a|_v == (Edge x11 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (Cons ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)}
Trying MoreEdge
Checking MoreEdge :: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U5}
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge X8 X7)} <: Edges ()
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x20 x21)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Trying x6
Checking x6 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x6 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x6 ??)))
Trying graph
Checking graph :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge graph ??)))
Trying x10
Checking x10 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A9)'
when checking x10 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x10 ??)))
Trying x11
Checking x11 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A9)'
when checking x11 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x11 ??)))
Trying x12
Checking x12 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edge (A9)'
when checking x12 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x12 ??)))
Trying x2
Checking x2 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x2 ??)))
Trying x5
Checking x5 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == x5} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x5 of type {Edge a|_v == x5}
Checking MoreEdge
           x5 :: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 X7)} <: Edges ()
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x21)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Trying x6
Checking x6 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge x5
           x6 :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x6)} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x6)} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       x6 of type {Edges A9|_v == (MoreEdge x5 x6)}
Checking MoreEdge (Edge x11 x10
                     x12) (MoreEdge x5
                             x6) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x11 x10 x12) (MoreEdge x5
                                             x6) of type LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x11 x10 x12) (MoreEdge x5
                                            x6)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 x6), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x10 x12)) == [x11] + [x10] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x10 x12) (MoreEdge x5
                                             x6)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 x6)))
Trying graph
Checking graph :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 graph)))
Trying x10
Checking x10 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A9)'
when checking x10 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 x10)))
Trying x11
Checking x11 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A9)'
when checking x11 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 x11)))
Trying x12
Checking x12 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A9)'
when checking x12 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 x12)))
Trying x2
Checking x2 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge x5
           x2 :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x2)} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x2)} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x2)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       x2 of type {Edges A9|_v == (MoreEdge x5 x2)}
Checking MoreEdge (Edge x11 x10
                     x12) (MoreEdge x5
                             x2) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x11 x10 x12) (MoreEdge x5
                                             x2) of type LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x11 x10 x12) (MoreEdge x5
                                            x2)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 x2), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x10 x12)) == [x11] + [x10] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x10 x12) (MoreEdge x5
                                             x2)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 x2)))
Trying x5
Checking x5 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 x5)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A10|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edges A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U6}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U5} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument NoEdge of type {Edges {A10|False}|_v == (NoEdge)}
Checking MoreEdge x5
           NoEdge :: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 (NoEdge))} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 (NoEdge))} <: LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 (NoEdge))} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       NoEdge of type {Edges A9|_v == (MoreEdge x5 (NoEdge))}
Checking MoreEdge (Edge x11 x10
                     x12) (MoreEdge x5
                             NoEdge) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x11 x10 x12) (MoreEdge x5
                                             NoEdge) of type LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x11 x10 x12) (MoreEdge x5
                                            NoEdge)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x10 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 (NoEdge)), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x10 x12)) == [x11] + [x10], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x10 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge) && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x10 x12)) == [x11] + [x10] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x10 x12) (MoreEdge x5
                                             NoEdge)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5
                                                              NoEdge)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edges A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge x5 Nil)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A10|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edge A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge NoEdge
                                                              ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edge A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (MoreEdge Nil ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)}
Trying Edge
Checking Edge :: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (?? ?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} <: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} /\ X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} /\ X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} <: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x10 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X9:_ -> X8:_ -> X7:_ -> x15:{Edge a|_v == (Edge x11 x10 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x12) (Edge ?? ?? ??)))
Trying x6
Checking x6 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A8 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'a'
when checking x6 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x6) ??))
Trying graph
Checking graph :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A8 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'a'
when checking graph :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      graph) ??))
Trying x10
Checking x10 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking x10 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x10) ??))
Trying x11
Checking x11 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking x11 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x11) ??))
Trying x2
Checking x2 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A8 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'a'
when checking x2 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x2) ??))
Trying x5
Checking x5 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A8 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'a'
when checking x5 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      x5) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'Edges (A9)'
with shape 'a'
when checking NoEdge :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      NoEdge) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'List (A9)'
with shape 'a'
when checking Nil :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x10
                                                      Nil) ??))
Trying x12
Checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Int ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x12
                                                      ??) ??))
Trying x6
Checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Int ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x6
                                                      ??) ??))
Trying graph
Checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Int ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 graph
                                                      ??) ??))
Trying x11
Checking x11 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Int ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Int ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Edge x11
           x11 :: X4:_ -> Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (?? ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x11 x11 x19)} <: X4:_ -> Edge A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x11 x11 x19)} /\ X4:_ -> Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x11 x11 x19)} /\ X4:_ -> Edge A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x19:A8 -> {Edge A8|_v == (Edge x11 x11 x19)} <: X4:_ -> Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x11 x11 X4)} <: Edge ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x11 x11 x19)} /\ Edge ()
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x19, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Trying x10
Checking x10 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking x10 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x10) ??))
Trying x12
Checking x12 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: A8 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: {a|U4} ()
Constraints
  C1 && (M0 && (_v == x12 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument x12 of type {a|_v == x12}
Checking Edge x11 x11
           x12 :: Edge A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge A8|_v == (Edge x11 x11 x12)} <: Edge A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge A8|_v == (Edge x11 x11 x12)} <: Edge A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == (Edge x11 x11 x12)} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Synthesized argument Edge x11
                       x11
                       x12 of type {Edge A8|_v == (Edge x11 x11 x12)}
Checking MoreEdge (Edge x11 x11
                     x12) :: X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} /\ X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} /\ X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: X2:_ -> Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 X2)} <: Edges ()
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
X2, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Trying x10
Checking x10 :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x10 ::
x15:{Edge a|_v == (Edge x11 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) x10))
Trying x6
Checking x6 :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge (Edge x11 x11
                     x12) x6 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x6)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge
                       (Edge x11 x11 x12)
                       x6 of type LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}
Checking Graph (MoreEdge (Edge
                            x11 x11 x12)
                  x6) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x6)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x6), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x6) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x6)) == nodes x15 + nodeSet x6 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x11 x12)) == [x11] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x11 x12) x6) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) x6))
Trying graph
Checking graph :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph ::
x15:{Edge a|_v == (Edge x11 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) graph))
Trying x12
Checking x12 :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A7)'
when checking x12 ::
x15:{Edge a|_v == (Edge x11 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) x12))
Trying x2
Checking x2 :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U3} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge (Edge x11 x11
                     x12) x2 :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x2)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge
                       (Edge x11 x11 x12)
                       x2 of type LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}
Checking Graph (MoreEdge (Edge
                            x11 x11 x12)
                  x2) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x2)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x2), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x2) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x2)) == nodes x15 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x11 x12)) == [x11] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x11 x12) x2) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) x2))
Trying x5
Checking x5 :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 ::
x15:{Edge a|_v == (Edge x11 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) x5))
Trying x11
Checking x11 :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A7)'
when checking x11 ::
x15:{Edge a|_v == (Edge x11 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) x11))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U5}
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Synthesized argument NoEdge of type {Edges {A9|False}|_v == (NoEdge)}
Checking MoreEdge (Edge x11 x11
                     x12) NoEdge :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 (NoEdge))} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 0)
Synthesized argument MoreEdge
                       (Edge x11 x11 x12)
                       NoEdge of type LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}
Checking Graph (MoreEdge (Edge
                            x11 x11 x12)
                  NoEdge) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 (NoEdge))}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (7 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 (NoEdge)), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum (NoEdge) == 0, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge), nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 (NoEdge))) == nodes x15 + nodeSet (NoEdge) && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x11 x12)) == [x11] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x11 x12) NoEdge) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) NoEdge))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil ::
x15:{Edge a|_v == (Edge x11 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) Nil))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)}
Trying Graph
Checking Graph :: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edges A9 -> {UnweightedGraph A9|_v == (Graph x20)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X7:_ -> x15:{Edge a|_v == (Edge x11 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (Graph ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:UnweightedGraph A9 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:{UnweightedGraph A9|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x20} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:UnweightedGraph A9 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X7:_ -> x15:{Edge a|_v == (Edge x11 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (nodesOf ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)}
Trying Cons
Checking Cons :: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:A9 -> x21:List A9 -> {List A9|_v == (Cons x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X8:_ -> X7:_ -> x15:{Edge a|_v == (Edge x11 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (Cons ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)}
Trying MoreEdge
Checking MoreEdge :: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} /\ X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Edge A9 -> x21:Edges A9 -> {Edges A9|_v == (MoreEdge x20 x21)} <: X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U5}
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge X8 X7)} <: Edges ()
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x20 x21)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x20, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
X7, X8, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Trying x10
Checking x10 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A9)'
when checking x10 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x10 ??)))
Trying x6
Checking x6 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x6 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x6 ??)))
Trying graph
Checking graph :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge graph ??)))
Trying x12
Checking x12 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edge (A9)'
when checking x12 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x12 ??)))
Trying x2
Checking x2 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x2 ??)))
Trying x5
Checking x5 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == x5} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x5 of type {Edge a|_v == x5}
Checking MoreEdge
           x5 :: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} /\ X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x21:Edges A9 -> {Edges A9|_v == (MoreEdge x5 x21)} <: X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 X7)} <: Edges ()
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x21)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x21, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} /\ {a|U3} ()
X7, graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Trying x10
Checking x10 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A9)'
when checking x10 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 x10)))
Trying x6
Checking x6 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge x5
           x6 :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x6)} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x6)} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       x6 of type {Edges A9|_v == (MoreEdge x5 x6)}
Checking MoreEdge (Edge x11 x11
                     x12) (MoreEdge x5
                             x6) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x11 x11 x12) (MoreEdge x5
                                             x6) of type LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x11 x11 x12) (MoreEdge x5
                                            x6)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x6)}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 x6), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x6) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x11 x12)) == [x11] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x11 x12) (MoreEdge x5
                                             x6)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 x6)))
Trying graph
Checking graph :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 graph)))
Trying x12
Checking x12 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A9)'
when checking x12 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 x12)))
Trying x2
Checking x2 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A9 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U5} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U5
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge x5
           x2 :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x2)} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 x2)} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x2)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       x2 of type {Edges A9|_v == (MoreEdge x5 x2)}
Checking MoreEdge (Edge x11 x11
                     x12) (MoreEdge x5
                             x2) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x11 x11 x12) (MoreEdge x5
                                             x2) of type LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x11 x11 x12) (MoreEdge x5
                                            x2)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 x2)}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 x2), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 x2) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x11 x12)) == [x11] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x11 x12) (MoreEdge x5
                                             x2)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 x2)))
Trying x11
Checking x11 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A9)'
when checking x11 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 x11)))
Trying x5
Checking x5 :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A9 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 x5)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A10|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edges A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U6}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U5} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument NoEdge of type {Edges {A10|False}|_v == (NoEdge)}
Checking MoreEdge x5
           NoEdge :: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 (NoEdge))} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A9|_v == (MoreEdge x5 (NoEdge))} <: LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 (NoEdge))} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U5} <: {a|U3} ()
Constraints
  C1 && (M0 && (U5 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument MoreEdge x5
                       NoEdge of type {Edges A9|_v == (MoreEdge x5 (NoEdge))}
Checking MoreEdge (Edge x11 x11
                     x12) (MoreEdge x5
                             NoEdge) :: Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)} <: Edges A6 ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x15 x16)} <: Edges ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Constraints
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 0)
Synthesized argument MoreEdge
                       (Edge x11 x11 x12) (MoreEdge x5
                                             NoEdge) of type LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}
Checking Graph (MoreEdge (Edge
                            x11 x11 x12) (MoreEdge x5
                                            NoEdge)) :: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:({Edges A9|_v == (MoreEdge x5 (NoEdge))}) IN LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN {Edges A7|_v == (MoreEdge x15 x16)}) IN {UnweightedGraph A6|_v == (Graph x14)} <: {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A10 -> {a|U6}
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {a|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x14)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U2} <: {a|U1} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x14} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}] (9 1)
Invalid Constraint: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x14 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x15 == (Edge x11 x11 x12), x5 == (Edge x10 x11 x12), x14 == (MoreEdge x15 x16), x16 == (MoreEdge x5 (NoEdge)), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size _v == edgeNum x14, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], nodes ((Edge x11 x11 x12)) == [x11] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x14 >= 0, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x15 == (Edge x11 x11 x12) && (x5 == (Edge x10 x11 x12) && (x14 == (MoreEdge x15 x16) && (x16 == (MoreEdge x5 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x15 x16)) == 1 + edgeNum x16 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x14 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x15 x16)) == nodes x15 + nodeSet x16 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge) && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (nodes ((Edge x11 x11 x12)) == [x11] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x14 >= 0 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge
                       (Edge x11 x11 x12) (MoreEdge x5
                                             NoEdge)) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5
                                                              NoEdge)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edges A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edges A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x5 Nil)))
Trying x11
Checking x11 :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A9 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A9)'
when checking x11 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge x11 ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A10|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A10|False}|_v == (NoEdge)} <: Edge A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge NoEdge
                                                              ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A9 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edge A9 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A10|False}|_v == (Nil)} <: Edge A9 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A10
UNIFY A10 WITH {a|U5} PRODUCING {a|U6}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (MoreEdge Nil ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)}
Trying Edge
Checking Edge :: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (?? ?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} <: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} /\ X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} /\ X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x20:Int -> x21:Int -> x22:A9 -> {Edge A9|_v == (Edge x20 x21 x22)} <: X9:_ -> X8:_ -> X7:_ -> LET x15:({Edge A8|_v == (Edge x11 x11 x12)}) IN Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X9:_ -> X8:_ -> X7:_ -> x15:{Edge a|_v == (Edge x11 x11 x12)} -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x12) (Edge ?? ?? ??)))
Trying x6
Checking x6 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: A8 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'a'
when checking x6 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x6) ??))
Trying graph
Checking graph :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: A8 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'a'
when checking graph :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      graph) ??))
Trying x2
Checking x2 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: A8 ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'a'
when checking x2 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x2) ??))
Trying x5
Checking x5 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: A8 ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'a'
when checking x5 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x5) ??))
Trying x11
Checking x11 :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking x11 :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      x11) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'Edges (A9)'
with shape 'a'
when checking NoEdge :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      NoEdge) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'List (A9)'
with shape 'a'
when checking Nil :: a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x11
                                                      Nil) ??))
Trying x2
Checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Int ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x2
                                                      ??) ??))
Trying x5
Checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Int ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 x5
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'Edges (A9)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11
                                                      NoEdge ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'List (A9)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x11 Nil
                                                      ??) ??))
Trying x12
Checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge ?? ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Int ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Int'
when checking x12 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x12 ??
                                                      ??) ??))
Trying x6
Checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge ?? ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Int ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x6 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x6 ?? ??)
                                            ??))
Trying graph
Checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge ?? ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Int ()
TYPE ERROR: Cannot match shape 'UnweightedGraph (a)'
with shape 'Int'
when checking graph :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge graph ??
                                                      ??) ??))
Trying x2
Checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge ?? ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Int ()
TYPE ERROR: Cannot match shape 'Edges (a)'
with shape 'Int'
when checking x2 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x2 ?? ??)
                                            ??))
Trying x5
Checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge ?? ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Int ()
TYPE ERROR: Cannot match shape 'Edge (a)'
with shape 'Int'
when checking x5 :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge x5 ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge ?? ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'Edges (A9)'
with shape 'Int'
when checking NoEdge :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge NoEdge ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge ?? ?? ??)
                                            ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Int ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
TYPE ERROR: Cannot match shape 'List (A9)'
with shape 'Int'
when checking Nil :: Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (MoreEdge (Edge Nil ??
                                                      ??) ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)}
Trying Edge
Checking Edge :: X4:_ -> X3:_ -> X2:_ -> Edges A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} /\ X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Int -> x16:Int -> x17:A7 -> {Edge A7|_v == (Edge x15 x16 x17)} <: X4:_ -> X3:_ -> X2:_ -> Edges A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X4:_ -> X3:_ -> X2:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Graph (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} /\ X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x14} <: X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)}
Trying Cons
Checking Cons :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:A6 -> x15:List A6 -> {List A6|_v == (Cons x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)}
Trying MoreEdge
Checking MoreEdge :: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} /\ X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Edge A6 -> x15:Edges A6 -> {Edges A6|_v == (MoreEdge x14 x15)} <: X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)}
Trying Edge
Checking Edge :: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf (??
                                           ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} /\ X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:Int -> x15:Int -> x16:A6 -> {Edge A6|_v == (Edge x14 x15 x16)} <: X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph A5|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|U1} PRODUCING {a|U2}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X3:_ -> X2:_ -> X1:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> nodesOf
                                  (Edge ?? ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} /\ X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x13:A5 -> x14:List A5 -> {List A5|_v == (Cons x13 x14)} <: X1:_ -> X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A5
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x2, x5, x6 |- A4
UNIFY A5 WITH Int PRODUCING {Int|U1}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x2, x5, x6 |- a
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- C1
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U1}
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X1 X0)} <: {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x13, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x13 x14)} /\ {List|elems _v == vertices graph} ()
X0, X1, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [X1] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && ([_v -> x13]U1 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x13 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (2 0)
Trying x10
Checking x10 :: A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: {Int|U1} ()
Constraints
  C1 && (M0 && (_v == x10 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Synthesized argument x10 of type {Int|_v == x10}
Checking Cons
           x10 :: X0:_ -> {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ?? ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} /\ X0:_ -> {List Int|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x14:List A5 -> {List A5|_v == (Cons x10 x14)} <: X0:_ -> {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
Simple Constraints
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 X0)} <: {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} /\ {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} /\ Int ()
Pred assignment
addSplitConstraint X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems X0} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} /\ {List|elems _v == vertices graph} ()
X0, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems X0} <: {List|elems _v == vertices graph} ()
Constraints
  False ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Cons x10 x14) && (graph == (Graph x2) && (elems _v == vertices graph && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && size graph >= 0))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}] (3 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)}
Trying Graph
Checking Graph :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edges A6 -> {UnweightedGraph A6|_v == (Graph x15)} <: X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Graph ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:{UnweightedGraph A6|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x15} <: X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:UnweightedGraph A6 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {a|False} PRODUCING {a|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U2}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U2} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X2} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x15} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ {Int|U1} ()
Pred assignment
After process simple constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U1} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)}
Trying Graph
Checking Graph :: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edges A7 -> {UnweightedGraph A7|_v == (Graph x16)} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X3)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x16)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
Pred assignment
addSplitConstraint X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X3} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} /\ {a|U2} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x16)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X3} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Graph x16) && (graph == (Graph x2) && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph)))))))))
  C1 && (M0 && (U2 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)}
Trying Graph
Checking Graph :: X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} <: X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} /\ X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} /\ X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A8 -> {UnweightedGraph A8|_v == (Graph x17)} <: X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking Graph ::
X4:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (Graph ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A8 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A8|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A8 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X4:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (nodesOf ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)}
Trying MoreEdge
Checking MoreEdge :: X5:_ -> X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} /\ X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edge A8 -> x18:Edges A8 -> {Edges A8|_v == (MoreEdge x17 x18)} <: X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U4}
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge X5 X4)} <: Edges ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x17 x18)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x17, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Trying x11
Checking x11 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge ??
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A8)'
when checking x11 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x11
                                                     ??)))
Trying x12
Checking x12 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge ??
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edge (A8)'
when checking x12 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x12
                                                     ??)))
Trying x6
Checking x6 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge ??
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x6 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x6
                                                     ??)))
Trying graph
Checking graph :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge ??
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edge'
when checking graph :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge graph
                                                     ??)))
Trying x10
Checking x10 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge ??
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edge (A8)'
when checking x10 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x10
                                                     ??)))
Trying x2
Checking x2 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge ??
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edge A8 ()
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking x2 :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x2
                                                     ??)))
Trying x5
Checking x5 :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge ??
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edge A8 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge|_v == x5} <: Edge ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x5 of type {Edge a|_v == x5}
Checking MoreEdge
           x5 :: X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {Edges A8|_v == (MoreEdge x5 x18)} <: X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {Edges A8|_v == (MoreEdge x5 x18)} /\ X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {Edges A8|_v == (MoreEdge x5 x18)} /\ X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {Edges A8|_v == (MoreEdge x5 x18)} <: X4:_ -> Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 X4)} <: Edges ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x18)} /\ Edges ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Trying x11
Checking x11 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: Edges A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A8)'
when checking x11 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     x11)))
Trying x12
Checking x12 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A8)'
when checking x12 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     x12)))
Trying x6
Checking x6 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A8 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking MoreEdge x5
           x6 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 x6)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 x6)} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x6)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       x6 of type {Edges A8|_v == (MoreEdge x5 x6)}
Checking Graph (MoreEdge x5
                  x6) :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 x6)}) IN {UnweightedGraph A7|_v == (Graph x16)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 x6)}) IN {UnweightedGraph A7|_v == (Graph x16)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x16)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x16} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x16} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x16 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x16 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 x6) && (graph == (Graph x2) && (size _v == edgeNum x16 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x16 == (MoreEdge x5 x6), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x16, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 x6) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x16 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       x6) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     x6)))
Trying graph
Checking graph :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph a|_v == graph} <: Edges A8 ()
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'Edges'
when checking graph :: Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     graph)))
Trying x10
Checking x10 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x10} <: Edges A8 ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'Edges (A8)'
when checking x10 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     x10)))
Trying x2
Checking x2 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x2} <: Edges A8 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x2} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument x2 of type {Edges a|_v == x2}
Checking MoreEdge x5
           x2 :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 x2)} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 x2)} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 x2)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       x2 of type {Edges A8|_v == (MoreEdge x5 x2)}
Checking Graph (MoreEdge x5
                  x2) :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 x2)}) IN {UnweightedGraph A7|_v == (Graph x16)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 x2)}) IN {UnweightedGraph A7|_v == (Graph x16)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x16)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x16} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x16} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x16 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x16 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 x2) && (graph == (Graph x2) && (size _v == edgeNum x16 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x16 == (MoreEdge x5 x2), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2, edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, size _v == edgeNum x16, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 x2) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x2)) == 1 + edgeNum x2 && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (size _v == edgeNum x16 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x2)) == nodes x5 + nodeSet x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       x2) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     x2)))
Trying x5
Checking x5 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edge a|_v == x5} <: Edges A8 ()
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking x5 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     x5)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Edges A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U5}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (NoEdge)} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U4} ()
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Synthesized argument NoEdge of type {Edges {A9|False}|_v == (NoEdge)}
Checking MoreEdge x5
           NoEdge :: Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 (NoEdge))} <: Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges A8|_v == (MoreEdge x5 (NoEdge))} <: Edges A7 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == (MoreEdge x5 (NoEdge))} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Constraints
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 0)
Synthesized argument MoreEdge x5
                       NoEdge of type {Edges A8|_v == (MoreEdge x5 (NoEdge))}
Checking Graph (MoreEdge x5
                  NoEdge) :: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 (NoEdge))}) IN {UnweightedGraph A7|_v == (Graph x16)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:({Edges A8|_v == (MoreEdge x5 (NoEdge))}) IN {UnweightedGraph A7|_v == (Graph x16)} <: {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {a|U2}
A7 -> {a|U3}
A8 -> {a|U4}
A9 -> {a|U5}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x16)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x16} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U3} <: {a|U2} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x16} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x16 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U3 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (8 1)
Invalid Constraint: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x16 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Strengthening: C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 (NoEdge)) && (graph == (Graph x2) && (size _v == edgeNum x16 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))) ==> size _v < size graph && size _v >= 0
Instantiated axioms:
edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2
All assumptions:
x5 == (Edge x10 x11 x12), x16 == (MoreEdge x5 (NoEdge)), x2 == (MoreEdge x5 x6), graph == (Graph x2), edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6, edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge), edgeNum (NoEdge) == 0, size _v == edgeNum x16, size ((Graph x2)) == edgeNum x2, nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6, nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge), nodeSet (NoEdge) == [], nodes ((Edge x10 x11 x12)) == [x10] + [x11], vertices ((Graph x2)) == nodeSet x2, edgeNum x16 >= 0, edgeNum x2 >= 0, edgeNum x6 >= 0, size graph >= 0
RHS: size _v < size graph && size _v >= 0
assumption x5 == (Edge x10 x11 x12) && (x16 == (MoreEdge x5 (NoEdge)) && (x2 == (MoreEdge x5 x6) && (graph == (Graph x2) && (edgeNum ((MoreEdge x5 x6)) == 1 + edgeNum x6 && (edgeNum ((MoreEdge x5 (NoEdge))) == 1 + edgeNum (NoEdge) && (edgeNum (NoEdge) == 0 && (size _v == edgeNum x16 && (size ((Graph x2)) == edgeNum x2 && (nodeSet ((MoreEdge x5 x6)) == nodes x5 + nodeSet x6 && (nodeSet ((MoreEdge x5 (NoEdge))) == nodes x5 + nodeSet (NoEdge) && (nodeSet (NoEdge) == [] && (nodes ((Edge x10 x11 x12)) == [x10] + [x11] && (vertices ((Graph x2)) == nodeSet x2 && (edgeNum x16 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))))))))))))))
mustHave !(size _v < size graph && size _v >= 0)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Graph (MoreEdge x5
                       NoEdge) ::
{UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     NoEdge)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Edges A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U4} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Nil :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge x5
                                                     Nil)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {Edges a|_v == (NoEdge)}
INTO {Edges {A9|False}|_v == (NoEdge)}
Trying NoEdge
Checking NoEdge :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge ??
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges {A9|False}|_v == (NoEdge)} <: Edge A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U4} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'Edge'
when checking NoEdge :: Edge a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge NoEdge
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: Edge A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge ??
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Edge A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List {A9|False}|_v == (Nil)} <: Edge A8 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A9
UNIFY A9 WITH {a|U4} PRODUCING {a|U5}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edge'
when checking Nil :: Edge a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (MoreEdge Nil
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} /\ X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:A8 -> x18:List A8 -> {List A8|_v == (Cons x17 x18)} <: X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'List'
with shape 'Edges'
when checking Cons ::
X5:_ -> X4:_ -> Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (Cons ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)}
Trying Edge
Checking Edge :: X6:_ -> X5:_ -> X4:_ -> Edges A7 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (?? ?? ?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> Edges A7 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> Edges A7 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} /\ X6:_ -> X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Int -> x18:Int -> x19:A8 -> {Edge A8|_v == (Edge x17 x18 x19)} <: X6:_ -> X5:_ -> X4:_ -> Edges A7 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'Edges'
when checking Edge ::
X6:_ -> X5:_ -> X4:_ -> Edges a
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Graph (Edge ?? ??
                                                     ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} /\ X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x16} <: X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
TYPE ERROR: Cannot match shape 'Int'
with shape 'a'
when checking nodesOf ::
X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)}
Trying MoreEdge
Checking MoreEdge :: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)}
Trying Cons
Checking Cons :: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)}
Trying Edge
Checking Edge :: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} <: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} /\ X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} /\ X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} <: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)}
Trying MoreEdge
Checking MoreEdge :: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Edge A7 -> x17:Edges A7 -> {Edges A7|_v == (MoreEdge x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'UnweightedGraph'
when checking MoreEdge ::
X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (MoreEdge ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)}
Trying Cons
Checking Cons :: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} /\ X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:A7 -> x17:List A7 -> {List A7|_v == (Cons x16 x17)} <: X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'List'
with shape 'UnweightedGraph'
when checking Cons ::
X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Cons ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)}
Trying Edge
Checking Edge :: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} <: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} /\ X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} /\ X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} <: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . src:Int -> dst:Int -> option:a -> {Edge a|_v == (Edge src dst option)}
INTO x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)}
Trying Edge
Checking Edge :: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (?? ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} <: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} /\ X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} /\ X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:Int -> x17:Int -> x18:A7 -> {Edge A7|_v == (Edge x16 x17 x18)} <: X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph A6|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|U2} PRODUCING {a|U3}
TYPE ERROR: Cannot match shape 'Edge'
with shape 'UnweightedGraph'
when checking Edge ::
X5:_ -> X4:_ -> X3:_ -> {UnweightedGraph a|size _v >= 0 && size _v < size graph}
in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (nodesOf (Edge ?? ?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . e:Edge a -> es:Edges a -> {Edges a|_v == (MoreEdge e es)}
INTO x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)}
Trying MoreEdge
Checking MoreEdge :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:Edge A6 -> x16:Edges A6 -> {Edges A6|_v == (MoreEdge x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
TYPE ERROR: Cannot match shape 'Edges'
with shape 'List'
when checking MoreEdge ::
X3:_ -> X2:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (MoreEdge ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} /\ X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x15:A6 -> x16:List A6 -> {List A6|_v == (Cons x15 x16)} <: X3:_ -> X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A6
UNIFY A6 WITH {Int|U1} PRODUCING {Int|U2}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {Int|U2}
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons X3 X2)} <: List ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x15 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x15, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, X3, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (4 0)
Trying x11
Checking x11 :: A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons ?? ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|_v == x11} <: {Int|U2} ()
Constraints
  C1 && (M0 && (_v == x11 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Synthesized argument x11 of type {Int|_v == x11}
Checking Cons
           x11 :: X2:_ -> List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 (??
                                            ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} <: X2:_ -> List A5 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} /\ X2:_ -> List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} /\ X2:_ -> List A5 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x16:List A6 -> {List A6|_v == (Cons x11 x16)} <: X2:_ -> List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
Simple Constraints
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 X2)} <: List ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x16)} /\ List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} /\ {Int|U1} ()
X2, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  C1 && (M0 && (U1 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}] (5 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)}
Trying Graph
Checking Graph :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:Edges A7 -> {UnweightedGraph A7|_v == (Graph x17)} <: X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {Int|U2} PRODUCING {Int|U3}
TYPE ERROR: Cannot match shape 'UnweightedGraph'
with shape 'List'
when checking Graph ::
X4:_ -> List Int in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (Graph ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
INSTANTIATE <a> . x0:{UnweightedGraph a|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x0}
INTO x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17}
Trying nodesOf
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
Checking nodesOf :: X4:_ -> List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (?? ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> List A6 ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} /\ X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:{UnweightedGraph A7|size _v >= 0 && size _v < size graph} -> {List Int|elems _v == vertices x17} <: X4:_ -> List A6 ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x17:UnweightedGraph A7 -> {List {Int|False}|False} <: graph:{UnweightedGraph {a|False}|False} -> List Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A7
UNIFY A7 WITH {a|False} PRODUCING {a|U3}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U3}
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|False} <: List ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|False} <: Int ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|False} <: UnweightedGraph ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|False} <: {a|U3} ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices X4} <: List ()
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x17} /\ List ()
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int /\ {Int|U2} ()
Pred assignment
After process simple constraints
X4, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (6 0)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
INSTANTIATE <a> . edges:Edges a -> {UnweightedGraph a|_v == (Graph edges)}
INTO x18:Edges A8 -> {UnweightedGraph A8|_v == (Graph x18)}
Trying Graph
Checking Graph :: X5:_ -> {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf (?? ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {UnweightedGraph A8|_v == (Graph x18)} <: X5:_ -> {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {UnweightedGraph A8|_v == (Graph x18)} /\ X5:_ -> {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {UnweightedGraph A8|_v == (Graph x18)} /\ X5:_ -> {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- x18:Edges A8 -> {UnweightedGraph A8|_v == (Graph x18)} <: X5:_ -> {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- A8
UNIFY A8 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 |- {a|U4}
X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph X5)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x18)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
Pred assignment
addSplitConstraint X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X5} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} /\ {a|U3} ()
graph, nodesOf, x10, x11, x12, x18, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x18)} /\ {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
X5, graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum X5} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  False ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (_v == (Graph x18) && (graph == (Graph x2) && (edgeNum x18 >= 0 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (size graph >= 0 && (size _v >= 0 && size _v < size graph)))))))))
  C1 && (M0 && (U3 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (8 0)
Trying x12
Checking x12 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf (Graph ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|_v == x12} <: Edges A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Edges (A8)'
when checking x12 :: Edges a in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf (Graph x12)))
Trying x6
Checking x6 :: Edges A8 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf (Graph ??)))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A8 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges a|_v == x6} <: Edges A8 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Edges|_v == x6} <: Edges ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- a <: {a|U4} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U4
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (9 0)
Synthesized argument x6 of type {Edges a|_v == x6}
Checking Graph
           x6 :: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 (nodesOf ??))
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A8|_v == (Graph x6)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph A8|_v == (Graph x6)} <: {UnweightedGraph A7|size _v >= 0 && size _v < size graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|_v == (Graph x6)} <: {UnweightedGraph|size _v >= 0 && size _v < size graph} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x6} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {a|U4} <: {a|U3} ()
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {UnweightedGraph|size _v == edgeNum x6} <: {UnweightedGraph|size _v < size graph && size _v >= 0} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (size _v == edgeNum x6 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> size _v < size graph && size _v >= 0
  C1 && (M0 && (U4 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (10 0)
Synthesized argument Graph
                       x6 of type {UnweightedGraph A8|_v == (Graph x6)}
Checking nodesOf (Graph
                    x6) :: List A6 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10
                                  (Cons x11 ??)
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x17:({UnweightedGraph A8|_v == (Graph x6)}) IN {List Int|elems _v == vertices x17} <: List A6 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x17:({UnweightedGraph A8|_v == (Graph x6)}) IN {List Int|elems _v == vertices x17} <: List A6 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == vertices x17} <: List ()
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x17, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- Int <: {Int|U2} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (10 0)
Synthesized argument nodesOf
                       (Graph
                          x6) of type LET x17:({UnweightedGraph A8|_v == (Graph x6)}) IN {List Int|elems _v == vertices x17}
Checking Cons x11 (nodesOf
                     (Graph x6)) :: List A5 in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> Cons x10 ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:(LET x17:({UnweightedGraph A8|_v == (Graph x6)}) IN {List Int|elems _v == vertices x17}) IN {List A6|_v == (Cons x11 x16)} <: List A5 ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x16:(LET x17:({UnweightedGraph A8|_v == (Graph x6)}) IN {List Int|elems _v == vertices x17}) IN {List A6|_v == (Cons x11 x16)} <: List A5 ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x11 x16)} <: List ()
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Pred assignment
After process simple constraints
graph, nodesOf, x10, x11, x12, x16, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U2} <: {Int|U1} ()
Constraints
  C1 && (M0 && (U2 && (x5 == (Edge x10 x11 x12) && (graph == (Graph x2) && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && size graph >= 0)))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (10 0)
Synthesized argument Cons x11
                       (nodesOf (Graph
                                   x6)) of type LET x16:(LET x17:({UnweightedGraph A8|_v == (Graph x6)}) IN {List Int|elems _v == vertices x17}) IN {List A6|_v == (Cons x11 x16)}
Checking Cons x10 (Cons x11
                     (nodesOf (Graph
                                 x6))) :: {List Int|elems _v == vertices graph} in
\graph . 
  match graph with
    Graph x2 -> 
      match x2 with
        MoreEdge x5 x6 -> 
          match x5 with
            Edge x10 x11 x12 -> ??
Adding constraint graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:(LET x17:({UnweightedGraph A8|_v == (Graph x6)}) IN {List Int|elems _v == vertices x17}) IN {List A6|_v == (Cons x11 x16)}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Typing Constraints
graph, nodesOf, x10, x11, x12, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- LET x14:(LET x16:(LET x17:({UnweightedGraph A8|_v == (Graph x6)}) IN {List Int|elems _v == vertices x17}) IN {List A6|_v == (Cons x11 x16)}) IN {List A5|_v == (Cons x10 x14)} <: {List Int|elems _v == vertices graph} ()
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|_v == (Cons x10 x14)} <: {List|elems _v == vertices graph} ()
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {Int|U1} <: Int ()
Pred assignment
addSplitConstraint graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
After process simple constraints
graph, nodesOf, x10, x11, x12, x14, x2, x5, x6 True, C1, M0, x5 == (Edge x10 x11 x12), graph == (Graph x2) |- {List|elems _v == [x10] + elems x14} <: {List|elems _v == vertices graph} ()
Constraints
  C1 && (M0 && (x5 == (Edge x10 x11 x12) && (x14 == (Cons x11 x16) && (graph == (Graph x2) && (x17 == (Graph x6) && (elems _v == [x10] + elems x14 && (elems x16 == vertices x17 && (edgeNum x2 >= 0 && (edgeNum x6 >= 0 && (len x14 >= 0 && (len x16 >= 0 && (size graph >= 0 && size x17 >= 0)))))))))))) ==> elems _v == vertices graph
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (11 0)
Typing Constraints
Type assignment
A0 -> a
A1 -> a
A2 -> {Int|U0}
A3 -> a
A4 -> a
A5 -> {Int|U1}
A6 -> {Int|U2}
A7 -> {a|U3}
A8 -> {a|U4}
Simple Constraints
Pred assignment
After process simple constraints
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {x2 == (MoreEdge x5 x6)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {x2 == (MoreEdge x5 x6)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (11 0)
Auxiliary goals are:
