Checking error in
error
Adding constraint range |- {Int|0 == 0} <: {Int|False} ()
Typing Constraints
range |- {Int|0 == 0} <: {Int|False} ()
Type assignment
Simple Constraints
range |- {Int|0 == 0} <: {Int|False} ()
Pred assignment
Simple Constraints
range |- {Int|0 == 0} <: {Int|False} ()
Constraints
  0 == 0 ==> False
QMap
Candidates (1)
  0: [] (0 1)
Chosen candidate: 0: [] (0 1)
Invalid Constraint: 0 == 0 ==> False
Strengthening: 0 == 0 ==> False
Instantiated axioms:
All assumptions:
0 == 0
RHS: False
assumption True
mustHave 0 == 0
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
error
Adding constraint lo, range, size |- C0
Looking for type {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
Trying lo
Checking lo :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . ??
Adding constraint lo, range, size C0 |- {Int|_v == lo} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C0 |- {Int|_v == lo} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C0
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . lo
Trying size
Checking size :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . ??
Adding constraint lo, range, size C0 |- {Int|_v == size} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C0 |- {Int|_v == size} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C0
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . size
Adding constraint lo, range, size |- A0
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A0|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . ??
Adding constraint lo, range, size C0 |- {PList {A0|False} <False>|_v == (Nil)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C0 |- {PList {A0|False} <False>|_v == (Nil)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- A0
lo, range, size |- C0
UNIFY A0 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U0}
Type assignment
A0 -> {Int|U0}
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
lo, range, size |- C0
lo, range, size |- {Int|U0}
lo, range, size C0 |- {PList|_v == (Nil)} <: {PList|len _v == size} ()
lo, range, size C0 |- {Int|False} <: {Int|_0 != _1} ()
lo, range, size C0 |- {Int|False} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
addSplitConstraint lo, range, size C0 |- {PList|len _v == 0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size C0 |- {PList|len _v == 0} <: {PList|len _v == size} ()
Constraints
  C0 && (len _v == 0 && size >= 0) ==> len _v == size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {}, U0 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}, U0 -> {}] (0 1)
Invalid Constraint: C0 && (len _v == 0 && size >= 0) ==> len _v == size
Strengthening: C0 && (len _v == 0 && size >= 0) ==> len _v == size
Instantiated axioms:
All assumptions:
len _v == 0, size >= 0
RHS: len _v == size
assumption len _v == 0 && size >= 0
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= 0
          ,size <= lo]
Optimal valuations:
{lo <= 0, size <= lo}
{size <= 0}
Pruned valuations:
{size <= 0}
Diffs: (1)
[C0 -> {size <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, U0 -> {}] (1 0)
Typing Constraints
Type assignment
A0 -> {Int|U0}
Simple Constraints
Pred assignment
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, U0 -> {}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, U0 -> {}] (1 0)
Auxiliary goals are:
Adding constraint lo, range, size |- C2
Trying lo
Checking lo :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking lo ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else lo
Trying size
Checking size :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking size ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else size
Trying zero
Checking zero :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking zero ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else zero
Adding constraint lo, range, size |- A1
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A1|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList {A1|False} <False>|_v == (Nil)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A1|False} <False>|_v == (Nil)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- A1
lo, range, size |- C2
UNIFY A1 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U1}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size |- C2
lo, range, size |- {Int|U1}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: {PList|len _v == size} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
addSplitConstraint lo, range, size C1, C2 |- {PList|len _v == 0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == 0} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 0 && size >= 0)) ==> len _v == size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (1 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}, U1 -> {}] (1 1)
Invalid Constraint: C1 && (C2 && (len _v == 0 && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 0 && size >= 0)) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 0, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 0 && size >= 0)
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Nil
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x1:Int -> {Int|_v == x1 - 1}
Trying dec
Checking dec :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec ??
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x1:Int -> {Int|_v == x1 + 1}
Trying inc
Checking inc :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc ??
Adding constraint lo, range, size |- A1
Adding constraint |- P0 :: A1 -> A1 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ?? ??
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
|- P0 :: A1 -> A1 -> Bool
lo, range, size |- A1
lo, range, size |- C2
UNIFY A1 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U1}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size |- C2
lo, range, size |- {Int|U1}
X0, X1, lo, range, size C1, C2 |- {PList|_v == (Cons X1 X0)} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {}, U0 -> {}, U1 -> {}] (2 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {}, U0 -> {}, U1 -> {}] (2 2)
Invalid Constraint: C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
Strengthening: C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: _0 != _1
assumption !(size <= 0) && size >= 0
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, _1 <= lo + _0, lo <= 0}
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P0 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {}] (3 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {}] (3 1)
Invalid Constraint: C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Strengthening: C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: lo <= _v && _v <= lo + size
assumption !(size <= 0) && size >= 0
mustHave !(lo <= _v && _v <= lo + size)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{0 <= lo, _v <= 0 + size, lo <= 0, size <= _v}
{_v <= size + lo, lo <= 0, size <= _v}
{0 <= _v, _v <= size + lo, lo <= 0}
{_v <= 0 + size, lo <= _v, size <= lo}
{0 <= lo, _v <= 0 + size, lo <= _v}
{_v <= 0 + size, lo <= size, size <= _v, size <= lo}
{0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{_v <= 0 + lo, lo <= size, size <= _v}
{0 <= _v, _v <= 0 + lo, lo <= 0}
{_v <= size + lo, lo <= _v}
{_v <= size + lo, lo <= size, size <= _v}
{_v <= 0 + lo, lo <= _v}
Pruned valuations:
{_v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U1 -> {_v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && ([_v -> x1]U1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Trying lo
Checking lo :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument lo of type {Int|_v == lo}
Checking Cons
           lo :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X0, lo, range, size C1, C2 |- {PList|_v == (Cons lo X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} /\ {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == (Cons lo x2) && (len _v == size && (size >= 0 && len x2 >= 0))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying size
Checking size :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking size ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo size
Trying lo
Checking lo :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking lo ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo lo
Trying zero
Checking zero :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking zero ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 lo _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Synthesized argument Nil of type {PList {A2|False} <False>|_v == (Nil)}
Checking Cons lo
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList A1 <P0 _0 _1>|_v == (Cons lo (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {PList A1 <P0 _0 _1>|_v == (Cons lo (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|_v == (Cons lo (Nil))} <: {PList|len _v == size} ()
lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && size >= 0)))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo Nil
Trying size
Checking size :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U1
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
{0 <= lo, lo <= size}
{lo <= size, size <= lo}
Pruned valuations:
{0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument size of type {Int|_v == size}
Checking Cons
           size :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 size _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 size _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons size x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {A1|P0 size _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons size x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {A1|P0 size _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X0, lo, range, size C1, C2 |- {PList|_v == (Cons size X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} /\ {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == (Cons size x2) && (len _v == size && (size >= 0 && len x2 >= 0))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying lo
Checking lo :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A1|P0 size _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking lo ::
PList {Int|(_v <= size + lo && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size lo
Trying size
Checking size :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A1|P0 size _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking size ::
PList {Int|(_v <= size + lo && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size size
Trying zero
Checking zero :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A1|P0 size _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking zero ::
PList {Int|(_v <= size + lo && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {A1|P0 size _v} <P0 _0 _1> ()
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 size _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Synthesized argument Nil of type {PList {A2|False} <False>|_v == (Nil)}
Checking Cons size
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList A1 <P0 _0 _1>|_v == (Cons size (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {PList A1 <P0 _0 _1>|_v == (Cons size (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|_v == (Cons size (Nil))} <: {PList|len _v == size} ()
lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], 0 <= lo, lo <= size, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && (0 <= lo && (lo <= size && size >= 0)))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size Nil
Trying zero
Checking zero :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U1
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == zero && (zero == 0 && size >= 0))
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
Pruned valuations:
{0 <= lo, lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument zero of type {Int|_v == zero}
Checking Cons
           zero :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 zero _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 zero _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {A1|P0 zero _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {A1|P0 zero _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X0, lo, range, size C1, C2 |- {PList|_v == (Cons zero X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} /\ {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (zero == 0 && (_v == (Cons zero x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying lo
Checking lo :: PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking lo ::
PList {Int|(_v <= size + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero lo
Trying size
Checking size :: PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking size ::
PList {Int|(_v <= size + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero size
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 zero _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 0)
Synthesized argument Nil of type {PList {A2|False} <False>|_v == (Nil)}
Checking Cons zero
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- {PList A1 <P0 _0 _1>|_v == (Cons zero (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- {PList A1 <P0 _0 _1>|_v == (Cons zero (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|_v == (Cons zero (Nil))} <: {PList|len _v == size} ()
lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && size >= 0)))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero Nil
Trying zero
Checking zero :: PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking zero ::
PList {Int|(_v <= size + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: A1 ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons Nil ??
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1}
Trying range
Adding constraint lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ?? ??
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
lo, range, size |- C2
Type assignment
A0 -> {Int|U0}
Simple Constraints
lo, range, size |- C2
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|X0 <= _v && _v <= X0 + X1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == x1} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|_0 != _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|x2 <= _v && _v <= x2 + x1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|x2 <= _v && _v <= x2 + x1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|_0 != _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == x1} /\ {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|X0 <= _v && _v <= X0 + X1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, X1, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> _0 != _1
  False ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (len _v == size && (len _v == x1 && (size >= 0 && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
  C1 && (C2 && (_0 != _1 && size >= 0))
  C1 && (C2 && (size >= 0 && ((lo <= _v && _v <= lo + size) && ((x2 <= _v && _v <= x2 + x1) && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}] (4 0)
Remaining Candidates (0)
TYPE ERROR: Found inconsistent refinements
when checking range ::
X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else range ?? ??
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x1:Int -> {Int|_v == x1 - 1}
Trying dec
Checking dec :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec ??
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x1:Int -> {Int|_v == x1 + 1}
Trying inc
Checking inc :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc ??
Adding constraint lo, range, size |- A1
Adding constraint |- P0 :: A1 -> A1 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ?? ??
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
|- P0 :: A1 -> A1 -> Bool
lo, range, size |- A1
lo, range, size |- C2
UNIFY A1 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U1}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size |- C2
lo, range, size |- {Int|U1}
X0, X1, lo, range, size C1, C2 |- {PList|_v == (Cons X1 X0)} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {}, U0 -> {}, U1 -> {}] (2 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {}, U0 -> {}, U1 -> {}] (2 2)
Invalid Constraint: C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
Strengthening: C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: _0 != _1
assumption !(size <= 0) && size >= 0
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, _1 <= lo + _0, lo <= 0}
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P0 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {}] (3 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {}] (3 1)
Invalid Constraint: C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Strengthening: C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: lo <= _v && _v <= lo + size
assumption !(size <= 0) && size >= 0
mustHave !(lo <= _v && _v <= lo + size)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{0 <= lo, _v <= 0 + size, lo <= 0, size <= _v}
{0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{0 <= _v, _v <= 0 + lo, lo <= 0}
{_v <= size + lo, lo <= 0, size <= _v}
{0 <= _v, _v <= size + lo, lo <= 0}
{_v <= 0 + size, lo <= size, size <= _v, size <= lo}
{_v <= 0 + lo, lo <= size, size <= _v}
{_v <= size + lo, lo <= size, size <= _v}
{0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{_v <= 0 + size, lo <= _v, size <= lo}
{0 <= lo, _v <= 0 + size, lo <= _v}
{_v <= size + lo, lo <= _v}
{_v <= 0 + lo, lo <= _v}
Pruned valuations:
{_v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U1 -> {_v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && ([_v -> x1]U1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Trying lo
Checking lo :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument lo of type {Int|_v == lo}
Checking Cons
           lo :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X0, lo, range, size C1, C2 |- {PList|_v == (Cons lo X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} /\ {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == (Cons lo x2) && (len _v == size && (size >= 0 && len x2 >= 0))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x3:Int -> {Int|_v == x3 - 1}
Trying dec
Checking dec :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking dec ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (dec ??)
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x3:Int -> {Int|_v == x3 + 1}
Trying inc
Checking inc :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking inc ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (inc ??)
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 lo _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
X2, X3, lo, range, size C1, C2 |- {PList|_v == (Cons X3 X2)} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 2)
Invalid Constraint: C1 && (C2 && (P1 && size >= 0)) ==> P0
Strengthening: C1 && (C2 && (P1 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: _0 != _1
assumption !(size <= 0) && size >= 0
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, _1 <= lo + _0, lo <= 0}
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P1 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (U2 && size >= 0)) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && size >= 0
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{_v <= size + lo, lo <= 0, size <= _v}
{0 <= lo, _v <= 0 + size, lo <= 0, size <= _v}
{lo != _v, 0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{lo != _v, 0 <= _v, _v <= size + lo, lo <= 0}
{0 != _v, 0 <= lo, _v <= 0 + size, lo <= 0, lo <= _v}
{0 != _v, 0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{0 != _v, 0 <= lo, _v <= size + lo, lo <= 0, lo <= _v}
{0 != lo, 0 <= _v, _v <= size + lo, lo <= 0}
{0 != _v, 0 <= _v, _v <= size + lo, lo <= 0}
{size != _v, _v <= size + lo, lo <= size, size <= _v}
{size != _v, _v <= size + lo, lo <= _v, lo <= size, size <= lo}
{lo != _v, _v <= size + lo, lo <= size, size <= _v}
{lo != _v, 0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{lo != _v, 0 <= lo, _v <= 0 + size, lo <= _v}
{lo != _v, _v <= size + lo, lo <= _v}
{size != lo, 0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{size != lo, _v <= 0 + size, _v <= size + lo, lo <= _v, size <= _v}
{size != lo, 0 <= lo, _v <= 0 + size, lo <= _v, size <= _v}
{size != lo, _v <= size + lo, lo <= size, size <= _v}
Pruned valuations:
{lo != _v, _v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (size >= 0 && (U1 && [_0 -> lo, _1 -> _v]P0))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 0)
Trying size
Checking size :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
{size != lo, 0 <= lo, lo <= size}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking Cons
           size :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|_v == (Cons size X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (size >= 0 && (U1 && [_0 -> lo, _1 -> _v]P0))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Trying lo
Checking lo :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size lo)
Trying size
Checking size :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size size)
Trying zero
Checking zero :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 size _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons size
           Nil :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Synthesized argument Cons size
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}
Checking Cons lo (Cons size
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons size
                         Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size Nil)
Trying lo
Checking lo :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking lo ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo ??)
Trying zero
Checking zero :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == zero && (zero == 0 && size >= 0))
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking zero ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero ??)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons Nil ??)
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X2, X3, lo, range, size C1, C2 |- {PList|len _v == X3} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (size >= 0 && ((U1 && [_0 -> lo, _1 -> _v]P0) && ((x4 <= _v && _v <= x4 + x3) && (x3 >= 0 && (x3 >= 0 && x3 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range size ??)
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (size >= 0 && ((U1 && [_0 -> lo, _1 -> _v]P0) && (x4 <= _v && _v <= x4 + lo))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking range lo
           size :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (size >= 0 && (size <= _v && _v <= size + lo))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
Checking Cons lo (range lo
                    size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo size)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range lo
           lo :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (size >= 0 && (lo <= _v && _v <= lo + lo))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (size >= 0 && (lo <= _v && _v <= lo + lo))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (size >= 0 && (lo <= _v && _v <= lo + lo))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), size != lo, 0 <= lo, _v <= lo + lo, lo <= _v, lo <= size, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (size != lo && (0 <= lo && (_v <= lo + lo && (lo <= _v && (lo <= size && size >= 0)))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo lo ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo lo)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range lo
           zero :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, size != lo, 0 <= lo, _v <= zero + lo, lo <= size, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (zero == 0 && (size != lo && (0 <= lo && (_v <= zero + lo && (lo <= size && (zero <= _v && size >= 0))))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo zero ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo Nil)
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> lo, _1 -> _v]P0) && (x4 <= _v && _v <= x4 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking range zero
           size :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero)))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, _v <= size + zero, size <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (zero == 0 && (_v <= size + zero && (size <= _v && size >= 0)))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
{size != lo, 0 <= lo, lo <= size}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
Checking Cons lo (range zero
                    size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero size)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range zero
           lo :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, _v <= lo + zero, lo <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (zero == 0 && (_v <= lo + zero && (lo <= _v && size >= 0)))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero lo ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero lo)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero Nil)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range zero
           zero :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, _v <= zero + zero, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (zero == 0 && (_v <= zero + zero && (zero <= _v && size >= 0)))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero zero ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range Nil ??)
Trying size
Checking size :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U1
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
{0 <= lo, lo <= size}
{lo <= size, size <= lo}
Pruned valuations:
{0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument size of type {Int|_v == size}
Checking Cons
           size :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 size _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 size _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons size x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {A1|P0 size _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons size x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {A1|P0 size _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X0, lo, range, size C1, C2 |- {PList|_v == (Cons size X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} /\ {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == (Cons size x2) && (len _v == size && (size >= 0 && len x2 >= 0))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x3:Int -> {Int|_v == x3 - 1}
Trying dec
Checking dec :: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (?? ??)
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking dec ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (dec ??)
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x3:Int -> {Int|_v == x3 + 1}
Trying inc
Checking inc :: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (?? ??)
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking inc ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (inc ??)
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 size _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
X2, X3, lo, range, size C1, C2 |- {PList|_v == (Cons X3 X2)} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 size _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 2)
Invalid Constraint: C1 && (C2 && (P1 && size >= 0)) ==> P0
Strengthening: C1 && (C2 && (P1 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), 0 <= lo, lo <= size, size >= 0
RHS: _0 != _1
assumption !(size <= 0) && (0 <= lo && (lo <= size && size >= 0))
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P1 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> size, _1 -> _v]P0
Strengthening: C1 && (C2 && (U2 && size >= 0)) ==> (_v <= size + lo && lo <= _v) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), 0 <= lo, lo <= size, size >= 0
RHS: (_v <= size + lo && lo <= _v) && size != _v
assumption !(size <= 0) && (0 <= lo && (lo <= size && size >= 0))
mustHave !((_v <= size + lo && lo <= _v) && size != _v)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{size != lo, _v <= 0 + lo, lo <= _v}
{lo != _v, _v <= size + lo, size <= _v, size <= lo}
{lo != _v, _v <= size + lo, lo <= _v, size <= lo}
{size != _v, 0 <= _v, _v <= size + lo, lo <= 0}
{size != _v, 0 <= _v, _v <= 0 + size, lo <= 0}
{size != _v, _v <= 0 + lo, lo <= _v}
{size != _v, _v <= size + lo, size <= _v}
{0 <= _v, _v <= 0 + lo, lo <= 0}
{_v <= 0 + lo, lo <= 0, lo <= _v}
{size != _v, _v <= size + lo, lo <= _v}
{size != _v, _v <= 0 + size, lo <= _v}
Pruned valuations:
{size != _v, _v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U2 -> {size != _v, _v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (size >= 0 && (U1 && [_0 -> size, _1 -> _v]P0))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (7 0)
Trying lo
Checking lo :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> size != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 <= lo, lo <= size, size >= 0
RHS: size != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == lo && (0 <= lo && (lo <= size && size >= 0)))
mustHave !(size != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{size != lo}
{lo <= 0}
Pruned valuations:
{size != lo}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking Cons
           lo :: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x4)} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x4)} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x4)} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x4)} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|_v == (Cons lo X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons lo x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (size >= 0 && (U1 && [_0 -> size, _1 -> _v]P0))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (8 0)
Trying lo
Checking lo :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(size != _v && (_v <= size + lo && lo <= _v)) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons lo lo)
Trying size
Checking size :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(size != _v && (_v <= size + lo && lo <= _v)) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons lo size)
Trying zero
Checking zero :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(size != _v && (_v <= size + lo && lo <= _v)) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons lo zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons lo ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 lo _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons lo
           Nil :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Synthesized argument Cons lo
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}
Checking Cons size (Cons lo
                      Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (Cons lo
                           Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons lo Nil)
Trying size
Checking size :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> size != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 <= lo, lo <= size, size >= 0
RHS: size != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == size && (0 <= lo && (lo <= size && size >= 0)))
mustHave !(size != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|size != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons size ??)
Trying zero
Checking zero :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> size != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 <= lo, lo <= size, size >= 0
RHS: size != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(size != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{lo <= 0}
Pruned valuations:
{lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking Cons
           zero :: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x4)} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x4)} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x4)} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x4)} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|_v == (Cons zero X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons zero x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (size >= 0 && (U1 && [_0 -> size, _1 -> _v]P0))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}] (8 0)
Trying lo
Checking lo :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(size != _v && (_v <= size + lo && lo <= _v)) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons zero lo)
Trying size
Checking size :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(size != _v && (_v <= size + lo && lo <= _v)) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons zero size)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons zero ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 zero _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 zero _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons zero
           Nil :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
Synthesized argument Cons zero
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))}
Checking Cons size (Cons zero
                      Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (lo <= size && (size >= 0 && len x2 >= 0)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (Cons
                           zero Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons zero Nil)
Trying zero
Checking zero :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(size != _v && (_v <= size + lo && lo <= _v)) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons zero zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|size != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (Cons Nil ??)
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X3:_ -> X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X2, X3, lo, range, size C1, C2 |- {PList|len _v == X3} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|U1 && P0 size _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (size >= 0 && ((U1 && [_0 -> size, _1 -> _v]P0) && ((x4 <= _v && _v <= x4 + x3) && (x3 >= 0 && (x3 >= 0 && x3 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && (0 <= lo && (lo <= size && size >= 0)))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{size != lo}
{lo <= 0}
Pruned valuations:
{size != lo}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|U1 && P0 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (size >= 0 && ((U1 && [_0 -> size, _1 -> _v]P0) && (x4 <= _v && _v <= x4 + lo))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range lo
           lo :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (size >= 0 && (lo <= _v && _v <= lo + lo))) ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (size >= 0 && (lo <= _v && _v <= lo + lo))) ==> U1 && [_0 -> size, _1 -> _v]P0
Strengthening: C1 && (C2 && (size >= 0 && (lo <= _v && _v <= lo + lo))) ==> (_v <= size + lo && lo <= _v) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), size != lo, 0 <= lo, _v <= lo + lo, lo <= _v, lo <= size, size >= 0
RHS: (_v <= size + lo && lo <= _v) && size != _v
assumption !(size <= 0) && (size != lo && (0 <= lo && (_v <= lo + lo && (lo <= _v && (lo <= size && size >= 0)))))
mustHave !((_v <= size + lo && lo <= _v) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{lo <= 0}
Pruned valuations:
{lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
Checking Cons size (range lo
                      lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= 0, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= 0 && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (range
                           lo lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range lo lo)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking range lo
           size :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (size >= 0 && (size <= _v && _v <= size + lo))) ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (size >= 0 && (size <= _v && _v <= size + lo))) ==> U1 && [_0 -> size, _1 -> _v]P0
Strengthening: C1 && (C2 && (size >= 0 && (size <= _v && _v <= size + lo))) ==> (_v <= size + lo && lo <= _v) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), size != lo, 0 <= lo, _v <= size + lo, lo <= size, size <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && size != _v
assumption !(size <= 0) && (size != lo && (0 <= lo && (_v <= size + lo && (lo <= size && (size <= _v && size >= 0)))))
mustHave !((_v <= size + lo && lo <= _v) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo size ::
PList {Int|(_v <= size + lo && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range lo size)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range lo
           zero :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> U1 && [_0 -> size, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> (_v <= size + lo && lo <= _v) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, size != lo, 0 <= lo, _v <= zero + lo, lo <= size, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && size != _v
assumption !(size <= 0) && (zero == 0 && (size != lo && (0 <= lo && (_v <= zero + lo && (lo <= size && (zero <= _v && size >= 0))))))
mustHave !((_v <= size + lo && lo <= _v) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{lo <= 0}
Pruned valuations:
{lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
Checking Cons size (range lo
                      zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= 0, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= 0 && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (range
                           lo zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range lo zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range lo ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range lo Nil)
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (0 <= lo && (lo <= size && size >= 0)))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range size ??)
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|U1 && P0 size _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> size, _1 -> _v]P0) && (x4 <= _v && _v <= x4 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range zero
           lo :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> U1 && [_0 -> size, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> (_v <= size + lo && lo <= _v) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, 0 <= lo, _v <= lo + zero, lo <= _v, lo <= size, size >= 0
RHS: (_v <= size + lo && lo <= _v) && size != _v
assumption !(size <= 0) && (zero == 0 && (0 <= lo && (_v <= lo + zero && (lo <= _v && (lo <= size && size >= 0)))))
mustHave !((_v <= size + lo && lo <= _v) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{size != lo}
{lo <= 0}
Pruned valuations:
{size != lo}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
Checking Cons size (range zero
                      lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (range
                           zero lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range zero lo)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking range zero
           size :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero)))) ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero)))) ==> U1 && [_0 -> size, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero)))) ==> (_v <= size + lo && lo <= _v) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, 0 <= lo, _v <= size + zero, lo <= size, size <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && size != _v
assumption !(size <= 0) && (zero == 0 && (0 <= lo && (_v <= size + zero && (lo <= size && (size <= _v && size >= 0)))))
mustHave !((_v <= size + lo && lo <= _v) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero size ::
PList {Int|(_v <= size + lo && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range zero size)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range zero ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range zero Nil)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range zero
           zero :: PList {A1|P0 size _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 size _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 size _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && [_0 -> size, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> U1 && [_0 -> size, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> U1 && [_0 -> size, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> (_v <= size + lo && lo <= _v) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, 0 <= lo, _v <= zero + zero, lo <= size, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && size != _v
assumption !(size <= 0) && (zero == 0 && (0 <= lo && (_v <= zero + zero && (lo <= size && (zero <= _v && size >= 0)))))
mustHave !((_v <= size + lo && lo <= _v) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{lo <= 0}
Pruned valuations:
{lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
Checking Cons size (range zero
                      zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons size x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons size x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons size (range
                           zero zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range zero zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons size (range Nil ??)
Trying zero
Checking zero :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U1
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == zero && (zero == 0 && size >= 0))
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
Pruned valuations:
{0 <= lo, lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument zero of type {Int|_v == zero}
Checking Cons
           zero :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 zero _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 zero _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {A1|P0 zero _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {A1|P0 zero _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X0, lo, range, size C1, C2 |- {PList|_v == (Cons zero X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} /\ {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (zero == 0 && (_v == (Cons zero x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x3:Int -> {Int|_v == x3 - 1}
Trying dec
Checking dec :: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (?? ??)
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking dec ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (dec ??)
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x3:Int -> {Int|_v == x3 + 1}
Trying inc
Checking inc :: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (?? ??)
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking inc ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (inc ??)
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 zero _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
X2, X3, lo, range, size C1, C2 |- {PList|_v == (Cons X3 X2)} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 zero _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (zero == 0 && size >= 0))) ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 2)
Invalid Constraint: C1 && (C2 && (P1 && size >= 0)) ==> P0
Strengthening: C1 && (C2 && (P1 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), 0 <= lo, lo <= 0, size >= 0
RHS: _0 != _1
assumption !(size <= 0) && (0 <= lo && (lo <= 0 && size >= 0))
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P1 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (U2 && (zero == 0 && size >= 0))) ==> U1 && [_0 -> zero, _1 -> _v]P0
Strengthening: C1 && (C2 && (U2 && (zero == 0 && size >= 0))) ==> (_v <= size + lo && lo <= _v) && zero != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, 0 <= lo, lo <= 0, size >= 0
RHS: (_v <= size + lo && lo <= _v) && zero != _v
assumption !(size <= 0) && (zero == 0 && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !((_v <= size + lo && lo <= _v) && zero != _v)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{lo != _v, _v <= size + lo, lo <= _v}
{lo != _v, _v <= 0 + size, lo <= _v}
{lo != _v, 0 <= _v, _v <= size + lo}
{0 != _v, 0 <= _v, _v <= size + lo}
{_v <= size + lo, size <= _v}
{0 != _v, _v <= size + lo, lo <= _v}
{0 != _v, _v <= 0 + size, lo <= _v}
{lo != _v, 0 <= _v, _v <= 0 + size}
{0 != _v, 0 <= _v, _v <= 0 + size}
{_v <= 0 + size, size <= _v}
Pruned valuations:
{lo != _v, _v <= size + lo, lo <= _v}
{lo != _v, _v <= 0 + size, lo <= _v}
{lo != _v, 0 <= _v, _v <= size + lo}
{0 != _v, 0 <= _v, _v <= size + lo}
{0 != _v, _v <= size + lo, lo <= _v}
{0 != _v, _v <= 0 + size, lo <= _v}
{lo != _v, 0 <= _v, _v <= 0 + size}
{0 != _v, 0 <= _v, _v <= 0 + size}
Diffs: (8)
[C1 -> {}, C2 -> {}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}]
[C1 -> {}, C2 -> {}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}]
[C1 -> {}, C2 -> {}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}]
[C1 -> {}, C2 -> {}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}]
[C1 -> {}, C2 -> {}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}]
[C1 -> {}, C2 -> {}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}]
[C1 -> {}, C2 -> {}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}]
[C1 -> {}, C2 -> {}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}]
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (zero == 0 && (size >= 0 && (U1 && [_0 -> zero, _1 -> _v]P0)))))
Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 0)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 0)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 0)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (7 0)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (7 0)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}] (7 0)
Remaining Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 0)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 0)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 0)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (7 0)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (7 0)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}] (7 0)
Trying lo
Checking lo :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (7 1)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}] (7 1)
Chosen candidate: 0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> 0 != _v && (0 <= _v && _v <= 0 + size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 <= lo, lo <= 0, size >= 0
RHS: 0 != _v && (0 <= _v && _v <= 0 + size)
assumption !(size <= 0) && (_v == lo && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(0 != _v && (0 <= _v && _v <= 0 + size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (7)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (7 1)
Chosen candidate: 0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> lo != _v && (0 <= _v && _v <= 0 + size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 <= lo, lo <= 0, size >= 0
RHS: lo != _v && (0 <= _v && _v <= 0 + size)
assumption !(size <= 0) && (_v == lo && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(lo != _v && (0 <= _v && _v <= 0 + size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (6)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (7 1)
Chosen candidate: 0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> 0 != _v && (_v <= 0 + size && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 <= lo, lo <= 0, size >= 0
RHS: 0 != _v && (_v <= 0 + size && lo <= _v)
assumption !(size <= 0) && (_v == lo && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(0 != _v && (_v <= 0 + size && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (5)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> 0 != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 <= lo, lo <= 0, size >= 0
RHS: 0 != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == lo && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(0 != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (4)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
Chosen candidate: 0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> 0 != _v && (0 <= _v && _v <= size + lo)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 <= lo, lo <= 0, size >= 0
RHS: 0 != _v && (0 <= _v && _v <= size + lo)
assumption !(size <= 0) && (_v == lo && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(0 != _v && (0 <= _v && _v <= size + lo))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
Chosen candidate: 0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> lo != _v && (0 <= _v && _v <= size + lo)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 <= lo, lo <= 0, size >= 0
RHS: lo != _v && (0 <= _v && _v <= size + lo)
assumption !(size <= 0) && (_v == lo && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(lo != _v && (0 <= _v && _v <= size + lo))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> lo != _v && (_v <= 0 + size && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 <= lo, lo <= 0, size >= 0
RHS: lo != _v && (_v <= 0 + size && lo <= _v)
assumption !(size <= 0) && (_v == lo && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(lo != _v && (_v <= 0 + size && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 <= lo, lo <= 0, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == lo && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking lo ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons lo ??)
Trying size
Checking size :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (8 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (8 0)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 0)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (8 0)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (8 0)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (8 0)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}] (8 0)
Remaining Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (8 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (8 0)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 0)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (8 0)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (8 0)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (8 0)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking Cons
           size :: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|_v == (Cons size X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (zero == 0 && size >= 0))) ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (zero == 0 && (size >= 0 && (U1 && [_0 -> zero, _1 -> _v]P0)))))
Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (8 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (8 0)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 0)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (8 0)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (8 0)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (8 0)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}] (8 0)
Remaining Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (8 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (8 0)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 0)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (8 0)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (8 0)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (8 0)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}] (8 0)
Trying lo
Checking lo :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons size lo)
Trying size
Checking size :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons size size)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 size _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 0)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 0)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 0)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 0)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 0)
Remaining Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 0)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 0)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 0)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 0)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons size
           Nil :: PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (zero == 0 && size >= 0))) ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 0)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 0)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 0)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 0)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 0)
Remaining Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 0)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 0)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 0)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 0)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 0)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 0)
Synthesized argument Cons size
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}
Checking Cons zero (Cons size
                      Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 1)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 1)
Chosen candidate: 0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (7)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 1)
Chosen candidate: 0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (6)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
Chosen candidate: 0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (5)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
Chosen candidate: 0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (4)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
Chosen candidate: 0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
Chosen candidate: 0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (Cons
                           size Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons size Nil)
Trying zero
Checking zero :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons size zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons Nil ??)
Trying zero
Checking zero :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (8)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (7 1)
  0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}] (7 1)
Chosen candidate: 0.7: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= 0 + size}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> 0 != _v && (0 <= _v && _v <= 0 + size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 <= lo, lo <= 0, size >= 0
RHS: 0 != _v && (0 <= _v && _v <= 0 + size)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 <= lo && (lo <= 0 && size >= 0))))
mustHave !(0 != _v && (0 <= _v && _v <= 0 + size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (7)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (7 1)
Chosen candidate: 0.6: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= 0 + size}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> lo != _v && (0 <= _v && _v <= 0 + size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 <= lo, lo <= 0, size >= 0
RHS: lo != _v && (0 <= _v && _v <= 0 + size)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 <= lo && (lo <= 0 && size >= 0))))
mustHave !(lo != _v && (0 <= _v && _v <= 0 + size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (6)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (7 1)
Chosen candidate: 0.5: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= 0 + size, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> 0 != _v && (_v <= 0 + size && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 <= lo, lo <= 0, size >= 0
RHS: 0 != _v && (_v <= 0 + size && lo <= _v)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 <= lo && (lo <= 0 && size >= 0))))
mustHave !(0 != _v && (_v <= 0 + size && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (5)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0.4: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> 0 != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 <= lo, lo <= 0, size >= 0
RHS: 0 != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 <= lo && (lo <= 0 && size >= 0))))
mustHave !(0 != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (4)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
  0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
Chosen candidate: 0.3: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> 0 != _v && (0 <= _v && _v <= size + lo)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 <= lo, lo <= 0, size >= 0
RHS: 0 != _v && (0 <= _v && _v <= size + lo)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 <= lo && (lo <= 0 && size >= 0))))
mustHave !(0 != _v && (0 <= _v && _v <= size + lo))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
Chosen candidate: 0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, 0 <= _v, _v <= size + lo}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> lo != _v && (0 <= _v && _v <= size + lo)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 <= lo, lo <= 0, size >= 0
RHS: lo != _v && (0 <= _v && _v <= size + lo)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 <= lo && (lo <= 0 && size >= 0))))
mustHave !(lo != _v && (0 <= _v && _v <= size + lo))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= 0 + size, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> lo != _v && (_v <= 0 + size && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 <= lo, lo <= 0, size >= 0
RHS: lo != _v && (_v <= 0 + size && lo <= _v)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 <= lo && (lo <= 0 && size >= 0))))
mustHave !(lo != _v && (_v <= 0 + size && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 <= lo, lo <= 0, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 <= lo && (lo <= 0 && size >= 0))))
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking zero ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (Cons zero ??)
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X3:_ -> X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X2, X3, lo, range, size C1, C2 |- {PList|len _v == X3} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|U1 && P0 zero _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> zero, _1 -> _v]P0) && ((x4 <= _v && _v <= x4 + x3) && (x3 >= 0 && (x3 >= 0 && x3 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|U1 && P0 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> zero, _1 -> _v]P0) && (x4 <= _v && _v <= x4 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking range lo
           size :: PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
Checking Cons zero (range lo
                      size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (range
                           lo size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range lo size)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range lo
           lo :: PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U1 && [_0 -> zero, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> (_v <= size + lo && lo <= _v) && zero != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, 0 <= lo, _v <= lo + lo, lo <= 0, lo <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && zero != _v
assumption !(size <= 0) && (zero == 0 && (0 <= lo && (_v <= lo + lo && (lo <= 0 && (lo <= _v && size >= 0)))))
mustHave !((_v <= size + lo && lo <= _v) && zero != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo lo ::
PList {Int|(_v <= size + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range lo lo)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range lo ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range lo Nil)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range lo
           zero :: PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> U1 && [_0 -> zero, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> (_v <= size + lo && lo <= _v) && zero != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, 0 <= lo, _v <= zero + lo, lo <= 0, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && zero != _v
assumption !(size <= 0) && (zero == 0 && (0 <= lo && (_v <= zero + lo && (lo <= 0 && (zero <= _v && size >= 0)))))
mustHave !((_v <= size + lo && lo <= _v) && zero != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo zero ::
PList {Int|(_v <= size + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range lo zero)
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 <= lo, lo <= 0, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range size ??)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range Nil ??)
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {A1|P0 zero _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|U1 && P0 zero _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> zero, _1 -> _v]P0) && (x4 <= _v && _v <= x4 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range zero
           lo :: PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> U1 && [_0 -> zero, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> (_v <= size + lo && lo <= _v) && zero != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, 0 <= lo, _v <= lo + zero, lo <= 0, lo <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && zero != _v
assumption !(size <= 0) && (zero == 0 && (0 <= lo && (_v <= lo + zero && (lo <= 0 && (lo <= _v && size >= 0)))))
mustHave !((_v <= size + lo && lo <= _v) && zero != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero lo ::
PList {Int|(_v <= size + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range zero lo)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking range zero
           size :: PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero)))) ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
Checking Cons zero (range zero
                      size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons zero x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons zero x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons zero (range
                           zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range zero size)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range zero ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range zero Nil)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range zero
           zero :: PList {A1|P0 zero _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 zero _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 zero _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && [_0 -> zero, _1 -> _v]P0} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> U1 && [_0 -> zero, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> U1 && [_0 -> zero, _1 -> _v]P0
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> (_v <= size + lo && lo <= _v) && zero != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, 0 <= lo, _v <= zero + zero, lo <= 0, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && zero != _v
assumption !(size <= 0) && (zero == 0 && (0 <= lo && (_v <= zero + zero && (lo <= 0 && (zero <= _v && size >= 0)))))
mustHave !((_v <= size + lo && lo <= _v) && zero != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero zero ::
PList {Int|(_v <= size + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons zero (range zero zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: A1 ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons Nil ??
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1}
Trying range
Adding constraint lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ?? ??
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
lo, range, size |- C2
Type assignment
A0 -> {Int|U0}
Simple Constraints
lo, range, size |- C2
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|X0 <= _v && _v <= X0 + X1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == x1} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|_0 != _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|x2 <= _v && _v <= x2 + x1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|x2 <= _v && _v <= x2 + x1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|_0 != _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == x1} /\ {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|X0 <= _v && _v <= X0 + X1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, X1, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> _0 != _1
  False ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (len _v == size && (len _v == x1 && (size >= 0 && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
  C1 && (C2 && (_0 != _1 && size >= 0))
  C1 && (C2 && (size >= 0 && ((lo <= _v && _v <= lo + size) && ((x2 <= _v && _v <= x2 + x1) && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}] (4 0)
Remaining Candidates (0)
TYPE ERROR: Found inconsistent refinements
when checking range ::
X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else range ?? ??
Adding constraint lo, range, size |- A1
Adding constraint |- P0 :: A1 -> A1 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ?? ??
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
|- P0 :: A1 -> A1 -> Bool
lo, range, size |- A1
lo, range, size |- C2
UNIFY A1 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U1}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size |- C2
lo, range, size |- {Int|U1}
X0, X1, lo, range, size C1, C2 |- {PList|_v == (Cons X1 X0)} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {}, U0 -> {}, U1 -> {}] (2 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {}, U0 -> {}, U1 -> {}] (2 2)
Invalid Constraint: C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
Strengthening: C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: _0 != _1
assumption !(size <= 0) && size >= 0
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, _1 <= lo + _0, lo <= 0}
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P0 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {}] (3 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {}] (3 1)
Invalid Constraint: C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Strengthening: C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: lo <= _v && _v <= lo + size
assumption !(size <= 0) && size >= 0
mustHave !(lo <= _v && _v <= lo + size)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{0 <= lo, _v <= 0 + size, lo <= 0, size <= _v}
{_v <= size + lo, lo <= 0, size <= _v}
{0 <= _v, _v <= size + lo, lo <= 0}
{_v <= 0 + size, lo <= _v, size <= lo}
{0 <= lo, _v <= 0 + size, lo <= _v}
{_v <= 0 + size, lo <= size, size <= _v, size <= lo}
{0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{_v <= 0 + lo, lo <= size, size <= _v}
{0 <= _v, _v <= 0 + lo, lo <= 0}
{_v <= size + lo, lo <= _v}
{_v <= size + lo, lo <= size, size <= _v}
{_v <= 0 + lo, lo <= _v}
Pruned valuations:
{_v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U1 -> {_v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && ([_v -> x1]U1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x3:Int -> {Int|_v == x3 - 1}
Trying dec
Checking dec :: X2:_ -> A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (?? ??) ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> A1 ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> A1 ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> A1 ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X2, lo, range, size C1, C2 |- {Int|_v == X2 - 1} <: {Int|U1} ()
lo, range, size, x3 C1, C2 |- {Int|_v == x3 - 1} /\ {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|_v == x3 - 1} /\ {Int|U1} ()
X2, lo, range, size C1, C2 |- {Int|_v == X2 - 1} <: {Int|U1} ()
Constraints
  False ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (U1 && (_v == x3 - 1 && size >= 0)))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec ??) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument lo of type {Int|_v == lo}
Checking dec lo :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo - 1} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == lo - 1 && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == lo - 1 && size >= 0)) ==> U1
Strengthening: C1 && (C2 && (_v == lo - 1 && size >= 0)) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo - 1, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == lo - 1 && size >= 0)
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking dec lo ::
{Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec lo) ??
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec ??) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument size of type {Int|_v == size}
Checking dec size :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size - 1} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == size - 1 && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == size - 1 && size >= 0)) ==> U1
Strengthening: C1 && (C2 && (_v == size - 1 && size >= 0)) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size - 1, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == size - 1 && size >= 0)
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument dec
                       size of type {Int|_v == size - 1}
Checking Cons (dec
                 size) :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X0, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 X0)} <: {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (x1 == size - 1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
Checking lo :: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking lo ::
x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) lo
Trying size
Checking size :: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking size ::
x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) size
Trying zero
Checking zero :: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking zero ::
x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
lo, range, size, x1 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument Nil of type {PList {A2|False} <False>|_v == (Nil)}
Checking Cons (dec size)
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 (Nil))} <: {PList|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], size != lo, 0 <= lo, lo <= size, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && (size != lo && (0 <= lo && (lo <= size && size >= 0))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) Nil
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x4:Int -> {Int|_v == x4 + 1}
Trying inc
Checking inc :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking inc ::
X3:_ -> x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (inc ??)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x4:Int -> {Int|_v == x4 - 1}
Trying dec
Checking dec :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking dec ::
X3:_ -> x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (dec ??)
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)}
Trying Cons
Checking Cons :: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
X3, X4, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons X4 X3)} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|_v == (Cons x4 x5)} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == size - 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 2)
Invalid Constraint: C1 && (C2 && (P1 && size >= 0)) ==> P0
Strengthening: C1 && (C2 && (P1 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), size != lo, 0 <= lo, lo <= size, size >= 0
RHS: _0 != _1
assumption !(size <= 0) && (size != lo && (0 <= lo && (lo <= size && size >= 0)))
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P1 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (U2 && (x1 == size - 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (U2 && (x1 == size - 1 && size >= 0))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == size - 1, size != lo, 0 <= lo, lo <= size, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == size - 1 && (size != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,0 <= _v
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{_v <= size + lo, size <= _v}
{_v <= 0 + size, size <= _v}
Pruned valuations:
{_v <= size + lo, size <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U2 -> {_v <= size + lo, size <= _v}]
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == size - 1 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}] (8 0)
Trying lo
Checking lo :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v <= size + lo && size <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v <= size + lo && size <= _v
assumption !(size <= 0) && (_v == lo && (size != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(_v <= size + lo && size <= _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking lo ::
{Int|_v <= size + lo && size <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons lo
                              ??)
Trying size
Checking size :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking Cons
           size :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons size x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == size - 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == size - 1 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}] (9 0)
Trying lo
Checking lo :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons size
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(_v <= size + lo && size <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons size
                              lo)
Trying size
Checking size :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons size
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(_v <= size + lo && size <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons size
                              size)
Trying zero
Checking zero :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons size
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(_v <= size + lo && size <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons size
                              zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons size
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 size _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}, U3 -> {}] (9 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons size
           Nil :: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == size - 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}, U3 -> {}] (9 0)
Synthesized argument Cons size
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}
Checking Cons (dec size) (Cons
                            size
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (Cons size Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons size
                              Nil)
Trying zero
Checking zero :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= size + lo, size <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v <= size + lo && size <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, size != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v <= size + lo && size <= _v
assumption !(size <= 0) && (_v == zero && (zero == 0 && (size != lo && (0 <= lo && (lo <= size && size >= 0)))))
mustHave !(_v <= size + lo && size <= _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking zero ::
{Int|_v <= size + lo && size <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons zero
                              ??)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v <= size + lo && size <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (Cons Nil
                              ??)
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4}
Trying range
Adding constraint lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X3, X4, lo, range, size, x1 C1, C2 |- {PList|len _v == X4} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|len _v == x4} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == size - 1 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && ((x5 <= _v && _v <= x5 + x4) && (x4 >= 0 && (x4 >= 0 && x4 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == size - 1 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && (x5 <= _v && _v <= x5 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range lo
           lo :: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size - 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == size - 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == size - 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == size - 1, size != lo, 0 <= lo, _v <= lo + lo, lo <= _v, lo <= size, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == size - 1 && (size != lo && (0 <= lo && (_v <= lo + lo && (lo <= _v && (lo <= size && size >= 0))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo lo ::
x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range lo
                              lo)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking range lo
           size :: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size - 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range lo
                       size of type {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}
Checking Cons (dec size) (range
                            lo
                            size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (range lo size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range lo
                              size)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range lo
           zero :: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == size - 1, zero == 0, size != lo, 0 <= lo, _v <= zero + lo, lo <= size, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == size - 1 && (zero == 0 && (size != lo && (0 <= lo && (_v <= zero + lo && (lo <= size && (zero <= _v && size >= 0)))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo zero ::
x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range lo
                              zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range lo
                              Nil)
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (size != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range size
                              ??)
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && (x5 <= _v && _v <= x5 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range zero
           lo :: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == size - 1, zero == 0, size != lo, 0 <= lo, _v <= lo + zero, lo <= _v, lo <= size, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == size - 1 && (zero == 0 && (size != lo && (0 <= lo && (_v <= lo + zero && (lo <= _v && (lo <= size && size >= 0)))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero lo ::
x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range zero
                              lo)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking range zero
           size :: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
Checking Cons (dec size) (range
                            zero
                            size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size - 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (dec size)
                (range zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range zero
                              size)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range zero
                              Nil)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range zero
           zero :: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size - 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == size - 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == size - 1, zero == 0, size != lo, 0 <= lo, _v <= zero + zero, lo <= size, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == size - 1 && (zero == 0 && (size != lo && (0 <= lo && (_v <= zero + zero && (lo <= size && (zero <= _v && size >= 0)))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero zero ::
x1:{Int|_v == size - 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range zero
                              zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec size) (range Nil
                              ??)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec ??) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument zero of type {Int|_v == zero}
Checking dec zero :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero - 1} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == zero - 1 && (zero == 0 && size >= 0))) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == zero - 1 && (zero == 0 && size >= 0))) ==> U1
Strengthening: C1 && (C2 && (_v == zero - 1 && (zero == 0 && size >= 0))) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero - 1, zero == 0, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == zero - 1 && (zero == 0 && size >= 0))
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking dec zero ::
{Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec zero) ??
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec ??) ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (dec Nil) ??
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x3:Int -> {Int|_v == x3 + 1}
Trying inc
Checking inc :: X2:_ -> A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (?? ??) ??
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> A1 ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> A1 ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> A1 ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X2, lo, range, size C1, C2 |- {Int|_v == X2 + 1} <: {Int|U1} ()
lo, range, size, x3 C1, C2 |- {Int|_v == x3 + 1} /\ {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|_v == x3 + 1} /\ {Int|U1} ()
X2, lo, range, size C1, C2 |- {Int|_v == X2 + 1} <: {Int|U1} ()
Constraints
  False ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (U1 && (_v == x3 + 1 && size >= 0)))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc ??) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument lo of type {Int|_v == lo}
Checking inc lo :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo + 1} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == lo + 1 && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument inc
                       lo of type {Int|_v == lo + 1}
Checking Cons (inc
                 lo) :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X0, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 X0)} <: {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (x1 == lo + 1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying size
Checking size :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking size ::
x1:{Int|_v == lo + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) size
Trying lo
Checking lo :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking lo ::
x1:{Int|_v == lo + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) lo
Trying zero
Checking zero :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking zero ::
x1:{Int|_v == lo + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
lo, range, size, x1 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument Nil of type {PList {A2|False} <False>|_v == (Nil)}
Checking Cons (inc lo)
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 (Nil))} <: {PList|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && size >= 0)))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo) Nil
::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) Nil
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x4:Int -> {Int|_v == x4 - 1}
Trying dec
Checking dec :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking dec ::
X3:_ -> x1:{Int|_v == lo + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (dec ??)
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x4:Int -> {Int|_v == x4 + 1}
Trying inc
Checking inc :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking inc ::
X3:_ -> x1:{Int|_v == lo + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (inc ??)
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)}
Trying Cons
Checking Cons :: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
X3, X4, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons X4 X3)} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|_v == (Cons x4 x5)} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == lo + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 2)
Invalid Constraint: C1 && (C2 && (P1 && size >= 0)) ==> P0
Strengthening: C1 && (C2 && (P1 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: _0 != _1
assumption !(size <= 0) && size >= 0
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, _1 <= lo + _0, lo <= 0}
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P1 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (U2 && (x1 == lo + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (U2 && (x1 == lo + 1 && size >= 0))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == lo + 1, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == lo + 1 && size >= 0)
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{_v <= 0 + size, lo <= size, size <= _v, size <= lo}
{_v <= 0 + size, lo <= _v, size <= lo}
{_v <= 0 + lo, lo <= size, size <= _v}
{size != _v, size != lo, _v <= size + lo, lo <= size, size <= _v}
{0 != _v, 0 != lo, 0 <= _v, _v <= size + lo, lo <= 0}
{0 <= _v, _v <= 0 + lo, lo <= 0}
{_v <= 0 + lo, lo <= _v}
Pruned valuations:
{_v <= 0 + lo, lo <= _v}
{size != _v, size != lo, _v <= size + lo, lo <= size, size <= _v}
{0 != _v, 0 != lo, 0 <= _v, _v <= size + lo, lo <= 0}
Diffs: (3)
[C1 -> {}, C2 -> {}, U2 -> {_v <= 0 + lo, lo <= _v}]
[C1 -> {}, C2 -> {size != lo, lo <= size}, U2 -> {size != _v, _v <= size + lo, size <= _v}]
[C1 -> {}, C2 -> {0 != lo, lo <= 0}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}]
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == lo + 1 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0)))))
Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 0)
Remaining Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 0)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 0)
Trying size
Checking size :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 1)
Chosen candidate: 0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> 0 != _v && (0 <= _v && _v <= size + lo)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 != lo, lo <= 0, size >= 0
RHS: 0 != _v && (0 <= _v && _v <= size + lo)
assumption !(size <= 0) && (_v == size && (0 != lo && (lo <= 0 && size >= 0)))
mustHave !(0 != _v && (0 <= _v && _v <= size + lo))
qualsList [0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 1)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> size != _v && (_v <= size + lo && size <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size != lo, lo <= size, size >= 0
RHS: size != _v && (_v <= size + lo && size <= _v)
assumption !(size <= 0) && (_v == size && (size != lo && (lo <= size && size >= 0)))
mustHave !(size != _v && (_v <= size + lo && size <= _v))
qualsList [0 != lo
          ,0 != size
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v <= 0 + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v <= 0 + lo && lo <= _v
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v <= 0 + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{lo <= size, size <= lo}
Pruned valuations:
{lo <= size, size <= lo}
Diffs: (1)
[C1 -> {}, C2 -> {lo <= size, size <= lo}]
Checking consistency
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking Cons
           size :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons size x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == lo + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == lo + 1 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0)))))
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Trying lo
Checking lo :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons size
                            ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(_v <= 0 + lo && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons size
                            lo)
Trying size
Checking size :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons size
                            ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(_v <= 0 + lo && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons size
                            size)
Trying zero
Checking zero :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons size
                            ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(_v <= 0 + lo && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons size
                            zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons size
                            ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 size _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons size
           Nil :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == lo + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Cons size
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}
Checking Cons (inc lo) (Cons
                          size
                          Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], lo <= size, size <= lo, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (lo <= size && (size <= lo && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (Cons size Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons size
                            Nil)
Trying lo
Checking lo :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 1)
Remaining Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 1)
Synthesized argument lo of type {Int|_v == lo}
Checking Cons
           lo :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons lo x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == lo + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == lo + 1 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0)))))
Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 1)
Remaining Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 1)
Trying size
Checking size :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(_v <= 0 + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons lo
                            size)
Trying lo
Checking lo :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(_v <= 0 + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons lo lo)
Trying zero
Checking zero :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(_v <= 0 + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons lo
                            zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons lo ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 lo _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}, U3 -> {}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
Remaining Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}, U3 -> {}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons lo
           Nil :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == lo + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}, U3 -> {}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
Remaining Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}, U3 -> {}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 1)
Synthesized argument Cons lo
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}
Checking Cons (inc lo) (Cons lo
                          Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}, U3 -> {}] (8 2)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 2)
Chosen candidate: 0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}, U3 -> {}] (8 2)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> 0 != _v && (0 <= _v && _v <= size + lo)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 != lo, lo <= 0, size >= 0
RHS: 0 != _v && (0 <= _v && _v <= size + lo)
assumption !(size <= 0) && (_v == lo && (0 != lo && (lo <= 0 && size >= 0)))
mustHave !(0 != _v && (0 <= _v && _v <= size + lo))
qualsList [0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}, U3 -> {}] (8 2)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}, U3 -> {}] (8 2)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> size != _v && (_v <= size + lo && size <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size != lo, lo <= size, size >= 0
RHS: size != _v && (_v <= size + lo && size <= _v)
assumption !(size <= 0) && (_v == lo && (size != lo && (lo <= size && size >= 0)))
mustHave !(size != _v && (_v <= size + lo && size <= _v))
qualsList [0 != lo
          ,0 != size
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (Cons lo Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons lo Nil)
Trying zero
Checking zero :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (3)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 1)
  0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 1)
Chosen candidate: 0.2: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 != _v, 0 <= _v, _v <= size + lo}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> 0 != _v && (0 <= _v && _v <= size + lo)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 != lo, lo <= 0, size >= 0
RHS: 0 != _v && (0 <= _v && _v <= size + lo)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 != lo && (lo <= 0 && size >= 0))))
mustHave !(0 != _v && (0 <= _v && _v <= size + lo))
qualsList [0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 1)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {size != _v, _v <= size + lo, size <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> size != _v && (_v <= size + lo && size <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, size != lo, lo <= size, size >= 0
RHS: size != _v && (_v <= size + lo && size <= _v)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (size != lo && (lo <= size && size >= 0))))
mustHave !(size != _v && (_v <= size + lo && size <= _v))
qualsList [0 != lo
          ,0 != size
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v <= 0 + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, size >= 0
RHS: _v <= 0 + lo && lo <= _v
assumption !(size <= 0) && (_v == zero && (zero == 0 && size >= 0))
mustHave !(_v <= 0 + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
Pruned valuations:
{0 <= lo, lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= 0}]
Checking consistency
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking Cons
           zero :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons zero x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == lo + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == lo + 1 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0)))))
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Trying size
Checking size :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons zero
                            ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(_v <= 0 + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons zero
                            size)
Trying lo
Checking lo :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons zero
                            ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(_v <= 0 + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons zero
                            lo)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons zero
                            ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 zero _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 zero _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons zero
           Nil :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == lo + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Cons zero
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))}
Checking Cons (inc lo) (Cons
                          zero
                          Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (Cons zero Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons zero
                            Nil)
Trying zero
Checking zero :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons zero
                            ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(_v <= 0 + lo && lo <= _v) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons zero
                            zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v <= 0 + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (Cons Nil ??)
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4}
Trying range
Adding constraint lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X3, X4, lo, range, size, x1 C1, C2 |- {PList|len _v == X4} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|len _v == x4} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == lo + 1 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && ((x5 <= _v && _v <= x5 + x4) && (x4 >= 0 && (x4 >= 0 && x4 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range size
                            ??)
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == lo + 1 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && (x5 <= _v && _v <= x5 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking range lo
           size :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == lo + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == lo + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == lo + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == lo + 1, size != lo, 0 <= lo, _v <= size + lo, lo <= size, size <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == lo + 1 && (size != lo && (0 <= lo && (_v <= size + lo && (lo <= size && (size <= _v && size >= 0))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo size ::
x1:{Int|_v == lo + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range lo
                            size)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range lo
           lo :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == lo + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == lo + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == lo + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == lo + 1, size != lo, 0 <= lo, _v <= lo + lo, lo <= _v, lo <= size, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == lo + 1 && (size != lo && (0 <= lo && (_v <= lo + lo && (lo <= _v && (lo <= size && size >= 0))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{lo <= 0}
Pruned valuations:
{lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
Checking Cons (inc lo) (range lo
                          lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= 0, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= 0 && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (range lo lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range lo lo)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range lo
           zero :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == lo + 1, zero == 0, size != lo, 0 <= lo, _v <= zero + lo, lo <= size, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == lo + 1 && (zero == 0 && (size != lo && (0 <= lo && (_v <= zero + lo && (lo <= size && (zero <= _v && size >= 0)))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{lo <= 0}
Pruned valuations:
{lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
Checking Cons (inc lo) (range lo
                          zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= 0, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= 0 && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (range lo zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range lo
                            zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range lo ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range lo
                            Nil)
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && (x5 <= _v && _v <= x5 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range zero
                            ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking range zero
           size :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == lo + 1, zero == 0, _v <= size + zero, size <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == lo + 1 && (zero == 0 && (_v <= size + zero && (size <= _v && size >= 0))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{lo <= size, size <= lo}
Pruned valuations:
{lo <= size, size <= lo}
Diffs: (1)
[C1 -> {}, C2 -> {lo <= size, size <= lo}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
Checking Cons (inc lo) (range
                          zero
                          size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {lo <= size, size <= lo}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, lo <= size, size <= lo, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (lo <= size && (size <= lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (range zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range zero
                            size)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range zero
                            ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range zero
           lo :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
Checking Cons (inc lo) (range
                          zero
                          lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (range zero lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range zero
                            lo)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range zero
                            ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range zero
                            Nil)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range zero
                            ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range zero
           zero :: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == lo + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == lo + 1, zero == 0, _v <= zero + zero, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == lo + 1 && (zero == 0 && (_v <= zero + zero && (zero <= _v && size >= 0))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
Pruned valuations:
{0 <= lo, lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
Checking Cons (inc lo) (range
                          zero
                          zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == lo + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc lo)
                (range zero zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range zero
                            zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc lo) (range Nil
                            ??)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc ??) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument size of type {Int|_v == size}
Checking inc size :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size + 1} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == size + 1 && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == size + 1 && size >= 0)) ==> U1
Strengthening: C1 && (C2 && (_v == size + 1 && size >= 0)) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size + 1, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == size + 1 && size >= 0)
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, 0 <= lo, lo <= size}
{lo <= size, size <= lo}
Pruned valuations:
{0 != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {0 != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument inc
                       size of type {Int|_v == size + 1}
Checking Cons (inc
                 size) :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X0, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 X0)} <: {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (x1 == size + 1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
Checking lo :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking lo ::
x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) lo
Trying size
Checking size :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking size ::
x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) size
Trying zero
Checking zero :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking zero ::
x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) zero
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
lo, range, size, x1 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument Nil of type {PList {A2|False} <False>|_v == (Nil)}
Checking Cons (inc size)
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 (Nil))} <: {PList|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) Nil
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x4:Int -> {Int|_v == x4 - 1}
Trying dec
Checking dec :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking dec ::
X3:_ -> x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (dec ??)
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x4:Int -> {Int|_v == x4 + 1}
Trying inc
Checking inc :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking inc ::
X3:_ -> x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (inc ??)
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)}
Trying Cons
Checking Cons :: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
X3, X4, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons X4 X3)} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|_v == (Cons x4 x5)} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == size + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 2)
Invalid Constraint: C1 && (C2 && (P1 && size >= 0)) ==> P0
Strengthening: C1 && (C2 && (P1 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: _0 != _1
assumption !(size <= 0) && (0 != lo && (0 <= lo && (lo <= size && size >= 0)))
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P1 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (U2 && (x1 == size + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (U2 && (x1 == size + 1 && size >= 0))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == size + 1, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == size + 1 && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != _v
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{_v <= 0 + lo, lo <= _v}
{_v <= 0 + lo, size <= _v}
{_v <= 0 + size, size <= _v}
{_v <= 0 + size, lo <= _v}
Pruned valuations:
{_v <= 0 + size, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U2 -> {_v <= 0 + size, lo <= _v}]
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == size + 1 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (8 0)
Trying lo
Checking lo :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking Cons
           lo :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons lo x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == size + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == size + 1 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (9 0)
Trying lo
Checking lo :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(_v <= 0 + size && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons lo
                              lo)
Trying size
Checking size :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(_v <= 0 + size && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons lo
                              size)
Trying zero
Checking zero :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(_v <= 0 + size && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons lo
                              zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 lo _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons lo
           Nil :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == size + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Cons lo
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}
Checking Cons (inc size) (Cons
                            lo
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (Cons lo Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons lo
                              Nil)
Trying size
Checking size :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking Cons
           size :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x5)} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons size x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == size + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == size + 1 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (9 0)
Trying lo
Checking lo :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons size
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(_v <= 0 + size && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons size
                              lo)
Trying size
Checking size :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons size
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(_v <= 0 + size && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons size
                              size)
Trying zero
Checking zero :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons size
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(_v <= 0 + size && lo <= _v) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons size
                              zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons size
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 size _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons size
           Nil :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == size + 1 && size >= 0))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Cons size
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}
Checking Cons (inc size) (Cons
                            size
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons size (Nil))}) IN LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems (Nil) == [], 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems (Nil) == [] && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (Cons size Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons size
                              Nil)
Trying zero
Checking zero :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + size, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v <= 0 + size && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v <= 0 + size && lo <= _v
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 != lo && (0 <= lo && (lo <= size && size >= 0)))))
mustHave !(_v <= 0 + size && lo <= _v)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking zero ::
{Int|_v <= 0 + size && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons zero
                              ??)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v <= 0 + size && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (Cons Nil
                              ??)
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4}
Trying range
Adding constraint lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X3, X4, lo, range, size, x1 C1, C2 |- {PList|len _v == X4} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|len _v == x4} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == size + 1 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && ((x5 <= _v && _v <= x5 + x4) && (x4 >= 0 && (x4 >= 0 && x4 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{size != lo}
Pruned valuations:
{size != lo}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == size + 1 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && (x5 <= _v && _v <= x5 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range lo
           lo :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == size + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == size + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == size + 1, 0 != lo, size != lo, 0 <= lo, _v <= lo + lo, lo <= _v, lo <= size, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == size + 1 && (0 != lo && (size != lo && (0 <= lo && (_v <= lo + lo && (lo <= _v && (lo <= size && size >= 0)))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo lo ::
x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range lo
                              lo)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking range lo
           size :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == size + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == size + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == size + 1, 0 != lo, size != lo, 0 <= lo, _v <= size + lo, lo <= size, size <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == size + 1 && (0 != lo && (size != lo && (0 <= lo && (_v <= size + lo && (lo <= size && (size <= _v && size >= 0)))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo size ::
x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range lo
                              size)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range lo
           zero :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == size + 1, zero == 0, 0 != lo, size != lo, 0 <= lo, _v <= zero + lo, lo <= size, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == size + 1 && (zero == 0 && (0 != lo && (size != lo && (0 <= lo && (_v <= zero + lo && (lo <= size && (zero <= _v && size >= 0))))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo zero ::
x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range lo
                              zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range lo
                              Nil)
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range size
                              ??)
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == size + 1 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && (x5 <= _v && _v <= x5 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range zero
           lo :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
Checking Cons (inc size) (range
                            zero
                            lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (range zero lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range zero
                              lo)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking range zero
           size :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
Checking Cons (inc size) (range
                            zero
                            size) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == size + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> size <= _x && _x <= size + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc size)
                (range zero size) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range zero
                              size)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range zero
                              Nil)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range zero
           zero :: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == size + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == size + 1, zero == 0, 0 != lo, 0 <= lo, _v <= zero + zero, lo <= size, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == size + 1 && (zero == 0 && (0 != lo && (0 <= lo && (_v <= zero + zero && (lo <= size && (zero <= _v && size >= 0)))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero zero ::
x1:{Int|_v == size + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range zero
                              zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc size) (range Nil
                              ??)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc ??) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument zero of type {Int|_v == zero}
Checking inc zero :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero + 1} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == zero + 1 && (zero == 0 && size >= 0))) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 1)
Invalid Constraint: C1 && (C2 && (_v == zero + 1 && (zero == 0 && size >= 0))) ==> U1
Strengthening: C1 && (C2 && (_v == zero + 1 && (zero == 0 && size >= 0))) ==> _v <= size + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero + 1, zero == 0, size >= 0
RHS: _v <= size + lo && lo <= _v
assumption !(size <= 0) && (_v == zero + 1 && (zero == 0 && size >= 0))
mustHave !(_v <= size + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
Pruned valuations:
{0 <= lo, lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Synthesized argument inc
                       zero of type {Int|_v == zero + 1}
Checking Cons (inc
                 zero) :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> -> LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X0, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 X0)} <: {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, lo, range, size, x1 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0))))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (6 0)
Trying lo
Checking lo :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking lo ::
x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) lo
Trying size
Checking size :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking size ::
x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) size
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
lo, range, size, x1 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|False} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 0)
Synthesized argument Nil of type {PList {A2|False} <False>|_v == (Nil)}
Checking Cons (inc zero)
           Nil :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 (Nil))} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons x1 (Nil))} <: {PList|len _v == size} ()
lo, range, size, x1 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1 C1, C2 |- {PList|len _v == 1 + len (Nil)} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len (Nil) && size >= 0)) ==> len _v == size
Instantiated axioms:
len (Nil) == 0, elems (Nil) == []
All assumptions:
!(size <= 0), len _v == 1 + len (Nil), len (Nil) == 0, elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len (Nil) && (len (Nil) == 0 && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && size >= 0)))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                Nil ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) Nil
Trying zero
Checking zero :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking zero ::
x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) zero
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x4:Int -> {Int|_v == x4 - 1}
Trying dec
Checking dec :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 - 1} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking dec ::
X3:_ -> x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (dec ??)
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x4:Int -> {Int|_v == x4 + 1}
Trying inc
Checking inc :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {Int|_v == x4 + 1} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking inc ::
X3:_ -> x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (inc ??)
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)}
Trying Cons
Checking Cons :: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:A2 -> x5:PList {A2|P1 x4 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x4 x5)} <: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 x1 _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
X3, X4, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons X4 X3)} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|_v == (Cons x4 x5)} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x4, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == zero + 1 && (zero == 0 && size >= 0)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 2)
Invalid Constraint: C1 && (C2 && (P1 && size >= 0)) ==> P0
Strengthening: C1 && (C2 && (P1 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), 0 <= lo, lo <= 0, size >= 0
RHS: _0 != _1
assumption !(size <= 0) && (0 <= lo && (lo <= 0 && size >= 0))
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P1 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C1 && (C2 && (U2 && (x1 == zero + 1 && (zero == 0 && size >= 0)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (U2 && (x1 == zero + 1 && (zero == 0 && size >= 0)))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == zero + 1, zero == 0, 0 <= lo, lo <= 0, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == zero + 1 && (zero == 0 && (0 <= lo && (lo <= 0 && size >= 0))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{_v <= 0 + lo, lo <= _v}
{0 <= _v, _v <= 0 + lo}
Pruned valuations:
{0 <= _v, _v <= 0 + lo}
{_v <= 0 + lo, lo <= _v}
Diffs: (2)
[C1 -> {}, C2 -> {}, U2 -> {0 <= _v, _v <= 0 + lo}]
[C1 -> {}, C2 -> {}, U2 -> {_v <= 0 + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0))))))
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 0)
Remaining Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (8 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 0)
Trying lo
Checking lo :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Remaining Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking Cons
           lo :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {A2|P1 lo _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons lo x5)} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons lo x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == zero + 1 && (zero == 0 && size >= 0)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0))))))
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Remaining Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Trying size
Checking size :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(0 <= _v && _v <= 0 + lo) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons lo
                              size)
Trying lo
Checking lo :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(0 <= _v && _v <= 0 + lo) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons lo
                              lo)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 lo _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons lo
           Nil :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons lo (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == zero + 1 && (zero == 0 && size >= 0)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Cons lo
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}
Checking Cons (inc zero) (Cons
                            lo
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons lo (Nil))}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Strengthening: C1 && (C2 && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))) ==> len _v == size
Instantiated axioms:
len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x2 == (Cons lo (Nil)), len _v == 1 + len x2, len ((Cons lo (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons lo (Nil))) == [lo] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x2 == (Cons lo (Nil)) && (len _v == 1 + len x2 && (len ((Cons lo (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons lo (Nil))) == [lo] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (Cons lo Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons lo
                              Nil)
Trying zero
Checking zero :: PList {A2|P1 lo _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 lo _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(0 <= _v && _v <= 0 + lo) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons lo
                              zero)
Trying size
Checking size :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (8 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 1)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v <= 0 + lo && lo <= _v
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 <= lo, lo <= 0, size >= 0
RHS: _v <= 0 + lo && lo <= _v
assumption !(size <= 0) && (_v == size && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(_v <= 0 + lo && lo <= _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (8 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> 0 <= _v && _v <= 0 + lo
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 <= lo, lo <= 0, size >= 0
RHS: 0 <= _v && _v <= 0 + lo
assumption !(size <= 0) && (_v == size && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(0 <= _v && _v <= 0 + lo)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|0 <= _v && _v <= 0 + lo} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons size
                              ??)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|0 <= _v && _v <= 0 + lo} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons Nil
                              ??)
Trying zero
Checking zero :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Remaining Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking Cons
           zero :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x5)} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:PList {A2|P1 zero _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons zero x5)} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero X3)} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|_v == (Cons zero x5)} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == zero + 1 && (zero == 0 && size >= 0)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (U1 && [_0 -> x1, _1 -> _v]P0))))))
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Remaining Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}] (9 0)
Trying lo
Checking lo :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
PList {Int|(0 <= _v && _v <= 0 + lo) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons zero
                              lo)
Trying size
Checking size :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
PList {Int|(0 <= _v && _v <= 0 + lo) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons zero
                              size)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 zero _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U2 && P1 zero _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons zero
           Nil :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|_v == (Cons zero (Nil))} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && (x1 == zero + 1 && (zero == 0 && size >= 0)))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Cons zero
                       Nil of type {PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))}
Checking Cons (inc zero) (Cons
                            zero
                            Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList A2 <P1 _0 _1>|_v == (Cons zero (Nil))}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {_v <= 0 + lo, lo <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {0 <= _v, _v <= 0 + lo}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), zero == 0, x2 == (Cons zero (Nil)), len _v == 1 + len x2, len ((Cons zero (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons zero (Nil))) == [zero] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (x2 == (Cons zero (Nil)) && (len _v == 1 + len x2 && (len ((Cons zero (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons zero (Nil))) == [zero] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (Cons zero Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons zero
                              Nil)
Trying zero
Checking zero :: PList {A2|P1 zero _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A2|P1 zero _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
PList {Int|(0 <= _v && _v <= 0 + lo) && zero != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (Cons zero
                              zero)
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4}
Trying range
Adding constraint lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} /\ X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + x4} <_0 != _1>|len _v == x4} <: X4:_ -> X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> x5:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X3, X4, lo, range, size, x1 C1, C2 |- {PList|len _v == X4} <: PList ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x4, x5 C1, C2 |- {PList|len _v == x4} /\ PList ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x4, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + x4} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x4, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + X4} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, X4, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && ((x5 <= _v && _v <= x5 + x4) && (x4 >= 0 && (x4 >= 0 && x4 < size))))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + lo} <_0 != _1>|len _v == lo} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + lo} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && (x5 <= _v && _v <= x5 + lo))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking range lo
           size :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + lo))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + lo))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + lo))))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == zero + 1, zero == 0, 0 <= lo, _v <= size + lo, lo <= 0, size <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == zero + 1 && (zero == 0 && (0 <= lo && (_v <= size + lo && (lo <= 0 && (size <= _v && size >= 0))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo size ::
x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range lo
                              size)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range lo
           lo :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + lo))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range lo
                       lo of type {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}
Checking Cons (inc zero) (range
                            lo
                            lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Strengthening: C1 && (C2 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), len _v == 1 + len x2, len x2 == lo, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo
RHS: len _v == size
assumption !(size <= 0) && (len _v == 1 + len x2 && (len x2 == lo && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + lo)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (range lo lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range lo
                              lo)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range lo
                              Nil)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range lo
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range lo
           zero :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range lo
                       zero of type {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}
Checking Cons (inc zero) (range
                            lo
                            zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == lo, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + lo))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (range lo zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range lo
                              zero)
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 <= lo, lo <= 0, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range size
                              ??)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range Nil
                              ??)
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range ??
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (?? ??)
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} /\ X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {PList {Int|x5 <= _v && _v <= x5 + zero} <_0 != _1>|len _v == zero} <: X3:_ -> LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X3, lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && P0 x1 _v} ()
lo, range, size, x1, x5 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1, x5 C1, C2 |- {Int|x5 <= _v && _v <= x5 + zero} /\ {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1, x5 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|X3 <= _v && _v <= X3 + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
X3, lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> x1, _1 -> _v]P0) && (x5 <= _v && _v <= x5 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range zero
           lo :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range zero
                       lo of type {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}
Checking Cons (inc zero) (range
                            zero
                            lo) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> lo <= _x && _x <= lo + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (range zero lo) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range zero
                              lo)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking range zero
           size :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
Strengthening: C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> (_v <= size + lo && lo <= _v) && x1 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x1 == zero + 1, zero == 0, 0 <= lo, _v <= size + zero, lo <= 0, size <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && x1 != _v
assumption !(size <= 0) && (x1 == zero + 1 && (zero == 0 && (0 <= lo && (_v <= size + zero && (lo <= 0 && (size <= _v && size >= 0))))))
mustHave !((_v <= size + lo && lo <= _v) && x1 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero size ::
x1:{Int|_v == zero + 1} -> PList {Int|(_v <= size + lo && lo <= _v) && x1 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range zero
                              size)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range zero
                              Nil)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range zero
                              ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range zero
           zero :: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) ??
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x1:({Int|_v == zero + 1}) IN PList {A1|P0 x1 _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && P0 x1 _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x1 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U1 && [_0 -> x1, _1 -> _v]P0} ()
lo, range, size, x1 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x1 == zero + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U1 && [_0 -> x1, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range zero
                       zero of type {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}
Checking Cons (inc zero) (range
                            zero
                            zero) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:({PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero}) IN LET x1:({Int|_v == zero + 1}) IN {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} <: {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Strengthening: C1 && (C2 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero
RHS: len _v == size
assumption !(size <= 0) && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> zero <= _x && _x <= zero + zero))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (inc zero)
                (range zero zero) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc zero) (range zero
                              zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc ??) ??
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (inc Nil) ??
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (?? ?? ??) ??
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A1 ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> A1 ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> A1 ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Cons ::
X3:_ -> X2:_ -> {Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (Cons ?? ??) ??
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X3:_ -> X2:_ -> A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (?? ?? ??) ??
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> A1 ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> A1 ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> A1 ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> A1 ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
TYPE ERROR: Cannot match shape 'PList (Int) <()>'
with shape 'Int'
when checking range ::
X3:_ -> X2:_ -> {Int|_v <= size + lo && lo <= _v}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons (range ?? ??) ??
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1}
Trying range
Adding constraint lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ?? ??
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x2:Int -> {PList {Int|x2 <= _v && _v <= x2 + x1} <_0 != _1>|len _v == x1} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> x2:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
lo, range, size |- C2
Type assignment
A0 -> {Int|U0}
Simple Constraints
lo, range, size |- C2
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|X0 <= _v && _v <= X0 + X1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == x1} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|_0 != _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|x2 <= _v && _v <= x2 + x1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|x2 <= _v && _v <= x2 + x1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|_0 != _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|len _v == x1} /\ {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|X0 <= _v && _v <= X0 + X1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, X1, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == X1} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> _0 != _1
  False ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (len _v == size && (len _v == x1 && (size >= 0 && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
  C1 && (C2 && (_0 != _1 && size >= 0))
  C1 && (C2 && (size >= 0 && ((lo <= _v && _v <= lo + size) && ((x2 <= _v && _v <= x2 + x1) && (x1 >= 0 && (x1 >= 0 && x1 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, U0 -> {}] (4 0)
Remaining Candidates (0)
TYPE ERROR: Found inconsistent refinements
when checking range ::
X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else range ?? ??
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x1:Int -> {Int|_v == x1 - 1}
Trying dec
Checking dec :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 - 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking dec ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else dec ??
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x1:Int -> {Int|_v == x1 + 1}
Trying inc
Checking inc :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:Int -> {Int|_v == x1 + 1} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size |- C2
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (Int) <()>'
when checking inc ::
X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else inc ??
Adding constraint lo, range, size |- A1
Adding constraint |- P0 :: A1 -> A1 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ?? ??
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} /\ X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x1:A1 -> x2:PList {A1|P0 x1 _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons x1 x2)} <: X1:_ -> X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
|- P0 :: A1 -> A1 -> Bool
lo, range, size |- A1
lo, range, size |- C2
UNIFY A1 WITH {Int|lo <= _v && _v <= lo + size} PRODUCING {Int|U1}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Typing Constraints
|- P0 :: A1 -> A1 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size |- C2
lo, range, size |- {Int|U1}
X0, X1, lo, range, size C1, C2 |- {PList|_v == (Cons X1 X0)} <: {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x1, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x1, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x1, x2 C1, C2 |- {PList|_v == (Cons x1 x2)} /\ {PList|len _v == size} ()
X0, X1, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, X1, lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, X1, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {}, U0 -> {}, U1 -> {}] (2 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {}, U0 -> {}, U1 -> {}] (2 2)
Invalid Constraint: C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
Strengthening: C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: _0 != _1
assumption !(size <= 0) && size >= 0
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, _1 <= lo + _0, lo <= 0}
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P0 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {}] (3 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {}] (3 1)
Invalid Constraint: C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Strengthening: C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: lo <= _v && _v <= lo + size
assumption !(size <= 0) && size >= 0
mustHave !(lo <= _v && _v <= lo + size)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{_v <= size + lo, lo <= 0, size <= _v}
{0 <= lo, _v <= 0 + size, lo <= 0, size <= _v}
{0 <= lo, _v <= 0 + size, lo <= _v}
{0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{0 <= _v, _v <= 0 + lo, lo <= 0}
{0 <= _v, _v <= size + lo, lo <= 0}
{_v <= 0 + lo, lo <= _v}
{_v <= 0 + size, lo <= size, size <= _v, size <= lo}
{_v <= size + lo, lo <= size, size <= _v}
{_v <= 0 + lo, lo <= size, size <= _v}
{0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{_v <= size + lo, lo <= _v}
{_v <= 0 + size, lo <= _v, size <= lo}
Pruned valuations:
{_v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U1 -> {_v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && ([_v -> x1]U1 && (_v == (Cons x1 x2) && (len _v == size && (size >= 0 && len x2 >= 0)))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (4 0)
Trying lo
Checking lo :: A1 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons ?? ??
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A1 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A1 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U1} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Synthesized argument lo of type {Int|_v == lo}
Checking Cons
           lo :: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ?? ??
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Adding constraint lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} /\ X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
lo, range, size C1, C2 |- x2:PList {A1|P0 lo _v} <P0 _0 _1> -> {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: X0:_ -> {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X0, lo, range, size C1, C2 |- {PList|_v == (Cons lo X0)} <: {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} /\ {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} /\ {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} /\ {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} /\ {PList|len _v == size} ()
X0, lo, range, size C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
X0, lo, range, size C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
X0, lo, range, size C1, C2 |- {PList|len _v == 1 + len X0} <: {PList|len _v == size} ()
Constraints
  False ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == (Cons lo x2) && (len _v == size && (size >= 0 && len x2 >= 0))))
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (U1 && (size >= 0 && (lo <= _v && _v <= lo + size))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (5 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x3:Int -> {Int|_v == x3 - 1}
Trying dec
Checking dec :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 - 1} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking dec ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (dec ??)
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x3:Int -> {Int|_v == x3 + 1}
Trying inc
Checking inc :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> {Int|_v == x3 + 1} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A1) <()>'
when checking inc ::
X2:_ -> PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (inc ??)
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 lo _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
X2, X3, lo, range, size C1, C2 |- {PList|_v == (Cons X3 X2)} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 2)
Invalid Constraint: C1 && (C2 && (P1 && size >= 0)) ==> P0
Strengthening: C1 && (C2 && (P1 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: _0 != _1
assumption !(size <= 0) && size >= 0
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, _1 <= lo + _0, lo <= 0}
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P1 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (U2 && size >= 0)) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && size >= 0
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{size != _v, _v <= size + lo, lo <= _v, lo <= size, size <= lo}
{size != _v, _v <= size + lo, lo <= size, size <= _v}
{0 != _v, 0 <= lo, _v <= 0 + size, lo <= 0, lo <= _v}
{0 != _v, 0 <= lo, _v <= size + lo, lo <= 0, lo <= _v}
{_v <= size + lo, lo <= 0, size <= _v}
{0 <= lo, _v <= 0 + size, lo <= 0, size <= _v}
{lo != _v, 0 <= _v, _v <= size + lo, lo <= 0}
{0 != lo, 0 <= _v, _v <= size + lo, lo <= 0}
{0 != _v, 0 <= _v, _v <= size + lo, lo <= 0}
{lo != _v, 0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{0 != _v, 0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{lo != _v, _v <= size + lo, lo <= size, size <= _v}
{size != lo, _v <= size + lo, lo <= size, size <= _v}
{size != lo, _v <= 0 + size, _v <= size + lo, lo <= _v, size <= _v}
{lo != _v, _v <= size + lo, lo <= _v}
{size != lo, 0 <= lo, _v <= 0 + size, lo <= _v, size <= _v}
{size != lo, 0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{lo != _v, 0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{lo != _v, 0 <= lo, _v <= 0 + size, lo <= _v}
Pruned valuations:
{lo != _v, _v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (size >= 0 && (U1 && [_0 -> lo, _1 -> _v]P0))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 0)
Trying size
Checking size :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
{size != lo, 0 <= lo, lo <= size}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking Cons
           size :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:PList {A2|P1 size _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons size x4)} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|_v == (Cons size X2)} <: PList ()
X2, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|_v == (Cons size x4)} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (size >= 0 && (U1 && [_0 -> lo, _1 -> _v]P0))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
Checking dec :: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (?? ??))
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking dec ::
X4:_ -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (dec
                                 ??))
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x5:Int -> {Int|_v == x5 + 1}
Trying inc
Checking inc :: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (?? ??))
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking inc ::
X4:_ -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (inc
                                 ??))
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (?? ??
                                 ??))
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 size _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
X4, X5, lo, range, size C1, C2 |- {PList|_v == (Cons X5 X4)} <: PList ()
X4, X5, lo, range, size C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|U3} <: {Int|U2 && P1 size _v} ()
lo, range, size, x5, x6 C1, C2 |- {PList|_v == (Cons x5 x6)} /\ PList ()
lo, range, size, x5, x6 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x5, x6 C1, C2 |- {Int|U3} /\ {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size, x5, x6 C1, C2 |- {Int|U3} /\ {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
lo, range, size, x5, x6 C1, C2 |- {Int|P2} /\ {Int|P1} ()
X4, X5, lo, range, size C1, C2 |- {Int|U3} <: {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
X4, X5, lo, range, size C1, C2 |- {Int|P2} <: {Int|P1} ()
Constraints
  C1 && (C2 && (P2 && size >= 0)) ==> P1
  C1 && (C2 && (U3 && size >= 0)) ==> U2 && [_0 -> size, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (8 2)
Invalid Constraint: C1 && (C2 && (P2 && size >= 0)) ==> P1
Strengthening: C1 && (C2 && (P2 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), size != lo, 0 <= lo, lo <= size, size >= 0
RHS: _0 != _1
assumption !(size <= 0) && (size != lo && (0 <= lo && (lo <= size && size >= 0)))
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P2 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (U3 && size >= 0)) ==> U2 && [_0 -> size, _1 -> _v]P1
Strengthening: C1 && (C2 && (U3 && size >= 0)) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), size != lo, 0 <= lo, lo <= size, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
assumption !(size <= 0) && (size != lo && (0 <= lo && (lo <= size && size >= 0)))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && size != _v)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,0 <= _v
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{0 != _v, size != _v, _v <= 0 + size, lo <= 0, lo <= _v}
{0 != _v, size != _v, 0 <= _v, _v <= 0 + size, lo <= 0}
{lo != _v, size != _v, 0 <= _v, _v <= 0 + size, lo <= 0}
{lo != _v, size != _v, 0 <= _v, _v <= size + lo, lo <= 0}
{0 != _v, size != _v, 0 <= _v, _v <= size + lo, lo <= 0}
{0 != _v, size != _v, _v <= size + lo, lo <= 0, lo <= _v}
{lo != _v, size != _v, _v <= size + lo, lo <= _v}
{lo != _v, size != _v, _v <= 0 + size, lo <= _v}
{size != _v, _v <= size + lo, size <= _v}
Pruned valuations:
{lo != _v, size != _v, _v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U3 -> {lo != _v, size != _v, _v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && (P1 && (P2 && size >= 0)))
  C1 && (C2 && (U3 && (size >= 0 && (U2 && [_0 -> size, _1 -> _v]P1))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, size != _v, _v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, size != _v, _v <= size + lo, lo <= _v}] (10 0)
Trying lo
Checking lo :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (Cons ??
                                 ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A3 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, size != _v, _v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, size != _v, _v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U3
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> lo != _v && (size != _v && (_v <= size + lo && lo <= _v))
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size != lo, 0 <= lo, lo <= size, size >= 0
RHS: lo != _v && (size != _v && (_v <= size + lo && lo <= _v))
assumption !(size <= 0) && (_v == lo && (size != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(lo != _v && (size != _v && (_v <= size + lo && lo <= _v)))
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking lo ::
{Int|lo != _v && (size != _v && (_v <= size + lo && lo <= _v))}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (Cons lo
                                 ??))
Trying size
Checking size :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (Cons ??
                                 ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A3 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, size != _v, _v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, size != _v, _v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U3
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> lo != _v && (size != _v && (_v <= size + lo && lo <= _v))
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size != lo, 0 <= lo, lo <= size, size >= 0
RHS: lo != _v && (size != _v && (_v <= size + lo && lo <= _v))
assumption !(size <= 0) && (_v == size && (size != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(lo != _v && (size != _v && (_v <= size + lo && lo <= _v)))
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|lo != _v && (size != _v && (_v <= size + lo && lo <= _v))}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (Cons
                                 size ??))
Trying zero
Checking zero :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (Cons ??
                                 ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A3 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, size != _v, _v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, size != _v, _v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> lo != _v && (size != _v && (_v <= size + lo && lo <= _v))
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, size != lo, 0 <= lo, lo <= size, size >= 0
RHS: lo != _v && (size != _v && (_v <= size + lo && lo <= _v))
assumption !(size <= 0) && (_v == zero && (zero == 0 && (size != lo && (0 <= lo && (lo <= size && size >= 0)))))
mustHave !(lo != _v && (size != _v && (_v <= size + lo && lo <= _v)))
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking zero ::
{Int|lo != _v && (size != _v && (_v <= size + lo && lo <= _v))}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (Cons
                                 zero ??))
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (Cons ??
                                 ??))
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: A3 ()
lo, range, size |- A4
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil ::
{Int|lo != _v && (size != _v && (_v <= size + lo && lo <= _v))}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (Cons
                                 Nil ??))
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5}
Trying range
Adding constraint lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X5:_ -> X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (?? ??
                                 ??))
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X4, X5, lo, range, size C1, C2 |- {PList|len _v == X5} <: PList ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|U2 && P1 size _v} ()
lo, range, size, x5, x6 C1, C2 |- {PList|len _v == x5} /\ PList ()
lo, range, size, x5, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x5, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + x5} /\ {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x5, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + x5} /\ {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
lo, range, size, x5, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X4, X5, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + X5} <: {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
X4, X5, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> size, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (size >= 0 && ((U2 && [_0 -> size, _1 -> _v]P1) && ((x6 <= _v && _v <= x6 + x5) && (x5 >= 0 && (x5 >= 0 && x5 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (10 0)
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (?? ??))
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} <: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} /\ X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} /\ X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + lo} <_0 != _1>|len _v == lo} <: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X4, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|U2 && P1 size _v} ()
lo, range, size, x6 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + lo} /\ {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + lo} /\ {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
lo, range, size, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + lo} <: {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> size, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (size >= 0 && ((U2 && [_0 -> size, _1 -> _v]P1) && (x6 <= _v && _v <= x6 + lo))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Synthesized argument size of type {Int|_v == size}
Checking range lo
           size :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (size >= 0 && (size <= _v && _v <= size + lo))) ==> U2 && [_0 -> size, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (size >= 0 && (size <= _v && _v <= size + lo))) ==> U2 && [_0 -> size, _1 -> _v]P1
Strengthening: C1 && (C2 && (size >= 0 && (size <= _v && _v <= size + lo))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), size != lo, 0 <= lo, _v <= size + lo, lo <= size, size <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
assumption !(size <= 0) && (size != lo && (0 <= lo && (_v <= size + lo && (lo <= size && (size <= _v && size >= 0)))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo size ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 lo size))
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range lo
           lo :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (size >= 0 && (lo <= _v && _v <= lo + lo))) ==> U2 && [_0 -> size, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (size >= 0 && (lo <= _v && _v <= lo + lo))) ==> U2 && [_0 -> size, _1 -> _v]P1
Strengthening: C1 && (C2 && (size >= 0 && (lo <= _v && _v <= lo + lo))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), size != lo, 0 <= lo, _v <= lo + lo, lo <= _v, lo <= size, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
assumption !(size <= 0) && (size != lo && (0 <= lo && (_v <= lo + lo && (lo <= _v && (lo <= size && size >= 0)))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo lo ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 lo lo))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range lo
           zero :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> U2 && [_0 -> size, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> U2 && [_0 -> size, _1 -> _v]P1
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo)))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, size != lo, 0 <= lo, _v <= zero + lo, lo <= size, zero <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
assumption !(size <= 0) && (zero == 0 && (size != lo && (0 <= lo && (_v <= zero + lo && (lo <= size && (zero <= _v && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo zero ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 lo ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 lo Nil))
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (10 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (size != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 size ??))
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (?? ??))
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} <: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} /\ X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} /\ X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + zero} <_0 != _1>|len _v == zero} <: X4:_ -> PList {A2|P1 size _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X4, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|U2 && P1 size _v} ()
lo, range, size, x6 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + zero} /\ {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x6 C1, C2 |- {Int|x6 <= _v && _v <= x6 + zero} /\ {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
lo, range, size, x6 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X4, lo, range, size C1, C2 |- {Int|X4 <= _v && _v <= X4 + zero} <: {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
X4, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> size, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (zero == 0 && (size >= 0 && ((U2 && [_0 -> size, _1 -> _v]P1) && (x6 <= _v && _v <= x6 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range zero
           lo :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> U2 && [_0 -> size, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> U2 && [_0 -> size, _1 -> _v]P1
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero)))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, size != lo, 0 <= lo, _v <= lo + zero, lo <= _v, lo <= size, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
assumption !(size <= 0) && (zero == 0 && (size != lo && (0 <= lo && (_v <= lo + zero && (lo <= _v && (lo <= size && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero lo ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 zero lo))
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Synthesized argument size of type {Int|_v == size}
Checking range zero
           size :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero)))) ==> U2 && [_0 -> size, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero)))) ==> U2 && [_0 -> size, _1 -> _v]P1
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero)))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, size != lo, 0 <= lo, _v <= size + zero, lo <= size, size <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
assumption !(size <= 0) && (zero == 0 && (size != lo && (0 <= lo && (_v <= size + zero && (lo <= size && (size <= _v && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero size ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 zero size))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 zero ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 zero Nil))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range zero
           zero :: PList {A2|P1 size _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: PList {A2|P1 size _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && [_0 -> size, _1 -> _v]P1} ()
lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> U2 && [_0 -> size, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> U2 && [_0 -> size, _1 -> _v]P1
Strengthening: C1 && (C2 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero)))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
Instantiated axioms:
All assumptions:
!(size <= 0), zero == 0, size != lo, 0 <= lo, _v <= zero + zero, lo <= size, zero <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && size != _v
assumption !(size <= 0) && (zero == 0 && (size != lo && (0 <= lo && (_v <= zero + zero && (lo <= size && (zero <= _v && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && size != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero zero ::
PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 ?? ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons size (range
                                 Nil ??))
Trying lo
Checking lo :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking lo ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons lo ??)
Trying zero
Checking zero :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == zero && (zero == 0 && size >= 0))
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking zero ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons zero ??)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: A2 ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons Nil ??)
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X2, X3, lo, range, size C1, C2 |- {PList|len _v == X3} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (size >= 0 && ((U1 && [_0 -> lo, _1 -> _v]P0) && ((x4 <= _v && _v <= x4 + x3) && (x3 >= 0 && (x3 >= 0 && x3 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range size ??)
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|len _v == lo} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + lo} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (size >= 0 && ((U1 && [_0 -> lo, _1 -> _v]P0) && (x4 <= _v && _v <= x4 + lo))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
Checking dec :: X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (?? ??))
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X4, lo, range, size C1, C2 |- {Int|_v == X4 - 1} <: Int ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 - 1} /\ Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (dec ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking dec size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument dec
                       size of type {Int|_v == size - 1}
Checking range lo (dec
                     size) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == size - 1 && (size >= 0 && (x4 <= _v && _v <= x4 + lo)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (x4 == size - 1 && (size >= 0 && (x4 <= _v && _v <= x4 + lo)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x4 == size - 1 && (size >= 0 && (x4 <= _v && _v <= x4 + lo)))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == size - 1, size != lo, 0 <= lo, _v <= x4 + lo, lo <= size, x4 <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x4 == size - 1 && (size != lo && (0 <= lo && (_v <= x4 + lo && (lo <= size && (x4 <= _v && size >= 0))))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo (dec
                          size) ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (dec
                                size))
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (dec ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking dec lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument dec
                       lo of type {Int|_v == lo - 1}
Checking range lo (dec
                     lo) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == lo - 1 && (size >= 0 && (x4 <= _v && _v <= x4 + lo)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (x4 == lo - 1 && (size >= 0 && (x4 <= _v && _v <= x4 + lo)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x4 == lo - 1 && (size >= 0 && (x4 <= _v && _v <= x4 + lo)))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == lo - 1, size != lo, 0 <= lo, _v <= x4 + lo, lo <= size, x4 <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x4 == lo - 1 && (size != lo && (0 <= lo && (_v <= x4 + lo && (lo <= size && (x4 <= _v && size >= 0))))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo (dec lo)
::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (dec lo))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (dec ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking dec zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument dec
                       zero of type {Int|_v == zero - 1}
Checking range lo (dec
                     zero) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + lo))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + lo))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + lo))))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == zero - 1, zero == 0, size != lo, 0 <= lo, _v <= x4 + lo, lo <= size, x4 <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x4 == zero - 1 && (zero == 0 && (size != lo && (0 <= lo && (_v <= x4 + lo && (lo <= size && (x4 <= _v && size >= 0)))))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo (dec
                          zero) ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (dec
                                zero))
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (dec ??))
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (dec
                                Nil))
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x5:Int -> {Int|_v == x5 + 1}
Trying inc
Checking inc :: X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (?? ??))
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X4, lo, range, size C1, C2 |- {Int|_v == X4 + 1} <: Int ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 + 1} /\ Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (inc ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking inc size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument inc
                       size of type {Int|_v == size + 1}
Checking range lo (inc
                     size) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == size + 1 && (size >= 0 && (x4 <= _v && _v <= x4 + lo)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (x4 == size + 1 && (size >= 0 && (x4 <= _v && _v <= x4 + lo)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x4 == size + 1 && (size >= 0 && (x4 <= _v && _v <= x4 + lo)))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == size + 1, size != lo, 0 <= lo, _v <= x4 + lo, lo <= size, x4 <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x4 == size + 1 && (size != lo && (0 <= lo && (_v <= x4 + lo && (lo <= size && (x4 <= _v && size >= 0))))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo (inc
                          size) ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (inc
                                size))
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (inc ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking inc lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument inc
                       lo of type {Int|_v == lo + 1}
Checking range lo (inc
                     lo) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == lo + 1 && (size >= 0 && (x4 <= _v && _v <= x4 + lo)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range lo
                       (inc
                          lo) of type LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}
Checking Cons lo (range lo (inc
                              lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == lo + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x4 == lo + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == lo + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == lo + 1, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo
RHS: len _v == size
assumption !(size <= 0) && (x4 == lo + 1 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         (inc lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (inc lo))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (inc ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking inc zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument inc
                       zero of type {Int|_v == zero + 1}
Checking range lo (inc
                     zero) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + lo} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + lo))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + lo))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + lo))))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == zero + 1, zero == 0, size != lo, 0 <= lo, _v <= x4 + lo, lo <= size, x4 <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x4 == zero + 1 && (zero == 0 && (size != lo && (0 <= lo && (_v <= x4 + lo && (lo <= size && (x4 <= _v && size >= 0)))))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{lo <= 0}
Pruned valuations:
{lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range lo
                       (inc
                          zero) of type LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}
Checking Cons lo (range lo (inc
                              zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + lo} <_0 != _1>|len _v == lo}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= 0, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == zero + 1, zero == 0, len _v == 1 + len x2, len x2 == lo, size != lo, 0 <= lo, lo <= 0, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo
RHS: len _v == size
assumption !(size <= 0) && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == lo && (size != lo && (0 <= lo && (lo <= 0 && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + lo)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range lo
                         (inc zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (inc
                                zero))
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (inc ??))
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (inc
                                Nil))
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (?? ??
                                ??))
Adding constraint lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> Int ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Cons ::
X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (Cons ??
                                ??))
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5}
Trying range
Adding constraint lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (?? ??
                                ??))
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
TYPE ERROR: Cannot match shape 'PList (Int) <()>'
with shape 'Int'
when checking range ::
X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range lo (range ??
                                ??))
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X2, lo, range, size C1, C2 |- {PList|len _v == zero} <: PList ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + zero} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (zero == 0 && (size >= 0 && ((U1 && [_0 -> lo, _1 -> _v]P0) && (x4 <= _v && _v <= x4 + zero)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
Checking dec :: X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (??
                                  ??))
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X4, lo, range, size C1, C2 |- {Int|_v == X4 - 1} <: Int ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 - 1} /\ Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (dec
                                  ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking dec size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument dec
                       size of type {Int|_v == size - 1}
Checking range zero (dec
                       size) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == size - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (x4 == size - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x4 == size - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == size - 1, zero == 0, _v <= x4 + zero, x4 <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x4 == size - 1 && (zero == 0 && (_v <= x4 + zero && (x4 <= _v && size >= 0))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero (dec
                            size) ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (dec
                                  size))
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (dec
                                  ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking dec lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument dec
                       lo of type {Int|_v == lo - 1}
Checking range zero (dec
                       lo) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == lo - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == lo - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (x4 == lo - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x4 == lo - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == lo - 1, zero == 0, _v <= x4 + zero, x4 <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x4 == lo - 1 && (zero == 0 && (_v <= x4 + zero && (x4 <= _v && size >= 0))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero (dec
                            lo) ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (dec
                                  lo))
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (dec
                                  ??))
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (dec
                                  Nil))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (dec
                                  ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking dec zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument dec
                       zero of type {Int|_v == zero - 1}
Checking range zero (dec
                       zero) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == zero - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x4 == zero - 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == zero - 1, zero == 0, _v <= x4 + zero, x4 <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x4 == zero - 1 && (zero == 0 && (_v <= x4 + zero && (x4 <= _v && size >= 0))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero (dec
                            zero) ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (dec
                                  zero))
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x5:Int -> {Int|_v == x5 + 1}
Trying inc
Checking inc :: X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (??
                                  ??))
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X4, lo, range, size C1, C2 |- {Int|_v == X4 + 1} <: Int ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 + 1} /\ Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (inc
                                  ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking inc size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument inc
                       size of type {Int|_v == size + 1}
Checking range zero (inc
                       size) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == size + 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (x4 == size + 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x4 == size + 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == size + 1, zero == 0, _v <= x4 + zero, x4 <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x4 == size + 1 && (zero == 0 && (_v <= x4 + zero && (x4 <= _v && size >= 0))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, 0 <= lo, lo <= size}
{lo <= size, size <= lo}
Pruned valuations:
{0 != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {0 != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range zero
                       (inc
                          size) of type LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}
Checking Cons lo (range zero
                    (inc
                       size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == size + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == size + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x4 == size + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == size + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == size + 1, zero == 0, len _v == 1 + len x2, len x2 == zero, 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero
RHS: len _v == size
assumption !(size <= 0) && (x4 == size + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero))))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero (inc size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (inc
                                  size))
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (inc
                                  ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking inc lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument inc
                       lo of type {Int|_v == lo + 1}
Checking range zero (inc
                       lo) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == lo + 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range zero
                       (inc
                          lo) of type LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}
Checking Cons lo (range zero
                    (inc
                       lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == lo + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x4 == lo + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == lo + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == lo + 1, zero == 0, len _v == 1 + len x2, len x2 == zero, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero
RHS: len _v == size
assumption !(size <= 0) && (x4 == lo + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero (inc lo)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (inc
                                  lo))
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (inc
                                  ??))
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (inc
                                  Nil))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (inc
                                  ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking inc zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument inc
                       zero of type {Int|_v == zero + 1}
Checking range zero (inc
                       zero) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x4 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + zero} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (size >= 0 && (x4 <= _v && _v <= x4 + zero))))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == zero + 1, zero == 0, _v <= x4 + zero, x4 <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x4 == zero + 1 && (zero == 0 && (_v <= x4 + zero && (x4 <= _v && size >= 0))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
Pruned valuations:
{0 <= lo, lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument range zero
                       (inc
                          zero) of type LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}
Checking Cons lo (range zero
                    (inc
                       zero)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == zero + 1}) IN {PList {Int|x4 <= _v && _v <= x4 + zero} <_0 != _1>|len _v == zero}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))) ==> len _v == size
Instantiated axioms:
All assumptions:
!(size <= 0), x4 == zero + 1, zero == 0, len _v == 1 + len x2, len x2 == zero, 0 <= lo, lo <= 0, size >= 0, len x2 >= 0, forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero
RHS: len _v == size
assumption !(size <= 0) && (x4 == zero + 1 && (zero == 0 && (len _v == 1 + len x2 && (len x2 == zero && (0 <= lo && (lo <= 0 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + zero)))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (range
                         zero (inc zero)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (inc
                                  zero))
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (?? ??
                                  ??))
Adding constraint lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:A2 -> x6:PList {A2|P1 x5 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> Int ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Cons ::
X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (Cons
                                  ?? ??))
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5}
Trying range
Adding constraint lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (?? ??
                                  ??))
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> Int ()
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> Int ()
Typing Constraints
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> Int ()
lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
TYPE ERROR: Cannot match shape 'PList (Int) <()>'
with shape 'Int'
when checking range ::
X5:_ -> X4:_ -> Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range zero (range
                                  ?? ??))
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range Nil ??)
Adding constraint lo, range, size |- A2
Adding constraint |- P1 :: A2 -> A2 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:A2 -> x4:PList {A2|P1 x3 _v} <P1 _0 _1> -> {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
|- P1 :: A2 -> A2 -> Bool
lo, range, size |- A2
UNIFY A2 WITH {Int|U1 && P0 lo _v} PRODUCING {Int|U2}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Typing Constraints
|- P1 :: A2 -> A2 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size |- {Int|U2}
X2, X3, lo, range, size C1, C2 |- {PList|_v == (Cons X3 X2)} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (5 2)
Invalid Constraint: C1 && (C2 && (P1 && size >= 0)) ==> P0
Strengthening: C1 && (C2 && (P1 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: _0 != _1
assumption !(size <= 0) && size >= 0
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, _1 <= lo + _0, lo <= 0}
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P1 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {}] (6 1)
Invalid Constraint: C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (U2 && size >= 0)) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && size >= 0
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{0 <= lo, _v <= 0 + size, lo <= 0, size <= _v}
{_v <= size + lo, lo <= 0, size <= _v}
{size != _v, _v <= size + lo, lo <= _v, lo <= size, size <= lo}
{lo != _v, 0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
{lo != _v, _v <= size + lo, lo <= size, size <= _v}
{size != lo, _v <= 0 + size, _v <= size + lo, lo <= _v, size <= _v}
{size != lo, 0 <= lo, _v <= 0 + size, lo <= _v, size <= _v}
{size != _v, _v <= size + lo, lo <= size, size <= _v}
{lo != _v, 0 <= _v, _v <= size + lo, lo <= 0}
{0 != _v, 0 <= lo, _v <= size + lo, lo <= 0, lo <= _v}
{0 != _v, 0 <= _v, _v <= size + lo, lo <= 0}
{0 != lo, 0 <= _v, _v <= size + lo, lo <= 0}
{lo != _v, _v <= size + lo, lo <= _v}
{0 != _v, 0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{lo != _v, 0 <= _v, 0 <= lo, _v <= 0 + size, lo <= 0}
{0 != _v, 0 <= lo, _v <= 0 + size, lo <= 0, lo <= _v}
{lo != _v, 0 <= lo, _v <= 0 + size, lo <= _v}
{size != lo, _v <= size + lo, lo <= size, size <= _v}
{size != lo, 0 <= lo, _v <= 0 + size, lo <= size, size <= _v}
Pruned valuations:
{lo != _v, _v <= size + lo, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}]
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (size >= 0 && (U1 && [_0 -> lo, _1 -> _v]P0))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (7 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
Checking dec :: X4:_ -> A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (?? ??) ??)
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> A2 ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> A2 ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> A2 ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X4, lo, range, size C1, C2 |- {Int|_v == X4 - 1} <: {Int|U2} ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 - 1} /\ {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x5 C1, C2 |- {Int|_v == x5 - 1} /\ {Int|U2} ()
X4, lo, range, size C1, C2 |- {Int|_v == X4 - 1} <: {Int|U2} ()
Constraints
  False ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (U2 && (_v == x5 - 1 && size >= 0)))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec ??) ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking dec size :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size - 1} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == size - 1 && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == size - 1 && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == size - 1 && size >= 0)) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size - 1, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == size - 1 && size >= 0)
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking dec size ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec size)
                      ??)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec ??) ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking dec lo :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo - 1} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo - 1} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == lo - 1 && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == lo - 1 && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == lo - 1 && size >= 0)) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo - 1, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == lo - 1 && size >= 0)
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking dec lo ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec lo) ??)
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec ??) ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking dec zero :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero - 1} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero - 1} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == zero - 1 && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == zero - 1 && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero - 1 && (zero == 0 && size >= 0))) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero - 1, zero == 0, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == zero - 1 && (zero == 0 && size >= 0))
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking dec zero ::
{Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec zero)
                      ??)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec ??) ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (dec Nil) ??)
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x5:Int -> {Int|_v == x5 + 1}
Trying inc
Checking inc :: X4:_ -> A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (?? ??) ??)
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> A2 ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> A2 ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} /\ X4:_ -> A2 ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 + 1} <: X4:_ -> A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X4, lo, range, size C1, C2 |- {Int|_v == X4 + 1} <: {Int|U2} ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 + 1} /\ {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x5 C1, C2 |- {Int|_v == x5 + 1} /\ {Int|U2} ()
X4, lo, range, size C1, C2 |- {Int|_v == X4 + 1} <: {Int|U2} ()
Constraints
  False ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (U2 && (_v == x5 + 1 && size >= 0)))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc ??) ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking inc size :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size + 1} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size + 1} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == size + 1 && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == size + 1 && size >= 0)) ==> U2
Strengthening: C1 && (C2 && (_v == size + 1 && size >= 0)) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size + 1, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == size + 1 && size >= 0)
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, 0 <= lo, lo <= size}
{lo <= size, size <= lo}
Pruned valuations:
{0 != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {0 != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Synthesized argument inc
                       size of type {Int|_v == size + 1}
Checking Cons (inc
                 size) :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X2, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 X2)} <: PList ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (size >= 0 && (U1 && [_0 -> lo, _1 -> _v]P0))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Trying lo
Checking lo :: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
x3:{Int|_v == size + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      lo)
Trying size
Checking size :: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
x3:{Int|_v == size + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      size)
Trying zero
Checking zero :: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
x3:{Int|_v == size + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size, x3 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons (inc size)
           Nil :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Cons (inc
                             size)
                       Nil of type LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))}
Checking Cons lo (Cons (inc
                          size)
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == size + 1, x2 == (Cons x3 (Nil)), len _v == 1 + len x2, len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == [], 0 != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 (Nil))) == [x3] + elems (Nil) && (elems (Nil) == [] && (0 != lo && (0 <= lo && (lo <= size && (size >= 0 && len x2 >= 0)))))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      Nil)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x6:Int -> {Int|_v == x6 - 1}
Trying dec
Checking dec :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (?? ??))
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking dec ::
X5:_ -> x3:{Int|_v == size + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (dec ??))
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x6:Int -> {Int|_v == x6 + 1}
Trying inc
Checking inc :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (?? ??))
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking inc ::
X5:_ -> x3:{Int|_v == size + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (inc ??))
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)}
Trying Cons
Checking Cons :: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (?? ?? ??))
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
X5, X6, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons X6 X5)} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|_v == (Cons x6 x7)} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2} /\ {Int|P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|U3} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2} <: {Int|P1} ()
Constraints
  C1 && (C2 && (P2 && size >= 0)) ==> P1
  C1 && (C2 && (U3 && (x3 == size + 1 && size >= 0))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C1 && (C2 && (P2 && size >= 0)) ==> P1
Strengthening: C1 && (C2 && (P2 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: _0 != _1
assumption !(size <= 0) && (0 != lo && (0 <= lo && (lo <= size && size >= 0)))
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P2 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C1 && (C2 && (U3 && (x3 == size + 1 && size >= 0))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (U3 && (x3 == size + 1 && size >= 0))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == size + 1, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == size + 1 && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != _v
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{lo != _v, _v <= 0 + size, lo <= _v}
{lo != _v, _v <= 0 + size, size <= _v}
{size != lo, _v <= 0 + size, size <= _v}
Pruned valuations:
{lo != _v, _v <= 0 + size, lo <= _v}
Diffs: (1)
[C1 -> {}, C2 -> {}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}]
Checking consistency
  C1 && (C2 && (P1 && (P2 && size >= 0)))
  C1 && (C2 && (U3 && (x3 == size + 1 && (size >= 0 && (U2 && [_0 -> x3, _1 -> _v]P1)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (11 0)
Trying lo
Checking lo :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A3 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U3
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> lo != _v && (_v <= 0 + size && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: lo != _v && (_v <= 0 + size && lo <= _v)
assumption !(size <= 0) && (_v == lo && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(lo != _v && (_v <= 0 + size && lo <= _v))
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking lo ::
{Int|lo != _v && (_v <= 0 + size && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons lo ??))
Trying size
Checking size :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A3 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U3
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> lo != _v && (_v <= 0 + size && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: lo != _v && (_v <= 0 + size && lo <= _v)
assumption !(size <= 0) && (_v == size && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(lo != _v && (_v <= 0 + size && lo <= _v))
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{size != lo}
Pruned valuations:
{size != lo}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (12 0)
Synthesized argument size of type {Int|_v == size}
Checking Cons
           size :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (?? ??))
Adding constraint lo, range, size C1, C2 |- x7:PList {A3|P2 size _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:PList {A3|P2 size _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:PList {A3|P2 size _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons size x7)} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:PList {A3|P2 size _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons size x7)} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
X5, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size X5)} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|_v == (Cons size x7)} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size, x3, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|P2} /\ {Int|P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|U3} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|P2} <: {Int|P1} ()
Constraints
  C1 && (C2 && (P2 && size >= 0)) ==> P1
  C1 && (C2 && (U3 && (x3 == size + 1 && size >= 0))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (P2 && size >= 0)))
  C1 && (C2 && (U3 && (x3 == size + 1 && (size >= 0 && (U2 && [_0 -> x3, _1 -> _v]P1)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (12 0)
Trying lo
Checking lo :: PList {A3|P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons size ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A3|P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: PList {A3|P2 size _v} <P2 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A3) <()>'
when checking lo ::
PList {Int|(lo != _v && (_v <= 0 + size && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons size lo))
Trying size
Checking size :: PList {A3|P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons size ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: PList {A3|P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: PList {A3|P2 size _v} <P2 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A3) <()>'
when checking size ::
PList {Int|(lo != _v && (_v <= 0 + size && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons size size))
Trying zero
Checking zero :: PList {A3|P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons size ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A3|P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: PList {A3|P2 size _v} <P2 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A3) <()>'
when checking zero ::
PList {Int|(lo != _v && (_v <= 0 + size && lo <= _v)) && size != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons size zero))
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: PList {A3|P2 size _v} <P2 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons size ??))
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {A3|P2 size _v} <P2 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: PList {A3|P2 size _v} <P2 _0 _1> ()
lo, range, size |- A4
UNIFY A4 WITH {Int|U3 && P2 size _v} PRODUCING {Int|U4}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
A4 -> {Int|U4}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
A4 -> {Int|U4}
Simple Constraints
lo, range, size |- {Int|U4}
lo, range, size C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: {Int|P2 _0 _1} ()
lo, range, size C1, C2 |- {Int|False} <: {Int|U3 && P2 size _v} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}, U4 -> {}] (12 0)
Synthesized argument Nil of type {PList {A4|False} <False>|_v == (Nil)}
Checking Cons size
           Nil :: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList A3 <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList A3 <P2 _0 _1>|_v == (Cons size (Nil))} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
A4 -> {Int|U4}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons size (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|U3} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|U3} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|P2} <: {Int|P1} ()
Constraints
  C1 && (C2 && (P2 && size >= 0)) ==> P1
  C1 && (C2 && (U3 && (x3 == size + 1 && size >= 0))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}, U4 -> {}] (12 0)
Synthesized argument Cons size
                       Nil of type {PList A3 <P2 _0 _1>|_v == (Cons size (Nil))}
Checking Cons (inc size) (Cons
                            size
                            Nil) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList A3 <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList A3 <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
A4 -> {Int|U4}
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}, U4 -> {}] (12 0)
Synthesized argument Cons (inc
                             size) (Cons size
                                      Nil) of type LET x4:({PList A3 <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Checking Cons lo (Cons (inc
                          size) (Cons size
                                   Nil)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList A3 <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList A3 <P2 _0 _1>|_v == (Cons size (Nil))}) IN LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
A4 -> {Int|U4}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U4 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}, U4 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}, U4 -> {}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))) ==> len _v == size
Instantiated axioms:
len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == []
All assumptions:
!(size <= 0), x3 == size + 1, x2 == (Cons x3 x4), x4 == (Cons size (Nil)), len _v == 1 + len x2, len ((Cons size (Nil))) == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, elems ((Cons size (Nil))) == [size] + elems (Nil), elems ((Cons x3 x4)) == [x3] + elems x4, elems (Nil) == [], 0 != lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (x2 == (Cons x3 x4) && (x4 == (Cons size (Nil)) && (len _v == 1 + len x2 && (len ((Cons size (Nil))) == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (elems ((Cons size (Nil))) == [size] + elems (Nil) && (elems ((Cons x3 x4)) == [x3] + elems x4 && (elems (Nil) == [] && (0 != lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && len x4 >= 0))))))))))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) (Cons size Nil)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons size Nil))
Trying zero
Checking zero :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A3 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {lo != _v, _v <= 0 + size, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> lo != _v && (_v <= 0 + size && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: lo != _v && (_v <= 0 + size && lo <= _v)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 != lo && (0 <= lo && (lo <= size && size >= 0)))))
mustHave !(lo != _v && (_v <= 0 + size && lo <= _v))
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking zero ::
{Int|lo != _v && (_v <= 0 + size && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons zero ??))
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons ?? ??))
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: A3 ()
lo, range, size |- A4
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil ::
{Int|lo != _v && (_v <= 0 + size && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (Cons Nil ??))
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6}
Trying range
Adding constraint lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (?? ?? ??))
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X5, X6, lo, range, size, x3 C1, C2 |- {PList|len _v == X6} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|len _v == x6} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x3 == size + 1 && (size >= 0 && ((U2 && [_0 -> x3, _1 -> _v]P1) && ((x7 <= _v && _v <= x7 + x6) && (x6 >= 0 && (x6 >= 0 && x6 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{size != lo}
Pruned valuations:
{size != lo}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (?? ??))
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x3 == size + 1 && (size >= 0 && ((U2 && [_0 -> x3, _1 -> _v]P1) && (x7 <= _v && _v <= x7 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument size of type {Int|_v == size}
Checking range lo
           size :: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == size + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == size + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == size + 1, 0 != lo, size != lo, 0 <= lo, _v <= size + lo, lo <= size, size <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == size + 1 && (0 != lo && (size != lo && (0 <= lo && (_v <= size + lo && (lo <= size && (size <= _v && size >= 0)))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo size ::
x3:{Int|_v == size + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range lo size))
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range lo
           lo :: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == size + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == size + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == size + 1, 0 != lo, size != lo, 0 <= lo, _v <= lo + lo, lo <= _v, lo <= size, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == size + 1 && (0 != lo && (size != lo && (0 <= lo && (_v <= lo + lo && (lo <= _v && (lo <= size && size >= 0)))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo lo ::
x3:{Int|_v == size + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range lo lo))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range lo
           zero :: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == size + 1, zero == 0, 0 != lo, size != lo, 0 <= lo, _v <= zero + lo, lo <= size, zero <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == size + 1 && (zero == 0 && (0 != lo && (size != lo && (0 <= lo && (_v <= zero + lo && (lo <= size && (zero <= _v && size >= 0))))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo zero ::
x3:{Int|_v == size + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range lo Nil))
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 != lo, 0 <= lo, lo <= size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (0 != lo && (0 <= lo && (lo <= size && size >= 0))))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range size ??))
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (?? ??))
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && ((U2 && [_0 -> x3, _1 -> _v]P1) && (x7 <= _v && _v <= x7 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range zero
           lo :: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == size + 1, zero == 0, 0 != lo, 0 <= lo, _v <= lo + zero, lo <= _v, lo <= size, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == size + 1 && (zero == 0 && (0 != lo && (0 <= lo && (_v <= lo + zero && (lo <= _v && (lo <= size && size >= 0)))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero lo ::
x3:{Int|_v == size + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range zero lo))
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument size of type {Int|_v == size}
Checking range zero
           size :: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == size + 1, zero == 0, 0 != lo, 0 <= lo, _v <= size + zero, lo <= size, size <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == size + 1 && (zero == 0 && (0 != lo && (0 <= lo && (_v <= size + zero && (lo <= size && (size <= _v && size >= 0)))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
{size != lo}
Pruned valuations:
{size != lo}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (13 0)
Synthesized argument range zero
                       size of type {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}
Checking Cons (inc size) (range
                            zero
                            size) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (13 0)
Synthesized argument Cons (inc
                             size) (range zero
                                      size) of type LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}
Checking Cons lo (Cons (inc
                          size) (range zero
                                   size)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero}) IN LET x3:({Int|_v == size + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (13 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (13 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4
All assumptions:
!(size <= 0), x3 == size + 1, zero == 0, x2 == (Cons x3 x4), len _v == 1 + len x2, len x4 == zero, len ((Cons x3 x4)) == 1 + len x4, elems ((Cons x3 x4)) == [x3] + elems x4, 0 != lo, size != lo, 0 <= lo, lo <= size, size >= 0, len x2 >= 0, len x4 >= 0, forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero
RHS: len _v == size
assumption !(size <= 0) && (x3 == size + 1 && (zero == 0 && (x2 == (Cons x3 x4) && (len _v == 1 + len x2 && (len x4 == zero && (len ((Cons x3 x4)) == 1 + len x4 && (elems ((Cons x3 x4)) == [x3] + elems x4 && (0 != lo && (size != lo && (0 <= lo && (lo <= size && (size >= 0 && (len x2 >= 0 && (len x4 >= 0 && (forall _x . _x in elems x4 ==> size <= _x && _x <= size + zero)))))))))))))))
mustHave !(len _v == size)
qualsList [0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               size) (range zero size)) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range zero size))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range zero Nil))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range zero
           zero :: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == size + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == size + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == size + 1, zero == 0, 0 != lo, 0 <= lo, _v <= zero + zero, lo <= size, zero <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == size + 1 && (zero == 0 && (0 != lo && (0 <= lo && (_v <= zero + zero && (lo <= size && (zero <= _v && size >= 0)))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != size
          ,size != lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero zero ::
x3:{Int|_v == size + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc size)
                      (range Nil ??))
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc ??) ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Synthesized argument lo of type {Int|_v == lo}
Checking inc lo :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo + 1} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == lo + 1 && size >= 0)) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Synthesized argument inc
                       lo of type {Int|_v == lo + 1}
Checking Cons (inc
                 lo) :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == lo + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X2, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 X2)} <: PList ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (size >= 0 && (U1 && [_0 -> lo, _1 -> _v]P0))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Trying size
Checking size :: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
x3:{Int|_v == lo + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      size)
Trying lo
Checking lo :: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
x3:{Int|_v == lo + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) lo)
Trying zero
Checking zero :: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
x3:{Int|_v == lo + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      zero)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size, x3 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons (inc lo)
           Nil :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == lo + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == lo + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Cons (inc
                             lo)
                       Nil of type LET x3:({Int|_v == lo + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))}
Checking Cons lo (Cons (inc lo)
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == lo + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == lo + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == lo + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == lo + 1, x2 == (Cons x3 (Nil)), len _v == 1 + len x2, len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == [], size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == lo + 1 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 (Nil))) == [x3] + elems (Nil) && (elems (Nil) == [] && (size >= 0 && len x2 >= 0))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               lo) Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) Nil)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x6:Int -> {Int|_v == x6 - 1}
Trying dec
Checking dec :: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) (??
                                     ??))
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking dec ::
X5:_ -> x3:{Int|_v == lo + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) (dec
                                     ??))
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x6:Int -> {Int|_v == x6 + 1}
Trying inc
Checking inc :: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) (??
                                     ??))
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking inc ::
X5:_ -> x3:{Int|_v == lo + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) (inc
                                     ??))
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)}
Trying Cons
Checking Cons :: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) (??
                                     ?? ??))
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
X5, X6, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons X6 X5)} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|_v == (Cons x6 x7)} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2} /\ {Int|P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|U3} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2} <: {Int|P1} ()
Constraints
  C1 && (C2 && (P2 && size >= 0)) ==> P1
  C1 && (C2 && (U3 && (x3 == lo + 1 && size >= 0))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C1 && (C2 && (P2 && size >= 0)) ==> P1
Strengthening: C1 && (C2 && (P2 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), size >= 0
RHS: _0 != _1
assumption !(size <= 0) && size >= 0
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 != lo, _1 <= lo + _0, lo <= 0}
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P2 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C1 && (C2 && (U3 && (x3 == lo + 1 && size >= 0))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (U3 && (x3 == lo + 1 && size >= 0))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == lo + 1, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == lo + 1 && size >= 0)
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= lo
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= 0
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
{0 != _v, 0 != lo, 0 <= _v, _v <= size + lo, lo <= 0}
{size != _v, size != lo, _v <= size + lo, lo <= size, size <= _v}
Pruned valuations:
{size != _v, size != lo, _v <= size + lo, lo <= size, size <= _v}
{0 != _v, 0 != lo, 0 <= _v, _v <= size + lo, lo <= 0}
Diffs: (2)
[C1 -> {}, C2 -> {size != lo, lo <= size}, U3 -> {size != _v, _v <= size + lo, size <= _v}]
[C1 -> {}, C2 -> {0 != lo, lo <= 0}, U3 -> {0 != _v, 0 <= _v, _v <= size + lo}]
Checking consistency
  C1 && (C2 && (P1 && (P2 && size >= 0)))
  C1 && (C2 && (U3 && (x3 == lo + 1 && (size >= 0 && (U2 && [_0 -> x3, _1 -> _v]P1)))))
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {size != _v, _v <= size + lo, size <= _v}] (11 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {0 != _v, 0 <= _v, _v <= size + lo}] (11 0)
Remaining Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {size != _v, _v <= size + lo, size <= _v}] (11 0)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {0 != _v, 0 <= _v, _v <= size + lo}] (11 0)
Trying size
Checking size :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (Cons ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: A3 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|U3} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {size != _v, _v <= size + lo, size <= _v}] (11 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {0 != _v, 0 <= _v, _v <= size + lo}] (11 1)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {0 != _v, 0 <= _v, _v <= size + lo}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U3
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> 0 != _v && (0 <= _v && _v <= size + lo)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 != lo, lo <= 0, size >= 0
RHS: 0 != _v && (0 <= _v && _v <= size + lo)
assumption !(size <= 0) && (_v == size && (0 != lo && (lo <= 0 && size >= 0)))
mustHave !(0 != _v && (0 <= _v && _v <= size + lo))
qualsList [0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {size != _v, _v <= size + lo, size <= _v}] (11 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {size != _v, _v <= size + lo, size <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> U3
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> size != _v && (_v <= size + lo && size <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size != lo, lo <= size, size >= 0
RHS: size != _v && (_v <= size + lo && size <= _v)
assumption !(size <= 0) && (_v == size && (size != lo && (lo <= size && size >= 0)))
mustHave !(size != _v && (_v <= size + lo && size <= _v))
qualsList [0 != lo
          ,0 != size
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|size != _v && (_v <= size + lo && size <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (Cons size ??))
Trying lo
Checking lo :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (Cons ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: A3 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|U3} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {size != _v, _v <= size + lo, size <= _v}] (11 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {0 != _v, 0 <= _v, _v <= size + lo}] (11 1)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {0 != _v, 0 <= _v, _v <= size + lo}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U3
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> 0 != _v && (0 <= _v && _v <= size + lo)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, 0 != lo, lo <= 0, size >= 0
RHS: 0 != _v && (0 <= _v && _v <= size + lo)
assumption !(size <= 0) && (_v == lo && (0 != lo && (lo <= 0 && size >= 0)))
mustHave !(0 != _v && (0 <= _v && _v <= size + lo))
qualsList [0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {size != _v, _v <= size + lo, size <= _v}] (11 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {size != _v, _v <= size + lo, size <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> U3
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> size != _v && (_v <= size + lo && size <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size != lo, lo <= size, size >= 0
RHS: size != _v && (_v <= size + lo && size <= _v)
assumption !(size <= 0) && (_v == lo && (size != lo && (lo <= size && size >= 0)))
mustHave !(size != _v && (_v <= size + lo && size <= _v))
qualsList [0 != lo
          ,0 != size
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking lo ::
{Int|size != _v && (_v <= size + lo && size <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (Cons lo ??))
Trying zero
Checking zero :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (Cons ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: A3 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|U3} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (2)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {size != _v, _v <= size + lo, size <= _v}] (11 1)
  0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {0 != _v, 0 <= _v, _v <= size + lo}] (11 1)
Chosen candidate: 0.1: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 != lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {0 != _v, 0 <= _v, _v <= size + lo}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> 0 != _v && (0 <= _v && _v <= size + lo)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, 0 != lo, lo <= 0, size >= 0
RHS: 0 != _v && (0 <= _v && _v <= size + lo)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (0 != lo && (lo <= 0 && size >= 0))))
mustHave !(0 != _v && (0 <= _v && _v <= size + lo))
qualsList [0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
Candidates (1)
  0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {size != _v, _v <= size + lo, size <= _v}] (11 1)
Chosen candidate: 0.0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {size != _v, _v <= size + lo, size <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> U3
Strengthening: C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> size != _v && (_v <= size + lo && size <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero, zero == 0, size != lo, lo <= size, size >= 0
RHS: size != _v && (_v <= size + lo && size <= _v)
assumption !(size <= 0) && (_v == zero && (zero == 0 && (size != lo && (lo <= size && size >= 0))))
mustHave !(size != _v && (_v <= size + lo && size <= _v))
qualsList [0 != lo
          ,0 != size
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking zero ::
{Int|size != _v && (_v <= size + lo && size <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (Cons zero ??))
Adding constraint lo, range, size |- A4
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A4|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: A3 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (Cons ?? ??))
Adding constraint lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: A3 ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A4|False} <False>|_v == (Nil)} <: A3 ()
lo, range, size |- A4
TYPE ERROR: Cannot match shape 'PList (A4) <()>'
with shape 'Int'
when checking Nil ::
{Int|size != _v && (_v <= size + lo && size <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (Cons Nil ??))
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6}
Trying range
Adding constraint lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) (??
                                     ?? ??))
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X5, X6, lo, range, size, x3 C1, C2 |- {PList|len _v == X6} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|len _v == x6} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x3 == lo + 1 && (size >= 0 && ((U2 && [_0 -> x3, _1 -> _v]P1) && ((x7 <= _v && _v <= x7 + x6) && (x6 >= 0 && (x6 >= 0 && x6 < size)))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range size ??))
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == lo, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == lo && size >= 0)
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{size != lo, 0 <= lo, lo <= size}
{0 <= lo, lo <= 0}
Pruned valuations:
{size != lo, 0 <= lo, lo <= size}
Diffs: (1)
[C1 -> {}, C2 -> {size != lo, 0 <= lo, lo <= size}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) (??
                                     ??))
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x3 == lo + 1 && (size >= 0 && ((U2 && [_0 -> x3, _1 -> _v]P1) && (x7 <= _v && _v <= x7 + lo)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument size of type {Int|_v == size}
Checking range lo
           size :: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == lo + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == lo + 1 && (size >= 0 && (size <= _v && _v <= size + lo)))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == lo + 1, size != lo, 0 <= lo, _v <= size + lo, lo <= size, size <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == lo + 1 && (size != lo && (0 <= lo && (_v <= size + lo && (lo <= size && (size <= _v && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo size ::
x3:{Int|_v == lo + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range lo size))
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range lo
           lo :: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == lo + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == lo + 1 && (size >= 0 && (lo <= _v && _v <= lo + lo)))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == lo + 1, size != lo, 0 <= lo, _v <= lo + lo, lo <= _v, lo <= size, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == lo + 1 && (size != lo && (0 <= lo && (_v <= lo + lo && (lo <= _v && (lo <= size && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo lo ::
x3:{Int|_v == lo + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range lo lo))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range lo
           zero :: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {size != lo, 0 <= lo, lo <= size}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == lo + 1, zero == 0, size != lo, 0 <= lo, _v <= zero + lo, lo <= size, zero <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == lo + 1 && (zero == 0 && (size != lo && (0 <= lo && (_v <= zero + lo && (lo <= size && (zero <= _v && size >= 0)))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,0 <= size
          ,lo <= 0
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo zero ::
x3:{Int|_v == lo + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range lo Nil))
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) (??
                                     ??))
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && ((U2 && [_0 -> x3, _1 -> _v]P1) && (x7 <= _v && _v <= x7 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument size of type {Int|_v == size}
Checking range zero
           size :: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == lo + 1, zero == 0, _v <= size + zero, size <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == lo + 1 && (zero == 0 && (_v <= size + zero && (size <= _v && size >= 0))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero size ::
x3:{Int|_v == lo + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range zero size))
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range zero
           lo :: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == lo + 1, zero == 0, _v <= lo + zero, lo <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == lo + 1 && (zero == 0 && (_v <= lo + zero && (lo <= _v && size >= 0))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero lo ::
x3:{Int|_v == lo + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range zero lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range zero Nil))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range zero
           zero :: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo) ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == lo + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == lo + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == lo + 1, zero == 0, _v <= zero + zero, zero <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == lo + 1 && (zero == 0 && (_v <= zero + zero && (zero <= _v && size >= 0))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero zero ::
x3:{Int|_v == lo + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc lo)
                      (range Nil ??))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc ??) ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 0)
Synthesized argument zero of type {Int|_v == zero}
Checking inc zero :: A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero + 1} <: A2 ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: A2 ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: {Int|U2} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero + 1} <: {Int|U2} ()
Constraints
  C1 && (C2 && (_v == zero + 1 && (zero == 0 && size >= 0))) ==> U2
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (8 1)
Invalid Constraint: C1 && (C2 && (_v == zero + 1 && (zero == 0 && size >= 0))) ==> U2
Strengthening: C1 && (C2 && (_v == zero + 1 && (zero == 0 && size >= 0))) ==> lo != _v && (_v <= size + lo && lo <= _v)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == zero + 1, zero == 0, size >= 0
RHS: lo != _v && (_v <= size + lo && lo <= _v)
assumption !(size <= 0) && (_v == zero + 1 && (zero == 0 && size >= 0))
mustHave !(lo != _v && (_v <= size + lo && lo <= _v))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{0 <= lo, lo <= 0}
Pruned valuations:
{0 <= lo, lo <= 0}
Diffs: (1)
[C1 -> {}, C2 -> {0 <= lo, lo <= 0}]
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Synthesized argument inc
                       zero of type {Int|_v == zero + 1}
Checking Cons (inc
                 zero) :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> -> LET x3:({Int|_v == zero + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 x4)} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X2, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 X2)} <: PList ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|_v == (Cons x3 x4)} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1 _0 _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|U2} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|P1} /\ {Int|P0} ()
X2, lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, lo, range, size, x3 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (P1 && size >= 0)))
  C1 && (C2 && (U2 && (size >= 0 && (U1 && [_0 -> lo, _1 -> _v]P0))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (9 0)
Trying size
Checking size :: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking size ::
x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      size)
Trying lo
Checking lo :: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking lo ::
x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      lo)
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
lo, range, size, x3 C1, C2 |- {PList|_v == (Nil)} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|False} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Nil of type {PList {A3|False} <False>|_v == (Nil)}
Checking Cons (inc zero)
           Nil :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == zero + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == zero + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|_v == (Cons x3 (Nil))} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|P1 _0 _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|U2} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3 C1, C2 |- {Int|P1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (P1 && size >= 0)) ==> P0
  C1 && (C2 && (U2 && size >= 0)) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 0)
Synthesized argument Cons (inc
                             zero)
                       Nil of type LET x3:({Int|_v == zero + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))}
Checking Cons lo (Cons (inc
                          zero)
                    Nil) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == zero + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x3:({Int|_v == zero + 1}) IN {PList A2 <P1 _0 _1>|_v == (Cons x3 (Nil))}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
P1 -> P1
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))))) ==> len _v == size
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (size >= 0 && len x2 >= 0)))))) ==> len _v == size
Instantiated axioms:
len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == []
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, x2 == (Cons x3 (Nil)), len _v == 1 + len x2, len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, elems ((Cons x3 (Nil))) == [x3] + elems (Nil), elems (Nil) == [], 0 <= lo, lo <= 0, size >= 0, len x2 >= 0
RHS: len _v == size
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (x2 == (Cons x3 (Nil)) && (len _v == 1 + len x2 && (len ((Cons x3 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (elems ((Cons x3 (Nil))) == [x3] + elems (Nil) && (elems (Nil) == [] && (0 <= lo && (lo <= 0 && (size >= 0 && len x2 >= 0)))))))))))
mustHave !(len _v == size)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons lo (Cons (inc
                               zero) Nil) ::
{PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      Nil)
Trying zero
Checking zero :: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking zero ::
x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      zero)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x6:Int -> {Int|_v == x6 - 1}
Trying dec
Checking dec :: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (?? ??))
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 - 1} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking dec ::
X5:_ -> x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (dec ??))
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x6:Int -> {Int|_v == x6 + 1}
Trying inc
Checking inc :: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (?? ??))
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
TYPE ERROR: Cannot match shape 'Int'
with shape 'PList (A2) <()>'
when checking inc ::
X5:_ -> x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (inc ??))
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)}
Trying Cons
Checking Cons :: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (?? ?? ??))
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:A3 -> x7:PList {A3|P2 x6 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x6 x7)} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
UNIFY A3 WITH {Int|U2 && P1 x3 _v} PRODUCING {Int|U3}
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Typing Constraints
|- P2 :: A3 -> A3 -> Bool
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
A3 -> {Int|U3}
Simple Constraints
lo, range, size |- {Int|U3}
X5, X6, lo, range, size, x3 C1, C2 |- {PList|_v == (Cons X6 X5)} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2 _0 _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|U3} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|_v == (Cons x6 x7)} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2 _0 _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
P2 -> P2
Simple Constraints
lo, range, size, x3, x6, x7 C1, C2 |- {Int|U3} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|P2} /\ {Int|P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|U3} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|P2} <: {Int|P1} ()
Constraints
  C1 && (C2 && (P2 && size >= 0)) ==> P1
  C1 && (C2 && (U3 && (x3 == zero + 1 && (zero == 0 && size >= 0)))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P2 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U3 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C1 && (C2 && (P2 && size >= 0)) ==> P1
Strengthening: C1 && (C2 && (P2 && size >= 0)) ==> _0 != _1
Instantiated axioms:
All assumptions:
!(size <= 0), 0 <= lo, lo <= 0, size >= 0
RHS: _0 != _1
assumption !(size <= 0) && (0 <= lo && (lo <= 0 && size >= 0))
mustHave !(_0 != _1)
qualsList [_1 == _0 + 1
          ,_1 == _0 - 1
          ,0 != lo
          ,0 != size
          ,_0 != _1
          ,size != lo
          ,0 <= size
          ,_0 <= _1
          ,_1 <= 0 + _0
          ,_1 <= lo + _0
          ,_1 <= size + _0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
{_1 == _0 + 1}
{_0 != _1}
{_1 == _0 - 1}
Pruned valuations:
{_0 != _1}
Diffs: (1)
[C1 -> {}, C2 -> {}, P2 -> {_0 != _1}]
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, P2 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C1 && (C2 && (U3 && (x3 == zero + 1 && (zero == 0 && size >= 0)))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (U3 && (x3 == zero + 1 && (zero == 0 && size >= 0)))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, 0 <= lo, lo <= 0, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (0 <= lo && (lo <= 0 && size >= 0))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != _v
          ,0 != lo
          ,0 != size
          ,lo != _v
          ,size != _v
          ,size != lo
          ,0 <= _v
          ,0 <= size
          ,_v <= 0 + lo
          ,_v <= 0 + size
          ,_v <= size + lo
          ,lo <= _v
          ,lo <= size
          ,size <= _v
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons ::
X6:_ -> X5:_ -> x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (Cons ?? ??))
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6}
Trying range
Adding constraint lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (?? ?? ??))
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} /\ X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + x6} <_0 != _1>|len _v == x6} <: X6:_ -> X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x6:Int -> x7:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X5, X6, lo, range, size, x3 C1, C2 |- {PList|len _v == X6} <: PList ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x6, x7 C1, C2 |- {PList|len _v == x6} /\ PList ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x6, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + x6} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x6, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + X6} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, X6, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && ((U2 && [_0 -> x3, _1 -> _v]P1) && ((x7 <= _v && _v <= x7 + x6) && (x6 >= 0 && (x6 >= 0 && x6 < size))))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 0)
Trying size
Checking size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (11 1)
Invalid Constraint: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Strengthening: C1 && (C2 && (_v == size && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
Instantiated axioms:
All assumptions:
!(size <= 0), _v == size, 0 <= lo, lo <= 0, size >= 0
RHS: _v >= 0 && (_v >= 0 && _v < size)
assumption !(size <= 0) && (_v == size && (0 <= lo && (lo <= 0 && size >= 0)))
mustHave !(_v >= 0 && (_v >= 0 && _v < size))
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking size ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range size ??))
Trying lo
Checking lo :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == lo && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range
           lo :: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (?? ??))
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + lo} <_0 != _1>|len _v == lo} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == lo} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + lo} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && ((U2 && [_0 -> x3, _1 -> _v]P1) && (x7 <= _v && _v <= x7 + lo))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument size of type {Int|_v == size}
Checking range lo
           size :: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + lo))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + lo))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + lo))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, 0 <= lo, _v <= size + lo, lo <= 0, size <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (0 <= lo && (_v <= size + lo && (lo <= 0 && (size <= _v && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo size ::
x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range lo size))
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range lo
           lo :: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + lo))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + lo))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + lo))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, 0 <= lo, _v <= lo + lo, lo <= 0, lo <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (0 <= lo && (_v <= lo + lo && (lo <= 0 && (lo <= _v && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo lo ::
x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range lo lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range lo Nil))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range lo ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range lo
           zero :: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + lo} <_0 != _1>|len _v == lo} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == lo} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + lo} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + lo))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, 0 <= lo, _v <= zero + lo, lo <= 0, zero <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (0 <= lo && (_v <= zero + lo && (lo <= 0 && (zero <= _v && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range lo zero ::
x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range lo zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil ::
{Int|_v >= 0 && (_v >= 0 && _v < size)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range Nil ??))
Trying zero
Checking zero :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range ?? ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == zero && (zero == 0 && size >= 0))) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range
           zero :: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (?? ??))
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} /\ X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
lo, range, size C1, C2 |- x7:Int -> {PList {Int|x7 <= _v && _v <= x7 + zero} <_0 != _1>|len _v == zero} <: X5:_ -> LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
X5, lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && P1 x3 _v} ()
lo, range, size, x3, x7 C1, C2 |- {PList|len _v == zero} /\ PList ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1 _0 _1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3, x7 C1, C2 |- {Int|x7 <= _v && _v <= x7 + zero} /\ {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3, x7 C1, C2 |- {Int|_0 != _1} /\ {Int|P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|X5 <= _v && _v <= X5 + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
X5, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  False ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P1 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && ((U2 && [_0 -> x3, _1 -> _v]P1) && (x7 <= _v && _v <= x7 + zero))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument size of type {Int|_v == size}
Checking range zero
           size :: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|size <= _v && _v <= size + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (size <= _v && _v <= size + zero))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, 0 <= lo, _v <= size + zero, lo <= 0, size <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (0 <= lo && (_v <= size + zero && (lo <= 0 && (size <= _v && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero size ::
x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range zero size))
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range zero
           lo :: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|lo <= _v && _v <= lo + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (lo <= _v && _v <= lo + zero))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, 0 <= lo, _v <= lo + zero, lo <= 0, lo <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (0 <= lo && (_v <= lo + zero && (lo <= 0 && (lo <= _v && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero lo ::
x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range zero lo))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range zero Nil))
Trying zero
Checking zero :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range zero ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range zero
           zero :: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- {PList {Int|zero <= _v && _v <= zero + zero} <_0 != _1>|len _v == zero} <: LET x3:({Int|_v == zero + 1}) IN PList {A2|P1 x3 _v} <P1 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
A2 -> {Int|U2}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == zero} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && P1 x3 _v} ()
Pred assignment
P0 -> P0
P1 -> P1
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + zero} <: {Int|U2 && [_0 -> x3, _1 -> _v]P1} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P1} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P1
  C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  P1 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U2 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {0 <= lo, lo <= 0}, P0 -> {_0 != _1}, P1 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}, U2 -> {lo != _v, _v <= size + lo, lo <= _v}] (12 1)
Invalid Constraint: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> U2 && [_0 -> x3, _1 -> _v]P1
Strengthening: C1 && (C2 && (x3 == zero + 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + zero))))) ==> (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == zero + 1, zero == 0, 0 <= lo, _v <= zero + zero, lo <= 0, zero <= _v, size >= 0
RHS: (lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v
assumption !(size <= 0) && (x3 == zero + 1 && (zero == 0 && (0 <= lo && (_v <= zero + zero && (lo <= 0 && (zero <= _v && size >= 0))))))
mustHave !((lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= size
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range zero zero ::
x3:{Int|_v == zero + 1} -> PList {Int|(lo != _v && (_v <= size + lo && lo <= _v)) && x3 != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc zero)
                      (range zero zero))
Adding constraint lo, range, size |- A3
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A3|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc ??) ??)
Adding constraint lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A3|False} <False>|_v == (Nil)} <: Int ()
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Nil :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (inc Nil) ??)
Adding constraint lo, range, size |- A3
Adding constraint |- P2 :: A3 -> A3 -> Bool
INSTANTIATE <a> . <p :: a -> a -> Bool> . x:a -> xs:PList {a|p x _v} <p _0 _1> -> {PList a <p _0 _1>|_v == (Cons x xs)}
INTO x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (?? ?? ??)
                      ??)
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> A2 ()
Adding constraint lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> A2 ()
Typing Constraints
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} /\ X5:_ -> X4:_ -> A2 ()
lo, range, size C1, C2 |- x5:A3 -> x6:PList {A3|P2 x5 _v} <P2 _0 _1> -> {PList A3 <P2 _0 _1>|_v == (Cons x5 x6)} <: X5:_ -> X4:_ -> A2 ()
|- P2 :: A3 -> A3 -> Bool
lo, range, size |- A3
TYPE ERROR: Cannot match shape 'PList (A3) <()>'
with shape 'Int'
when checking Cons ::
X5:_ -> X4:_ -> {Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (Cons ?? ??)
                      ??)
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5}
Trying range
Adding constraint lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X5:_ -> X4:_ -> A2 in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (?? ?? ??)
                      ??)
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> A2 ()
Adding constraint lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> A2 ()
Typing Constraints
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} /\ X5:_ -> X4:_ -> A2 ()
lo, range, size C1, C2 |- x5:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x6:Int -> {PList {Int|x6 <= _v && _v <= x6 + x5} <_0 != _1>|len _v == x5} <: X5:_ -> X4:_ -> A2 ()
lo, range, size C1, C2 |- x5:Int -> x6:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
TYPE ERROR: Cannot match shape 'PList (Int) <()>'
with shape 'Int'
when checking range ::
X5:_ -> X4:_ -> {Int|lo != _v && (_v <= size + lo && lo <= _v)}
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (Cons (range ?? ??)
                      ??)
INSTANTIATE x0:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> lo:Int -> {PList {Int|lo <= _v && _v <= lo + x0} <_0 != _1>|len _v == x0}
INTO x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Trying range
Adding constraint lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Checking range :: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ?? ??)
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:{Int|_v >= 0 && (_v >= 0 && _v < size)} -> x4:Int -> {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X3:_ -> X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x3:Int -> x4:Int -> {PList {Int|False} <False>|False} <: size:{Int|False} -> lo:{Int|False} -> PList Int <True> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {PList|False} <: PList ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
lo, range, size C1, C2 |- {Int|False} <: Int ()
X2, X3, lo, range, size C1, C2 |- {PList|len _v == X3} <: PList ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|X2 <= _v && _v <= X2 + X3} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, X3, lo, range, size C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (size >= 0 && ((U1 && [_0 -> lo, _1 -> _v]P0) && ((x4 <= _v && _v <= x4 + x3) && (x3 >= 0 && (x3 >= 0 && x3 < size))))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (7 0)
INSTANTIATE x:Int -> {Int|_v == x - 1}
INTO x5:Int -> {Int|_v == x5 - 1}
Trying dec
Checking dec :: X4:_ -> {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (?? ??) ??)
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Adding constraint lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} /\ X4:_ -> {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size C1, C2 |- x5:Int -> {Int|_v == x5 - 1} <: X4:_ -> {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X4, lo, range, size C1, C2 |- {Int|_v == X4 - 1} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
lo, range, size, x5 C1, C2 |- {Int|_v == x5 - 1} /\ {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x5 C1, C2 |- {Int|_v == x5 - 1} /\ {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
X4, lo, range, size C1, C2 |- {Int|_v == X4 - 1} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  False ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (_v == x5 - 1 && (size >= 0 && (_v >= 0 && (_v >= 0 && _v < size)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Trying size
Checking size :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec ??) ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (8 0)
Synthesized argument size of type {Int|_v == size}
Checking dec
           size :: {Int|_v >= 0 && (_v >= 0 && _v < size)} in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range ?? ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == size - 1} <: {Int|_v >= 0 && (_v >= 0 && _v < size)} ()
Constraints
  C1 && (C2 && (_v == size - 1 && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument dec
                       size of type {Int|_v == size - 1}
Checking range (dec
                  size) :: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (?? ??)
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN Int -> LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Adding constraint lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN Int -> LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN Int -> LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} /\ X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
lo, range, size C1, C2 |- x4:LET x3:({Int|_v == size - 1}) IN Int -> LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: X2:_ -> PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X2, lo, range, size, x3 C1, C2 |- {PList|len _v == x3} <: PList ()
X2, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
X2, lo, range, size, x3 C1, C2 |- {Int|X2 <= _v && _v <= X2 + x3} <: {Int|U1 && P0 lo _v} ()
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} /\ PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} /\ {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} /\ {Int|P0} ()
X2, lo, range, size, x3 C1, C2 |- {Int|X2 <= _v && _v <= X2 + x3} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
X2, lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  False ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
  C1 && (C2 && (P0 && (_0 != _1 && size >= 0)))
  C1 && (C2 && (x3 == size - 1 && (size >= 0 && ((U1 && [_0 -> lo, _1 -> _v]P0) && (x4 <= _v && _v <= x4 + x3)))))
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Trying lo
Checking lo :: LET x3:({Int|_v == size - 1}) IN Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == size - 1}) IN Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: LET x3:({Int|_v == size - 1}) IN Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking range (dec size)
           lo :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == size - 1}) IN {PList {Int|lo <= _v && _v <= lo + x3} <_0 != _1>|len _v == x3} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == size - 1}) IN {PList {Int|lo <= _v && _v <= lo + x3} <_0 != _1>|len _v == x3} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == x3} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + x3} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|lo <= _v && _v <= lo + x3} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x3 == size - 1 && (size >= 0 && (lo <= _v && _v <= lo + x3)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (size >= 0 && (lo <= _v && _v <= lo + x3)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x3 == size - 1 && (size >= 0 && (lo <= _v && _v <= lo + x3)))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == size - 1, _v <= lo + x3, lo <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x3 == size - 1 && (_v <= lo + x3 && (lo <= _v && size >= 0)))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range (dec size)
                lo ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec size)
                      lo)
Trying size
Checking size :: LET x3:({Int|_v == size - 1}) IN Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == size - 1}) IN Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == size} <: LET x3:({Int|_v == size - 1}) IN Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|_v == size} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument size of type {Int|_v == size}
Checking range (dec size)
           size :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == size - 1}) IN {PList {Int|size <= _v && _v <= size + x3} <_0 != _1>|len _v == x3} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == size - 1}) IN {PList {Int|size <= _v && _v <= size + x3} <_0 != _1>|len _v == x3} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == x3} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + x3} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|size <= _v && _v <= size + x3} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x3 == size - 1 && (size >= 0 && (size <= _v && _v <= size + x3)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (size >= 0 && (size <= _v && _v <= size + x3)))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x3 == size - 1 && (size >= 0 && (size <= _v && _v <= size + x3)))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == size - 1, _v <= size + x3, size <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x3 == size - 1 && (_v <= size + x3 && (size <= _v && size >= 0)))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range (dec size)
                size ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec size)
                      size)
Trying zero
Checking zero :: LET x3:({Int|_v == size - 1}) IN Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == size - 1}) IN Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == zero} <: LET x3:({Int|_v == size - 1}) IN Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|_v == zero} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument zero of type {Int|_v == zero}
Checking range (dec size)
           zero :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x3:({Int|_v == size - 1}) IN {PList {Int|zero <= _v && _v <= zero + x3} <_0 != _1>|len _v == x3} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x3:({Int|_v == size - 1}) IN {PList {Int|zero <= _v && _v <= zero + x3} <_0 != _1>|len _v == x3} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x3 C1, C2 |- {PList|len _v == x3} <: PList ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + x3} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|zero <= _v && _v <= zero + x3} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x3 == size - 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + x3))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 1)
Invalid Constraint: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + x3))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
Strengthening: C1 && (C2 && (x3 == size - 1 && (zero == 0 && (size >= 0 && (zero <= _v && _v <= zero + x3))))) ==> (_v <= size + lo && lo <= _v) && lo != _v
Instantiated axioms:
All assumptions:
!(size <= 0), x3 == size - 1, zero == 0, _v <= zero + x3, zero <= _v, size >= 0
RHS: (_v <= size + lo && lo <= _v) && lo != _v
assumption !(size <= 0) && (x3 == size - 1 && (zero == 0 && (_v <= zero + x3 && (zero <= _v && size >= 0))))
mustHave !((_v <= size + lo && lo <= _v) && lo != _v)
qualsList [0 != lo
          ,0 != size
          ,size != lo
          ,0 <= lo
          ,0 <= size
          ,lo <= 0
          ,lo <= size
          ,size <= lo]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking range (dec size)
                zero ::
PList {Int|(_v <= size + lo && lo <= _v) && lo != _v} <_0 != _1>
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec size)
                      zero)
Adding constraint lo, range, size |- A2
INSTANTIATE <a> . <p :: a -> a -> Bool> . {PList a <p _0 _1>|_v == (Nil)}
INTO {PList {A2|False} <False>|_v == (Nil)}
Trying Nil
Checking Nil :: LET x3:({Int|_v == size - 1}) IN Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == size - 1}) IN Int ()
Typing Constraints
lo, range, size C1, C2 |- {PList {A2|False} <False>|_v == (Nil)} <: LET x3:({Int|_v == size - 1}) IN Int ()
lo, range, size |- A2
TYPE ERROR: Cannot match shape 'PList (A2) <()>'
with shape 'Int'
when checking Nil ::
x3:{Int|_v == size - 1} -> Int
in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec size)
                      Nil)
INSTANTIATE x:Int -> {Int|_v == x + 1}
INTO x6:Int -> {Int|_v == x6 + 1}
Trying inc
Checking inc :: X5:_ -> LET x3:({Int|_v == size - 1}) IN Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec size)
                      (?? ??))
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN Int ()
Adding constraint lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN Int ()
Typing Constraints
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} /\ X5:_ -> LET x3:({Int|_v == size - 1}) IN Int ()
lo, range, size C1, C2 |- x6:Int -> {Int|_v == x6 + 1} <: X5:_ -> LET x3:({Int|_v == size - 1}) IN Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
X5, lo, range, size, x3 C1, C2 |- {Int|_v == X5 + 1} <: Int ()
lo, range, size, x3, x6 C1, C2 |- {Int|_v == x6 + 1} /\ Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Trying lo
Checking lo :: Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec size)
                      (inc ??))
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size C1, C2 |- {Int|_v == lo} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument lo of type {Int|_v == lo}
Checking inc
           lo :: LET x3:({Int|_v == size - 1}) IN Int in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo (range (dec size)
                      ??)
Adding constraint lo, range, size C1, C2 |- {Int|_v == lo + 1} <: LET x3:({Int|_v == size - 1}) IN Int ()
Typing Constraints
lo, range, size C1, C2 |- {Int|_v == lo + 1} <: LET x3:({Int|_v == size - 1}) IN Int ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x3 C1, C2 |- {Int|_v == lo + 1} <: Int ()
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (9 0)
Synthesized argument inc
                       lo of type {Int|_v == lo + 1}
Checking range (dec size) (inc
                             lo) :: PList {A1|P0 lo _v} <P0 _0 _1> in
\size . \lo . 
    if size <= 0
      then Nil
      else Cons lo ??
Adding constraint lo, range, size C1, C2 |- LET x4:({Int|_v == lo + 1}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Typing Constraints
lo, range, size C1, C2 |- LET x4:({Int|_v == lo + 1}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3} <: PList {A1|P0 lo _v} <P0 _0 _1> ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {PList|len _v == x3} <: PList ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0 _0 _1} ()
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} <: {Int|U1 && P0 lo _v} ()
Pred assignment
P0 -> P0
Simple Constraints
lo, range, size, x3, x4 C1, C2 |- {Int|x4 <= _v && _v <= x4 + x3} <: {Int|U1 && [_0 -> lo, _1 -> _v]P0} ()
lo, range, size, x3, x4 C1, C2 |- {Int|_0 != _1} <: {Int|P0} ()
Constraints
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
  C1 && (C2 && (x3 == size - 1 && (x4 == lo + 1 && (size >= 0 && (x4 <= _v && _v <= x4 + x3))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (10 0)
Synthesized argument range (dec
                              size) (inc
                                       lo) of type LET x4:({Int|_v == lo + 1}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}
Checking Cons lo (range (dec
                           size) (inc
                                    lo)) :: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} in
\size . \lo . 
    if size <= 0
      then Nil
      else ??
Adding constraint lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo + 1}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Typing Constraints
lo, range, size C1, C2 |- LET x2:(LET x4:({Int|_v == lo + 1}) IN LET x3:({Int|_v == size - 1}) IN {PList {Int|x4 <= _v && _v <= x4 + x3} <_0 != _1>|len _v == x3}) IN {PList A1 <P0 _0 _1>|_v == (Cons lo x2)} <: {PList {Int|lo <= _v && _v <= lo + size} <_0 != _1>|len _v == size} ()
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
lo, range, size, x2 C1, C2 |- {PList|_v == (Cons lo x2)} <: {PList|len _v == size} ()
lo, range, size, x2 C1, C2 |- {Int|P0 _0 _1} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
Pred assignment
P0 -> P0
addSplitConstraint lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Simple Constraints
lo, range, size, x2 C1, C2 |- {Int|U1} <: {Int|lo <= _v && _v <= lo + size} ()
lo, range, size, x2 C1, C2 |- {Int|P0} <: {Int|_0 != _1} ()
lo, range, size, x2 C1, C2 |- {PList|len _v == 1 + len x2} <: {PList|len _v == size} ()
Constraints
  C1 && (C2 && (x3 == size - 1 && (x4 == lo + 1 && (len _v == 1 + len x2 && (len x2 == x3 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + x3)))))))) ==> len _v == size
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (11 0)
Typing Constraints
Type assignment
A0 -> {Int|U0}
A1 -> {Int|U1}
Simple Constraints
Pred assignment
P0 -> P0
Simple Constraints
Constraints
QMap
  C0 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  C1 -> {!(size <= 0)}
  C2 -> {0 <= size, size != lo, 0 != lo, 0 != size, lo <= size, lo <= 0, size <= lo, size <= 0, 0 <= lo}
  P0 -> {_1 == _0 + 1, _0 != _1, _1 <= lo + _0, _1 <= size + _0, _1 <= 0 + _0, _0 <= _1, _1 == _0 - 1}
  U0 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
  U1 -> {0 != _v, _v <= size + lo, _v <= 0 + lo, _v <= 0 + size, lo <= _v, size <= _v, 0 <= _v, lo != _v, size != _v}
Checking consistency
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {!(size <= 0)}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (11 0)
Auxiliary goals are:
Re-checking candidates after updating C1
Checking validity
  C1 && (C2 && (P0 && size >= 0)) ==> _0 != _1
  C1 && (C2 && (U1 && size >= 0)) ==> lo <= _v && _v <= lo + size
  C1 && (C2 && (_v == lo && size >= 0)) ==> U1
  C1 && (C2 && (_v == size - 1 && size >= 0)) ==> _v >= 0 && (_v >= 0 && _v < size)
  C1 && (C2 && (x3 == size - 1 && (x4 == lo + 1 && (len _v == 1 + len x2 && (len x2 == x3 && (size >= 0 && (len x2 >= 0 && (forall _x . _x in elems x2 ==> x4 <= _x && _x <= x4 + x3)))))))) ==> len _v == size
  C1 && (C2 && (x3 == size - 1 && (x4 == lo + 1 && (size >= 0 && (x4 <= _v && _v <= x4 + x3))))) ==> U1 && [_0 -> lo, _1 -> _v]P0
  C1 && (C2 && (_0 != _1 && size >= 0)) ==> P0
Candidates (1)
  0: [C0 -> {size <= 0}, C1 -> {}, C2 -> {}, P0 -> {_0 != _1}, U0 -> {}, U1 -> {_v <= size + lo, lo <= _v}] (11 0)
Remaining Candidates (0)
TYPE ERROR: Re-checking candidates failed
