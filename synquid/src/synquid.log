Checking error in
error
Adding constraint product |- Int <: {Int|False} ()
Typing Constraints
product |- Int <: {Int|False} ()
Type assignment
Simple Constraints
product |- Int <: {Int|False} ()
Pred assignment
Constraints
  True ==> False
QMap
Candidates (1)
  0: [] (0 1)
Chosen candidate: 0: [] (0 1)
Invalid Constraint: True ==> False
Strengthening: True ==> False
Instantiated axioms:
All assumptions:
True
RHS: False
assumption True
mustHave True
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
error
Adding constraint product, xs, ys |- (match) M0
Adding constraint product, xs, ys |- C0
Checking error in
\xs . \ys . error
Adding constraint product, xs, ys C0, M0 |- {Int|xs == xs && ys == ys} <: {Int|False} ()
Typing Constraints
product, xs, ys C0, M0 |- {Int|xs == xs && ys == ys} <: {Int|False} ()
product, xs, ys |- C0
product, xs, ys |- (match) M0
Type assignment
Simple Constraints
product, xs, ys |- (match) M0
product, xs, ys |- C0
product, xs, ys C0, M0 |- {Int|xs == xs && ys == ys} <: {Int|False} ()
Pred assignment
Constraints
  C0 && (M0 && (len xs >= 0 && (len ys >= 0 && (xs == xs && ys == ys)))) ==> False
QMap
  C0 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
Candidates (1)
  0: [C0 -> {}, M0 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}, M0 -> {}] (0 1)
Invalid Constraint: C0 && (M0 && (len xs >= 0 && (len ys >= 0 && (xs == xs && ys == ys)))) ==> False
Strengthening: C0 && (M0 && (len xs >= 0 && (len ys >= 0 && (xs == xs && ys == ys)))) ==> False
Instantiated axioms:
len (Nil) == 0, len (Nil) == 0
All assumptions:
xs == xs, ys == ys, len (Nil) == 0, len (Nil) == 0, len xs >= 0, len ys >= 0
RHS: False
assumption True
mustHave xs == xs && (ys == ys && (len (Nil) == 0 && (len (Nil) == 0 && (len xs >= 0 && len ys >= 0))))
qualsList [xs == (Nil)
          ,ys == (Nil)]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\xs . \ys . error
Looking for type {List Pair a b|len _v == len xs * len ys}
Trying xs
Checking xs :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . ??
Adding constraint product, xs, ys C0, M0 |- {List a|_v == xs} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, xs, ys C0, M0 |- {List a|_v == xs} <: {List Pair a b|len _v == len xs * len ys} ()
product, xs, ys |- C0
product, xs, ys |- (match) M0
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . xs
Trying ys
Checking ys :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . ??
Adding constraint product, xs, ys C0, M0 |- {List b|_v == ys} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, xs, ys C0, M0 |- {List b|_v == ys} <: {List Pair a b|len _v == len xs * len ys} ()
product, xs, ys |- C0
product, xs, ys |- (match) M0
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . ys
Adding constraint product, xs, ys |- A0
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A0|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . ??
Adding constraint product, xs, ys C0, M0 |- {List {A0|False}|_v == (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, xs, ys C0, M0 |- {List {A0|False}|_v == (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
product, xs, ys |- A0
product, xs, ys |- C0
product, xs, ys |- (match) M0
UNIFY A0 WITH Pair a b PRODUCING {Pair {a|U0} {b|U1}|U2}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
Simple Constraints
product, xs, ys |- (match) M0
product, xs, ys |- C0
product, xs, ys |- {Pair {a|U0} {b|U1}|U2}
product, xs, ys |- {b|U1}
product, xs, ys |- {a|U0}
product, xs, ys C0, M0 |- {List|_v == (Nil)} <: {List|len _v == len xs * len ys} ()
product, xs, ys C0, M0 |- {Pair|False} <: Pair ()
product, xs, ys C0, M0 |- {b|U1} <: b ()
product, xs, ys C0, M0 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint product, xs, ys C0, M0 |- {List|len _v == 0} <: {List|len _v == len xs * len ys} ()
Constraints
  C0 && (M0 && (len _v == 0 && (len xs >= 0 && len ys >= 0))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}, M0 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (0 1)
Invalid Constraint: C0 && (M0 && (len _v == 0 && (len xs >= 0 && len ys >= 0))) ==> len _v == len xs * len ys
Strengthening: C0 && (M0 && (len _v == 0 && (len xs >= 0 && len ys >= 0))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len (Nil) == 0
All assumptions:
len _v == 0, len (Nil) == 0, len (Nil) == 0, len xs >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption len _v == 0 && (len (Nil) == 0 && (len (Nil) == 0 && (len xs >= 0 && len ys >= 0)))
mustHave !(len _v == len xs * len ys)
qualsList [xs == (Nil)
          ,ys == (Nil)]
Optimal valuations:
{xs == (Nil)}
{ys == (Nil)}
Pruned valuations:
{ys == (Nil)}
{xs == (Nil)}
Diffs: (2)
[C0 -> {}, M0 -> {ys == (Nil)}]
[C0 -> {}, M0 -> {xs == (Nil)}]
Checking consistency
Candidates (2)
  0.0: [C0 -> {}, M0 -> {ys == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}] (1 0)
  0.1: [C0 -> {}, M0 -> {xs == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}] (1 0)
Remaining Candidates (2)
  0.0: [C0 -> {}, M0 -> {ys == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}] (1 0)
  0.1: [C0 -> {}, M0 -> {xs == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}] (1 0)
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
Simple Constraints
Pred assignment
Constraints
QMap
  C0 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (2)
  0.0: [C0 -> {}, M0 -> {ys == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}] (1 0)
  0.1: [C0 -> {}, M0 -> {xs == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}] (1 0)
Remaining Candidates (2)
  0.0: [C0 -> {}, M0 -> {ys == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}] (1 0)
  0.1: [C0 -> {}, M0 -> {xs == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}] (1 0)
Auxiliary goals are:
Match valuation [xs == (Nil)]
Adding constraint product, xs, ys |- A1
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x1:A1 -> x2:List A1 -> {List A1|_v == (Cons x1 x2)}
Matching constructor type
{List A1|_v == (Cons x1 x2)}
with scrutinee
List a
Checking error in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> error
Adding constraint product, x3, x4, xs, ys True, M1 |- {Int|x3 == x3 && (x4 == x4 && (xs == xs && ys == ys))} <: {Int|False} ()
Typing Constraints
product, x3, x4, xs, ys True, M1 |- {Int|x3 == x3 && (x4 == x4 && (xs == xs && ys == ys))} <: {Int|False} ()
product, xs, ys |- A1
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
Simple Constraints
product, xs, ys |- a
product, x3, x4, xs, ys True, M1 |- {Int|x3 == x3 && (x4 == x4 && (xs == xs && ys == ys))} <: {Int|False} ()
Pred assignment
Constraints
  M1 && (len x4 >= 0 && (len xs >= 0 && (len ys >= 0 && (x3 == x3 && (x4 == x4 && (xs == xs && ys == ys)))))) ==> False
QMap
  C0 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0.1: [C0 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, U0 -> {}, U1 -> {}, U2 -> {}] (1 1)
Chosen candidate: 0.1: [C0 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, U0 -> {}, U1 -> {}, U2 -> {}] (1 1)
Invalid Constraint: M1 && (len x4 >= 0 && (len xs >= 0 && (len ys >= 0 && (x3 == x3 && (x4 == x4 && (xs == xs && ys == ys)))))) ==> False
Strengthening: M1 && (len x4 >= 0 && (len xs >= 0 && (len ys >= 0 && (x3 == x3 && (x4 == x4 && (xs == xs && ys == ys)))))) ==> False
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4
All assumptions:
x3 == x3, x4 == x4, xs == xs, xs == (Cons x3 x4), ys == ys, len ((Cons x3 x4)) == 1 + len x4, len x4 >= 0, len xs >= 0, len ys >= 0
RHS: False
assumption True
mustHave x3 == x3 && (x4 == x4 && (xs == xs && (xs == (Cons x3 x4) && (ys == ys && (len ((Cons x3 x4)) == 1 + len x4 && (len x4 >= 0 && (len xs >= 0 && len ys >= 0)))))))
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> error
Adding constraint product, x3, x4, xs, ys |- (match) M2
Adding constraint product, x3, x4, xs, ys |- C1
Checking error in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> error
Adding constraint product, x3, x4, xs, ys True, C1, M1, M2 |- {Int|x3 == x3 && (x4 == x4 && (xs == xs && ys == ys))} <: {Int|False} ()
Typing Constraints
product, x3, x4, xs, ys True, C1, M1, M2 |- {Int|x3 == x3 && (x4 == x4 && (xs == xs && ys == ys))} <: {Int|False} ()
product, x3, x4, xs, ys |- C1
product, x3, x4, xs, ys |- (match) M2
product, xs, ys |- A1
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
Simple Constraints
product, xs, ys |- a
product, x3, x4, xs, ys |- (match) M2
product, x3, x4, xs, ys |- C1
product, x3, x4, xs, ys True, C1, M1, M2 |- {Int|x3 == x3 && (x4 == x4 && (xs == xs && ys == ys))} <: {Int|False} ()
Pred assignment
Constraints
  C1 && (M1 && (M2 && (len x4 >= 0 && (len xs >= 0 && (len ys >= 0 && (x3 == x3 && (x4 == x4 && (xs == xs && ys == ys)))))))) ==> False
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (1 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {}, U0 -> {}, U1 -> {}, U2 -> {}] (1 1)
Invalid Constraint: C1 && (M1 && (M2 && (len x4 >= 0 && (len xs >= 0 && (len ys >= 0 && (x3 == x3 && (x4 == x4 && (xs == xs && ys == ys)))))))) ==> False
Strengthening: C1 && (M1 && (M2 && (len x4 >= 0 && (len xs >= 0 && (len ys >= 0 && (x3 == x3 && (x4 == x4 && (xs == xs && ys == ys)))))))) ==> False
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0
All assumptions:
x3 == x3, x4 == x4, xs == xs, xs == (Cons x3 x4), ys == ys, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len x4 >= 0, len xs >= 0, len ys >= 0
RHS: False
assumption True
mustHave x3 == x3 && (x4 == x4 && (xs == xs && (xs == (Cons x3 x4) && (ys == ys && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && len ys >= 0))))))))
qualsList [ys == (Nil)]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> error
Looking for type {List Pair a b|len _v == len xs * len ys}
Trying x3
Checking x3 :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> ??
Adding constraint product, x3, x4, xs, ys True, C1, M1, M2 |- {a|_v == x3} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, xs, ys True, C1, M1, M2 |- {a|_v == x3} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, xs, ys |- C1
product, x3, x4, xs, ys |- (match) M2
product, xs, ys |- A1
TYPE ERROR: Cannot match shape 'a'
with shape 'List (Pair (a) (b))'
when checking x3 ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> x3
Trying x4
Checking x4 :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> ??
Adding constraint product, x3, x4, xs, ys True, C1, M1, M2 |- {List a|_v == x4} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, xs, ys True, C1, M1, M2 |- {List a|_v == x4} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, xs, ys |- C1
product, x3, x4, xs, ys |- (match) M2
product, xs, ys |- A1
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> x4
Trying xs
Checking xs :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> ??
Adding constraint product, x3, x4, xs, ys True, C1, M1, M2 |- {List a|_v == xs} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, xs, ys True, C1, M1, M2 |- {List a|_v == xs} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, xs, ys |- C1
product, x3, x4, xs, ys |- (match) M2
product, xs, ys |- A1
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> xs
Trying ys
Checking ys :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> ??
Adding constraint product, x3, x4, xs, ys True, C1, M1, M2 |- {List b|_v == ys} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, xs, ys True, C1, M1, M2 |- {List b|_v == ys} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, xs, ys |- C1
product, x3, x4, xs, ys |- (match) M2
product, xs, ys |- A1
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> ys
Adding constraint product, x3, x4, xs, ys |- A2
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A2|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> ??
Adding constraint product, x3, x4, xs, ys True, C1, M1, M2 |- {List {A2|False}|_v == (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, xs, ys True, C1, M1, M2 |- {List {A2|False}|_v == (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, xs, ys |- A2
product, x3, x4, xs, ys |- C1
product, x3, x4, xs, ys |- (match) M2
product, xs, ys |- A1
UNIFY A2 WITH Pair a b PRODUCING {Pair {a|U3} {b|U4}|U5}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
Simple Constraints
product, xs, ys |- a
product, x3, x4, xs, ys |- (match) M2
product, x3, x4, xs, ys |- C1
product, x3, x4, xs, ys |- {Pair {a|U3} {b|U4}|U5}
product, x3, x4, xs, ys |- {b|U4}
product, x3, x4, xs, ys |- {a|U3}
product, x3, x4, xs, ys True, C1, M1, M2 |- {List|_v == (Nil)} <: {List|len _v == len xs * len ys} ()
product, x3, x4, xs, ys True, C1, M1, M2 |- {Pair|False} <: Pair ()
product, x3, x4, xs, ys True, C1, M1, M2 |- {b|U4} <: b ()
product, x3, x4, xs, ys True, C1, M1, M2 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, xs, ys True, C1, M1, M2 |- {List|len _v == 0} <: {List|len _v == len xs * len ys} ()
Constraints
  C1 && (M1 && (M2 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && len ys >= 0))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (1 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (1 1)
Invalid Constraint: C1 && (M1 && (M2 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && len ys >= 0))))) ==> len _v == len xs * len ys
Strengthening: C1 && (M1 && (M2 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && len ys >= 0))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), len _v == 0, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len x4 >= 0, len xs >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (len _v == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && len ys >= 0)))))
mustHave !(len _v == len xs * len ys)
qualsList [ys == (Nil)]
Optimal valuations:
{ys == (Nil)}
Pruned valuations:
{ys == (Nil)}
Diffs: (1)
[C1 -> {}, M1 -> {}, M2 -> {ys == (Nil)}]
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (2 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (2 0)
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
Simple Constraints
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (2 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (2 0)
Auxiliary goals are:
Match valuation [ys == (Nil)]
Adding constraint product, x3, x4, xs, ys |- A3
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x5:A3 -> x6:List A3 -> {List A3|_v == (Cons x5 x6)}
Matching constructor type
{List A3|_v == (Cons x5 x6)}
with scrutinee
List b
Checking error in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> error
Adding constraint product, x3, x4, x7, x8, xs, ys True, M1, M3 |- {Int|x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys))))} <: {Int|False} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, M1, M3 |- {Int|x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys))))} <: {Int|False} ()
product, x3, x4, xs, ys |- A3
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys True, M1, M3 |- {Int|x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys))))} <: {Int|False} ()
Pred assignment
Constraints
  M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys)))))))))) ==> False
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (2 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}] (2 1)
Invalid Constraint: M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys)))))))))) ==> False
Strengthening: M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys)))))))))) ==> False
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
x3 == x3, x7 == x7, x4 == x4, xs == xs, xs == (Cons x3 x4), x8 == x8, ys == ys, ys == (Cons x7 x8), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: False
assumption True
mustHave x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (xs == (Cons x3 x4) && (x8 == x8 && (ys == ys && (ys == (Cons x7 x8) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))))))
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> error
Adding constraint product, x3, x4, x7, x8, xs, ys |- C2
Looking for type {List Pair a b|len _v == len xs * len ys}
Trying x3
Checking x3 :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
TYPE ERROR: Cannot match shape 'a'
with shape 'List (Pair (a) (b))'
when checking x3 ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> x3
Trying x4
Checking x4 :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> x4
Trying x7
Checking x7 :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
TYPE ERROR: Cannot match shape 'b'
with shape 'List (Pair (a) (b))'
when checking x7 ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> x7
Trying x8
Checking x8 :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> x8
Trying xs
Checking xs :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> xs
Trying ys
Checking ys :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ys
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A4|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A4|False}|_v == (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A4|False}|_v == (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A4 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U6} {b|U7}|U8}
product, x3, x4, x7, x8, xs, ys |- {b|U7}
product, x3, x4, x7, x8, xs, ys |- {a|U6}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 0} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (2 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (2 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Nil ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Nil
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A4 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U6} {b|U7}|U8}
product, x3, x4, x7, x8, xs, ys |- {b|U7}
product, x3, x4, x7, x8, xs, ys |- {a|U6}
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X1 X0)} <: {List|len _v == len xs * len ys} ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && ([_v -> x9]U8 && (_v == (Cons x9 x10) && (len _v == len xs * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Trying x3
Checking x3 :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x3 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons x3 ??
Trying x4
Checking x4 :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A4 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking x4 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons x4 ??
Trying x7
Checking x7 :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x7 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons x7 ??
Trying x8
Checking x8 :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons x8 ??
Trying xs
Checking xs :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A4 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking xs :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons xs ??
Trying ys
Checking ys :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ys ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A5|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A5|False}|_v == (Nil)} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A5|False}|_v == (Nil)} <: A4 ()
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH {a|U6} PRODUCING {a|U9}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Nil :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)}
Trying Pair
Checking Pair :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A5 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
TYPE ERROR: Cannot match shape 'Pair (A4)'
with shape 'List'
when checking Pair ::
X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Pair ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10}
Trying append
Checking append :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A4 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U6} {b|U7}|U8}
product, x3, x4, x7, x8, xs, ys |- {b|U7}
product, x3, x4, x7, x8, xs, ys |- {a|U6}
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X1 + len X0} <: {List|len _v == len xs * len ys} ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X1 + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len x9 + len x10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Trying x3
Checking x3 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A4)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append x3 ??
Trying x4
Checking x4 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append x4 ??
Trying x7
Checking x7 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A4)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append x7 ??
Trying x8
Checking x8 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append x8 ??
Trying xs
Checking xs :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append xs ??
Trying ys
Checking ys :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ys ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A5|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A5|False}|_v == (Nil)} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A5|False}|_v == (Nil)} <: List A4 ()
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U9} {b|U10}|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U9} {b|U10}|U11}
product, x3, x4, x7, x8, xs, ys |- {b|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Nil of type {List {A5|False}|_v == (Nil)}
Checking append
           Nil :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A4 -> {List A4|len _v == len (Nil) + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A4 -> {List A4|len _v == len (Nil) + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A4 -> {List A4|len _v == len (Nil) + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A4 -> {List A4|len _v == len (Nil) + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
Simple Constraints
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len (Nil) + len x10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Trying x3
Checking x3 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A4)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil x3
Trying x4
Checking x4 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil x4
Trying x7
Checking x7 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A4)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil x7
Trying x8
Checking x8 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil x8
Trying xs
Checking xs :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil xs
Trying ys
Checking ys :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ys
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: List A4 ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U12} {b|U13}|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U12} {b|U13}|U14}
product, x3, x4, x7, x8, xs, ys |- {b|U13}
product, x3, x4, x7, x8, xs, ys |- {a|U12}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument Nil of type {List {A6|False}|_v == (Nil)}
Checking append Nil
           Nil :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len (Nil) + len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len (Nil) + len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len (Nil)} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len (Nil)} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil Nil ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil Nil
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x9:(x10:A5 -> A4) -> x11:List A5 -> {List A4|len _v == len x11}
Trying map
Checking map :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:(x10:A5 -> A4) -> x11:List A5 -> {List A4|len _v == len x11} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:(x10:A5 -> A4) -> x11:List A5 -> {List A4|len _v == len x11} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:(x10:A5 -> A4) -> x11:List A5 -> {List A4|len _v == len x11} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:(x10:A5 -> A4) -> x11:List A5 -> {List A4|len _v == len x11} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A4 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U6} {b|U7}|U8}
product, x3, x4, x7, x8, xs, ys |- {b|U7}
product, x3, x4, x7, x8, xs, ys |- {a|U6}
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} /\ {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Checking map
           f0 :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> {List A4|len _v == len x11} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> {List A4|len _v == len x11} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> {List A4|len _v == len x11} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> {List A4|len _v == len x11} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} /\ {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Trying x3
Checking x3 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A5)'
when checking x3 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 x3
Trying x4
Checking x4 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH a PRODUCING {a|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking map f0
           x4 :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len x4} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len x4} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 x4 ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 x4
Trying x7
Checking x7 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A5)'
when checking x7 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 x7
Trying x8
Checking x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH b PRODUCING {b|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking map f0
           x8 :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len x8} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len x8} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 x8 ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 x8
Trying xs
Checking xs :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH a PRODUCING {a|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument xs of type {List a|_v == xs}
Checking map f0
           xs :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len xs} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len xs} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len xs} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len xs} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 xs ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 xs
Trying ys
Checking ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH b PRODUCING {b|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument ys of type {List b|_v == ys}
Checking map f0
           ys :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len ys} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len ys} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 ys ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ys
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Synthesized argument Nil of type {List {A6|False}|_v == (Nil)}
Checking map f0
           Nil :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A4|len _v == len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A6|False} <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil)} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil)} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil), len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) && (len (Nil) == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 Nil ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 Nil
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <a> . <b> . x0:{List a|len _v >= 0 && len _v < len xs} -> ys:List b -> {List Pair a b|len _v == len x0 * len ys}
INTO x9:{List A4|len _v >= 0 && len _v < len xs} -> x10:List A5 -> {List Pair A4 A5|len _v == len x9 * len x10}
Trying product
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A5 -> {List {Pair {A4|False} {A5|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
Checking product :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:{List A4|len _v >= 0 && len _v < len xs} -> x10:List A5 -> {List Pair A4 A5|len _v == len x9 * len x10} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:{List A4|len _v >= 0 && len _v < len xs} -> x10:List A5 -> {List Pair A4 A5|len _v == len x9 * len x10} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:{List A4|len _v >= 0 && len _v < len xs} -> x10:List A5 -> {List Pair A4 A5|len _v == len x9 * len x10} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:{List A4|len _v >= 0 && len _v < len xs} -> x10:List A5 -> {List Pair A4 A5|len _v == len x9 * len x10} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A5 -> {List {Pair {A4|False} {A5|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A4 WITH a PRODUCING {a|U6}
UNIFY A5 WITH b PRODUCING {b|U7}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, x7, x8, xs, ys |- {a|U6}
product, x3, x4, x7, x8, xs, ys |- {b|U7}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: a ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U6} ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X1 * len X0} <: {List|len _v == len xs * len ys} ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 * len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X1 * len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len x9 * len x10 && (len _v == len xs * len ys && (len x4 >= 0 && (len x9 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x9 >= 0 && len x9 < len xs)))))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (3 0)
Trying x3
Checking x3 :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A4|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A4)'
when checking x3 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x3 ??
Trying x4
Checking x4 :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A4|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (5 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking product
           x4 :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len x4 * len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len x4 * len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len x4 * len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len x4 * len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair /\ Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len x4 * len x10 && (len _v == len xs * len ys && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (5 0)
Trying x3
Checking x3 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A5)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 x3
Trying x7
Checking x7 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A5 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A5)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 x7
Trying x8
Checking x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (6 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product x4
           x8 :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A4 A5|len _v == len x4 * len x8} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A4 A5|len _v == len x4 * len x8} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x8} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x8} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (6 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (6 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x4 * len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x4 * len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 x8 ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 x8
Trying xs
Checking xs :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 xs
Trying ys
Checking ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (6 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product x4
           ys :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A4 A5|len _v == len x4 * len ys} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A4 A5|len _v == len x4 * len ys} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len ys} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len ys} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (6 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (6 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x4 * len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x4 * len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 ys ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ys
Trying x4
Checking x4 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 x4
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {b|U7} PRODUCING {b|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U8}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U7} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (5 0)
Synthesized argument Nil of type {List {A6|False}|_v == (Nil)}
Checking product x4
           Nil :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A4 A5|len _v == len x4 * len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A4 A5|len _v == len x4 * len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len (Nil)} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len (Nil)} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x4 * len (Nil), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x4 * len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 Nil ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 Nil
Trying x7
Checking x7 :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A4|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A4)'
when checking x7 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x7 ??
Trying x8
Checking x8 :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A4|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x8 ??
Trying xs
Checking xs :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A4|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (4 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (4 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Strengthening: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
_v == xs, xs == (Cons x3 x4), ys == (Cons x7 x8), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v >= 0 && len _v < len xs
assumption _v == xs && (xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v >= 0 && len _v < len xs)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product xs ??
Trying ys
Checking ys :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A4|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ys ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: {List A4|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {a|U6} PRODUCING {a|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {a|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {a|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U8}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U6} ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 0} <: {List|len _v < len xs && len _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v < len xs && len _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (4 0)
Synthesized argument Nil of type {List {A6|False}|_v == (Nil)}
Checking product
           Nil :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len (Nil) * len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len (Nil) * len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len (Nil) * len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len (Nil) * len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {a|U8}
Simple Constraints
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair /\ Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len (Nil) * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (4 0)
Remaining Candidates (0)
TYPE ERROR: Found inconsistent refinements
when checking product Nil ::
X0:_ -> {List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A4 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U6} {b|U7}|U8}
product, x3, x4, x7, x8, xs, ys |- {b|U7}
product, x3, x4, x7, x8, xs, ys |- {a|U6}
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X1 X0)} <: {List|len _v == len xs * len ys} ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && ([_v -> x9]U8 && (_v == (Cons x9 x10) && (len _v == len xs * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Trying x3
Checking x3 :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x3 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons x3 ??
Trying x4
Checking x4 :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A4 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking x4 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons x4 ??
Trying x7
Checking x7 :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x7 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons x7 ??
Trying x8
Checking x8 :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons x8 ??
Trying xs
Checking xs :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A4 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking xs :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons xs ??
Trying ys
Checking ys :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ys ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A5|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A5|False}|_v == (Nil)} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A5|False}|_v == (Nil)} <: A4 ()
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH {a|U6} PRODUCING {a|U9}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Nil :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)}
Trying Pair
Checking Pair :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A5 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
TYPE ERROR: Cannot match shape 'Pair (A4)'
with shape 'List'
when checking Pair ::
X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Pair ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10}
Trying append
Checking append :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A4 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U6} {b|U7}|U8}
product, x3, x4, x7, x8, xs, ys |- {b|U7}
product, x3, x4, x7, x8, xs, ys |- {a|U6}
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X1 + len X0} <: {List|len _v == len xs * len ys} ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X1 + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len x9 + len x10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Trying x3
Checking x3 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A4)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append x3 ??
Trying x4
Checking x4 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append x4 ??
Trying x7
Checking x7 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A4)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append x7 ??
Trying x8
Checking x8 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append x8 ??
Trying xs
Checking xs :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append xs ??
Trying ys
Checking ys :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ys ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A5|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A5|False}|_v == (Nil)} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A5|False}|_v == (Nil)} <: List A4 ()
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U9} {b|U10}|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U9} {b|U10}|U11}
product, x3, x4, x7, x8, xs, ys |- {b|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Nil of type {List {A5|False}|_v == (Nil)}
Checking append
           Nil :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A4 -> {List A4|len _v == len (Nil) + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A4 -> {List A4|len _v == len (Nil) + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A4 -> {List A4|len _v == len (Nil) + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A4 -> {List A4|len _v == len (Nil) + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
Simple Constraints
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len (Nil) + len x10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x11:A6 -> x12:List A6 -> {List A6|_v == (Cons x11 x12)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (?? ??
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:List A6 -> {List A6|_v == (Cons x11 x12)} <: X3:_ -> X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:List A6 -> {List A6|_v == (Cons x11 x12)} /\ X3:_ -> X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:List A6 -> {List A6|_v == (Cons x11 x12)} /\ X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:List A6 -> {List A6|_v == (Cons x11 x12)} <: X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U12} {b|U13}|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U12} {b|U13}|U14}
product, x3, x4, x7, x8, xs, ys |- {b|U13}
product, x3, x4, x7, x8, xs, ys |- {a|U12}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X3 X2)} <: List ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} <: {Pair|U8} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x11 x12)} /\ List ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} /\ {Pair|U8} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} /\ {b|U7} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Trying x3
Checking x3 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x3 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      x3 ??)
Trying x4
Checking x4 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A6 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking x4 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      x4 ??)
Trying x7
Checking x7 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x7 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      x7 ??)
Trying x8
Checking x8 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      x8 ??)
Trying xs
Checking xs :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A6 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking xs :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      xs ??)
Trying ys
Checking ys :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {a|U12} PRODUCING {a|U15}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Nil :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Cons
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x11:A7 -> x12:A6 -> {Pair A7 A6|_v == (Pair x11 x12)}
Trying Pair
Checking Pair :: X3:_ -> X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (?? ??
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A7 -> x12:A6 -> {Pair A7 A6|_v == (Pair x11 x12)} <: X3:_ -> X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A7 -> x12:A6 -> {Pair A7 A6|_v == (Pair x11 x12)} /\ X3:_ -> X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A7 -> x12:A6 -> {Pair A7 A6|_v == (Pair x11 x12)} /\ X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A7 -> x12:A6 -> {Pair A7 A6|_v == (Pair x11 x12)} <: X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U12} {b|U13}|U14}
TYPE ERROR: Cannot match shape 'Pair (A6)'
with shape 'List'
when checking Pair ::
X3:_ -> X2:_ -> List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (Pair
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x11:(x12:A7 -> A6) -> x13:List A7 -> {List A6|len _v == len x13}
Trying map
Checking map :: X3:_ -> X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (?? ??
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A7 -> A6) -> x13:List A7 -> {List A6|len _v == len x13} <: X3:_ -> X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A7 -> A6) -> x13:List A7 -> {List A6|len _v == len x13} /\ X3:_ -> X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A7 -> A6) -> x13:List A7 -> {List A6|len _v == len x13} /\ X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A7 -> A6) -> x13:List A7 -> {List A6|len _v == len x13} <: X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U12} {b|U13}|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A7
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U12} {b|U13}|U14}
product, x3, x4, x7, x8, xs, ys |- {b|U13}
product, x3, x4, x7, x8, xs, ys |- {a|U12}
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} <: {Pair|U8} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} /\ {Pair|U8} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} /\ {b|U7} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Checking map
           f0 :: X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List A6|len _v == len x13} <: X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List A6|len _v == len x13} /\ X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List A6|len _v == len x13} /\ X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List A6|len _v == len x13} <: X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} <: {Pair|U8} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} /\ {Pair|U8} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} /\ {b|U7} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      x3)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH a PRODUCING {a|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {a|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U15} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U15
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking map f0 x4 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument map f0
                       x4 of type {List A6|len _v == len x4}
Checking append Nil (map f0
                       x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x4}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x4}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {a|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil (map f0
                            x4) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      x4)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      x7)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH b PRODUCING {b|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {b|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U15} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U15
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking map f0 x8 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument map f0
                       x8 of type {List A6|len _v == len x8}
Checking append Nil (map f0
                       x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x8}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x8}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {b|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil (map f0
                            x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      x8)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH a PRODUCING {a|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {a|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U15} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U15
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument xs of type {List a|_v == xs}
Checking map f0 xs :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument map f0
                       xs of type {List A6|len _v == len xs}
Checking append Nil (map f0
                       xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len xs}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len xs}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {a|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil (map f0
                            xs) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      xs)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH b PRODUCING {b|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {b|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U15} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U15
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument ys of type {List b|_v == ys}
Checking map f0 ys :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument map f0
                       ys of type {List A6|len _v == len ys}
Checking append Nil (map f0
                       ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len ys}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len ys}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {b|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil (map f0
                            ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking map f0
           Nil :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil)} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil)} <: List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A8|False} <: A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument map f0
                       Nil of type {List A6|len _v == len (Nil)}
Checking append Nil (map f0
                       Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil)}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil)}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A8|False} <: A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len (Nil), len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) && (len (Nil) == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil (map f0
                            Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (map f0
                                      Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x11:List A6 -> x12:List A6 -> {List A6|len _v == len x11 + len x12}
Trying append
Checking append :: X3:_ -> X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (?? ??
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A6 -> {List A6|len _v == len x11 + len x12} <: X3:_ -> X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A6 -> {List A6|len _v == len x11 + len x12} /\ X3:_ -> X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A6 -> {List A6|len _v == len x11 + len x12} /\ X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A6 -> {List A6|len _v == len x11 + len x12} <: X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U12} {b|U13}|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U12} {b|U13}|U14}
product, x3, x4, x7, x8, xs, ys |- {b|U13}
product, x3, x4, x7, x8, xs, ys |- {a|U12}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X3 + len X2} <: List ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} <: {Pair|U8} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11 + len x12} /\ List ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} /\ {Pair|U8} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} /\ {b|U7} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      x3 ??)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      x4 ??)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      x7 ??)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      x8 ??)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      xs ??)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U12} {b|U13}|U14} PRODUCING {Pair {a|U15} {b|U16}|U17}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {Pair {a|U15} {b|U16}|U17}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {Pair {a|U15} {b|U16}|U17}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U15} {b|U16}|U17}
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys |- {a|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U16} <: {b|U13} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U15} <: {a|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U16 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append
           Nil :: X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len (Nil) + len x12} <: X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len (Nil) + len x12} /\ X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len (Nil) + len x12} /\ X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len (Nil) + len x12} <: X2:_ -> List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {Pair {a|U15} {b|U16}|U17}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} <: {Pair|U8} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x12} /\ List ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} /\ {Pair|U8} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} /\ {b|U7} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil x3)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil x4)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {Pair {a|U12} {b|U13}|U14} PRODUCING {Pair {a|U18} {b|U19}|U20}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {Pair {a|U15} {b|U16}|U17}
A8 -> {Pair {a|U18} {b|U19}|U20}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {Pair {a|U15} {b|U16}|U17}
A8 -> {Pair {a|U18} {b|U19}|U20}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U18} {b|U19}|U20}
product, x3, x4, x7, x8, xs, ys |- {b|U19}
product, x3, x4, x7, x8, xs, ys |- {a|U18}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U19} <: {b|U13} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U18} <: {a|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U19 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
  C2 && (M1 && (M3 && (U18 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking append Nil
           Nil :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len (Nil)} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len (Nil)} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {Pair {a|U15} {b|U16}|U17}
A8 -> {Pair {a|U18} {b|U19}|U20}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U14} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument append Nil
                       Nil of type {List A6|len _v == len (Nil) + len (Nil)}
Checking append Nil (append Nil
                       Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil) + len (Nil)}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil) + len (Nil)}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {Pair {a|U12} {b|U13}|U14}
A7 -> {Pair {a|U15} {b|U16}|U17}
A8 -> {Pair {a|U18} {b|U19}|U20}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len (Nil) + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil (append
                            Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (append
                                      Nil Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . <b> . x0:{List a|len _v >= 0 && len _v < len xs} -> ys:List b -> {List Pair a b|len _v == len x0 * len ys}
INTO x11:{List A6|len _v >= 0 && len _v < len xs} -> x12:List A7 -> {List Pair A6 A7|len _v == len x11 * len x12}
Trying product
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A7 -> {List {Pair {A6|False} {A7|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
Checking product :: X3:_ -> X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (?? ??
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A6|len _v >= 0 && len _v < len xs} -> x12:List A7 -> {List Pair A6 A7|len _v == len x11 * len x12} <: X3:_ -> X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A6|len _v >= 0 && len _v < len xs} -> x12:List A7 -> {List Pair A6 A7|len _v == len x11 * len x12} /\ X3:_ -> X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A6|len _v >= 0 && len _v < len xs} -> x12:List A7 -> {List Pair A6 A7|len _v == len x11 * len x12} /\ X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A6|len _v >= 0 && len _v < len xs} -> x12:List A7 -> {List Pair A6 A7|len _v == len x11 * len x12} <: X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A7 -> {List {Pair {A6|False} {A7|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {a|U6} PRODUCING {a|U12}
UNIFY A7 WITH {b|U7} PRODUCING {b|U13}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U12}
product, x3, x4, x7, x8, xs, ys |- {b|U13}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: a ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U13} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U12} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X3 * len X2} <: List ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11 * len x12} /\ List ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} /\ {b|U7} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U13 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Trying x3
Checking x3 :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A6|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x3 ??)
Trying x4
Checking x4 :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A6|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking product
           x4 :: X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A7 -> {List Pair A6 A7|len _v == len x4 * len x12} <: X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A7 -> {List Pair A6 A7|len _v == len x4 * len x12} /\ X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A7 -> {List Pair A6 A7|len _v == len x4 * len x12} /\ X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A7 -> {List Pair A6 A7|len _v == len x4 * len x12} <: X2:_ -> List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x12} /\ List ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} /\ {b|U7} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U13 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 x3)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 x7)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product x4
           x8 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len x8} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len x8} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument product x4
                       x8 of type {List Pair A6 A7|len _v == len x4 * len x8}
Checking append Nil (product x4
                       x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len x4 * len x8}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len x4 * len x8}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len x4 * len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil
                (product x4 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 x8)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 xs)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product x4
           ys :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len ys} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len ys} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument product x4
                       ys of type {List Pair A6 A7|len _v == len x4 * len ys}
Checking append Nil (product x4
                       ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len x4 * len ys}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len x4 * len ys}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len x4 * len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil
                (product x4 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 ys)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 x4)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {b|U13} PRODUCING {b|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {b|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U13} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking product x4
           Nil :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len (Nil)} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len (Nil)} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument product x4
                       Nil of type {List Pair A6 A7|len _v == len x4 * len (Nil)}
Checking append Nil (product x4
                       Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len x4 * len (Nil)}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len x4 * len (Nil)}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {b|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len x4 * len (Nil), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len x4 * len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil
                (product x4 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x4 Nil)
Trying x7
Checking x7 :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A6|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x7 ??)
Trying x8
Checking x8 :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A6|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product x8 ??)
Trying xs
Checking xs :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A6|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Strengthening: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
_v == xs, xs == (Cons x3 x4), ys == (Cons x7 x8), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v >= 0 && len _v < len xs
assumption _v == xs && (xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v >= 0 && len _v < len xs)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product xs ??)
Trying ys
Checking ys :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A6|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: {List A6|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {a|U12} PRODUCING {a|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U12} ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 0} <: {List|len _v < len xs && len _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v < len xs && len _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking product
           Nil :: X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A7 -> {List Pair A6 A7|len _v == len (Nil) * len x12} <: X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A7 -> {List Pair A6 A7|len _v == len (Nil) * len x12} /\ X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A7 -> {List Pair A6 A7|len _v == len (Nil) * len x12} /\ X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A7 -> {List Pair A6 A7|len _v == len (Nil) * len x12} <: X2:_ -> List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x12} /\ List ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} /\ {b|U7} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U13 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil x3)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil x4)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil x7)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product Nil
           x8 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len x8} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len x8} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument product Nil
                       x8 of type {List Pair A6 A7|len _v == len (Nil) * len x8}
Checking append Nil (product Nil
                       x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len (Nil) * len x8}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len (Nil) * len x8}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len (Nil) * len x8, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil
                (product Nil x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil x8)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil xs)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product Nil
           ys :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len ys} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len ys} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument product Nil
                       ys of type {List Pair A6 A7|len _v == len (Nil) * len ys}
Checking append Nil (product Nil
                       ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len (Nil) * len ys}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len (Nil) * len ys}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len (Nil) * len ys, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil
                (product Nil ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {b|U13} PRODUCING {b|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
A9 -> {b|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
A9 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U13} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking product Nil
           Nil :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len (Nil)} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len (Nil)} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
A9 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U12} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument product Nil
                       Nil of type {List Pair A6 A7|len _v == len (Nil) * len (Nil)}
Checking append Nil (product Nil
                       Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len (Nil) * len (Nil)}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A6 A7|len _v == len (Nil) * len (Nil)}) IN {List A4|len _v == len (Nil) + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {b|U13}
A8 -> {a|U14}
A9 -> {b|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len (Nil) + len x10, len x10 == len (Nil) * len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len (Nil) + len x10 && (len x10 == len (Nil) * len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append Nil
                (product Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append Nil
                          (product Nil Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x9:(x10:A5 -> A4) -> x11:List A5 -> {List A4|len _v == len x11}
Trying map
Checking map :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:(x10:A5 -> A4) -> x11:List A5 -> {List A4|len _v == len x11} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:(x10:A5 -> A4) -> x11:List A5 -> {List A4|len _v == len x11} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:(x10:A5 -> A4) -> x11:List A5 -> {List A4|len _v == len x11} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:(x10:A5 -> A4) -> x11:List A5 -> {List A4|len _v == len x11} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A4 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U6} {b|U7}|U8}
product, x3, x4, x7, x8, xs, ys |- {b|U7}
product, x3, x4, x7, x8, xs, ys |- {a|U6}
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} /\ {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Checking map
           f0 :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> {List A4|len _v == len x11} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> {List A4|len _v == len x11} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> {List A4|len _v == len x11} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> {List A4|len _v == len x11} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} /\ {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x12:A6 -> x13:List A6 -> {List A6|_v == (Cons x12 x13)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A6 -> x13:List A6 -> {List A6|_v == (Cons x12 x13)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A6 -> x13:List A6 -> {List A6|_v == (Cons x12 x13)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A6 -> x13:List A6 -> {List A6|_v == (Cons x12 x13)} /\ X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A6 -> x13:List A6 -> {List A6|_v == (Cons x12 x13)} <: X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X3 X2)} <: List ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x12 x13)} /\ List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Trying x3
Checking x3 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH {a|_v == x3} PRODUCING {a|U9}
UNIFY A5 WITH {a|U9} PRODUCING {a|U10}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (_v == x3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument x3 of type {a|_v == x3}
Checking Cons
           x3 :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x3 x13)} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x3 x13)} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x3 x13)} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x3 x13)} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x3 X2)} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x3 x13)} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking Cons x3
           x4 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x3 x4)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x3 x4)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x3 x4)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Synthesized argument Cons x3
                       x4 of type {List A6|_v == (Cons x3 x4)}
Checking map f0 (Cons x3
                   x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x3 x4)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x3 x4)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x11 == (Cons x3 x4) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 1)
Invalid Constraint: C2 && (M1 && (M3 && (x11 == (Cons x3 x4) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x11 == (Cons x3 x4) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
x11 == (Cons x3 x4), xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption x11 == (Cons x3 x4) && (xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (Cons x3
                        x4) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  x4)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Synthesized argument xs of type {List a|_v == xs}
Checking Cons x3
           xs :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x3 xs)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x3 xs)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x3 xs)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Synthesized argument Cons x3
                       xs of type {List A6|_v == (Cons x3 xs)}
Checking map f0 (Cons x3
                   xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x3 xs)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x3 xs)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x11 == (Cons x3 xs) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 1)
Invalid Constraint: C2 && (M1 && (M3 && (x11 == (Cons x3 xs) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x11 == (Cons x3 xs) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x3 xs)) == 1 + len xs, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
x11 == (Cons x3 xs), xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x3 xs)) == 1 + len xs, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption x11 == (Cons x3 xs) && (xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x3 xs)) == 1 + len xs && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (Cons x3
                        xs) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  ys)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  x3)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {a|U9} PRODUCING {a|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U9} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons x3
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x3 (Nil))} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x3 (Nil))} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x3 (Nil))} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Cons x3
                       Nil of type {List A6|_v == (Cons x3 (Nil))}
Checking map f0 (Cons x3
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x3 (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x3 (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x11 == (Cons x3 (Nil)) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (x11 == (Cons x3 (Nil)) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x11 == (Cons x3 (Nil)) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
x11 == (Cons x3 (Nil)), xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x3 (Nil))) == 1 + len (Nil), len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption x11 == (Cons x3 (Nil)) && (xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x3 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (Cons x3
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x3
                                  Nil)
Trying x4
Checking x4 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH {List a|_v == x4} PRODUCING {List {a|U9}|U10}
UNIFY A5 WITH {List {a|U9}|U10} PRODUCING {List {a|U11}|U12}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {List {a|U11}|U12}
product, x3, x4, x7, x8, xs, ys |- {a|U11}
product, x3, x4, x7, x8, xs, ys |- {List {a|U9}|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U11} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} /\ {List|U12} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U11} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: {List|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
  C2 && (M1 && (M3 && (_v == x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking Cons
           x4 :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x4 x13)} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x4 x13)} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x4 x13)} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x4 x13)} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x4 X2)} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U11} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x4 x13)} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} /\ {List|U12} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  x3)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (a)'
when checking x8 :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (a)'
when checking xs :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (a)'
when checking ys :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  ys)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (a)'
when checking x4 :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  x4)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {List {a|U9}|U10} PRODUCING {List {a|U13}|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
A7 -> {List {a|U13}|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
A7 -> {List {a|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {List {a|U13}|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: {List|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons x4
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x4 (Nil))} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x4 (Nil))} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
A7 -> {List {a|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x4 (Nil))} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument Cons x4
                       Nil of type {List A6|_v == (Cons x4 (Nil))}
Checking map f0 (Cons x4
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x4 (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x4 (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
A7 -> {List {a|U13}|U14}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x11 == (Cons x4 (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (x11 == (Cons x4 (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x11 == (Cons x4 (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x4 (Nil))) == 1 + len (Nil), len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), x11 == (Cons x4 (Nil)), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x4 (Nil))) == 1 + len (Nil), len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x11 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (x11 == (Cons x4 (Nil)) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len ((Cons x4 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (Cons x4
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x4
                                  Nil)
Trying x7
Checking x7 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH {b|_v == x7} PRODUCING {b|U9}
UNIFY A5 WITH {b|U9} PRODUCING {b|U10}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U10}
product, x3, x4, x7, x8, xs, ys |- {b|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (_v == x7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument x7 of type {b|_v == x7}
Checking Cons
           x7 :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x7 x13)} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x7 x13)} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x7 x13)} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x7 x13)} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x7 X2)} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x7 x13)} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  x3)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  x4)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking Cons x7
           x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 x8)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 x8)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x7 x8)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Synthesized argument Cons x7
                       x8 of type {List A6|_v == (Cons x7 x8)}
Checking map f0 (Cons x7
                   x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x7 x8)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x7 x8)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x11 == (Cons x7 x8) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 1)
Invalid Constraint: C2 && (M1 && (M3 && (x11 == (Cons x7 x8) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x11 == (Cons x7 x8) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), x11 == (Cons x7 x8), ys == (Cons x7 x8), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x11 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (x11 == (Cons x7 x8) && (ys == (Cons x7 x8) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (Cons x7
                        x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Synthesized argument ys of type {List b|_v == ys}
Checking Cons x7
           ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 ys)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 ys)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x7 ys)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Synthesized argument Cons x7
                       ys of type {List A6|_v == (Cons x7 ys)}
Checking map f0 (Cons x7
                   ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x7 ys)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x7 ys)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x11 == (Cons x7 ys) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 1)
Invalid Constraint: C2 && (M1 && (M3 && (x11 == (Cons x7 ys) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x11 == (Cons x7 ys) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x7 ys)) == 1 + len ys
All assumptions:
xs == (Cons x3 x4), x11 == (Cons x7 ys), ys == (Cons x7 x8), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x7 ys)) == 1 + len ys, len x4 >= 0, len xs >= 0, len x11 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (x11 == (Cons x7 ys) && (ys == (Cons x7 x8) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len ((Cons x7 ys)) == 1 + len ys && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (Cons x7
                        ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  ys)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  x7)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {b|U9} PRODUCING {b|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U9} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons x7
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 (Nil))} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 (Nil))} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x7 (Nil))} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Cons x7
                       Nil of type {List A6|_v == (Cons x7 (Nil))}
Checking map f0 (Cons x7
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x7 (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x7 (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x11 == (Cons x7 (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (x11 == (Cons x7 (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x11 == (Cons x7 (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x7 (Nil))) == 1 + len (Nil), len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), x11 == (Cons x7 (Nil)), ys == (Cons x7 x8), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x7 (Nil))) == 1 + len (Nil), len (Nil) == 0, len x4 >= 0, len xs >= 0, len x11 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (x11 == (Cons x7 (Nil)) && (ys == (Cons x7 x8) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len ((Cons x7 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (Cons x7
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x7
                                  Nil)
Trying x8
Checking x8 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH {List b|_v == x8} PRODUCING {List {b|U9}|U10}
UNIFY A5 WITH {List {b|U9}|U10} PRODUCING {List {b|U11}|U12}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {List {b|U11}|U12}
product, x3, x4, x7, x8, xs, ys |- {b|U11}
product, x3, x4, x7, x8, xs, ys |- {List {b|U9}|U10}
product, x3, x4, x7, x8, xs, ys |- {b|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U11} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} /\ {List|U12} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U11} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: {List|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
  C2 && (M1 && (M3 && (_v == x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking Cons
           x8 :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x8 x13)} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x8 x13)} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x8 x13)} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons x8 x13)} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x8 X2)} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U11} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x8 x13)} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} /\ {List|U12} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  x3)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (b)'
when checking x4 :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  x4)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  x7)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (b)'
when checking xs :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (b)'
when checking ys :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  ys)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (b)'
when checking x8 :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  x8)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {List {b|U9}|U10} PRODUCING {List {b|U13}|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
A7 -> {List {b|U13}|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
A7 -> {List {b|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {List {b|U13}|U14}
product, x3, x4, x7, x8, xs, ys |- {b|U13}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: {List|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons x8
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x8 (Nil))} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x8 (Nil))} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
A7 -> {List {b|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x8 (Nil))} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument Cons x8
                       Nil of type {List A6|_v == (Cons x8 (Nil))}
Checking map f0 (Cons x8
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x8 (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons x8 (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
A7 -> {List {b|U13}|U14}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x11 == (Cons x8 (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (x11 == (Cons x8 (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x11 == (Cons x8 (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x8 (Nil))) == 1 + len (Nil), len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), x11 == (Cons x8 (Nil)), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x8 (Nil))) == 1 + len (Nil), len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x11 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (x11 == (Cons x8 (Nil)) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len ((Cons x8 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (Cons x8
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons x8
                                  Nil)
Trying xs
Checking xs :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH {List a|_v == xs} PRODUCING {List {a|U9}|U10}
UNIFY A5 WITH {List {a|U9}|U10} PRODUCING {List {a|U11}|U12}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {List {a|U11}|U12}
product, x3, x4, x7, x8, xs, ys |- {a|U11}
product, x3, x4, x7, x8, xs, ys |- {List {a|U9}|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U11} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} /\ {List|U12} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U11} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: {List|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
  C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument xs of type {List a|_v == xs}
Checking Cons
           xs :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons xs x13)} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons xs x13)} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons xs x13)} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons xs x13)} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons xs X2)} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U11} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons xs x13)} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} /\ {List|U12} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  x3)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (a)'
when checking x4 :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  x4)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (a)'
when checking x8 :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  x8)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (a)'
when checking ys :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  ys)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (a)'
when checking xs :: List List a
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  xs)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {List {a|U9}|U10} PRODUCING {List {a|U13}|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
A7 -> {List {a|U13}|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
A7 -> {List {a|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {List {a|U13}|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: {List|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons xs
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons xs (Nil))} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons xs (Nil))} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
A7 -> {List {a|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons xs (Nil))} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument Cons xs
                       Nil of type {List A6|_v == (Cons xs (Nil))}
Checking map f0 (Cons xs
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons xs (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons xs (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {a|U11}|U12}
A6 -> {List {a|U9}|U10}
A7 -> {List {a|U13}|U14}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x11 == (Cons xs (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (x11 == (Cons xs (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x11 == (Cons xs (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons xs (Nil))) == 1 + len (Nil), len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), x11 == (Cons xs (Nil)), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons xs (Nil))) == 1 + len (Nil), len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x11 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (x11 == (Cons xs (Nil)) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len ((Cons xs (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (Cons xs
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons xs
                                  Nil)
Trying ys
Checking ys :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH {List b|_v == ys} PRODUCING {List {b|U9}|U10}
UNIFY A5 WITH {List {b|U9}|U10} PRODUCING {List {b|U11}|U12}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {List {b|U11}|U12}
product, x3, x4, x7, x8, xs, ys |- {b|U11}
product, x3, x4, x7, x8, xs, ys |- {List {b|U9}|U10}
product, x3, x4, x7, x8, xs, ys |- {b|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U11} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} /\ {List|U12} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U11} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: {List|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
  C2 && (M1 && (M3 && (_v == ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument ys of type {List b|_v == ys}
Checking Cons
           ys :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons ys x13)} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons ys x13)} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons ys x13)} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons ys x13)} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons ys X2)} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U11} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons ys x13)} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} /\ {List|U12} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  x3)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (b)'
when checking x4 :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  x4)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (b)'
when checking x8 :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (b)'
when checking xs :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (b)'
when checking ys :: List List b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {List {b|U9}|U10} PRODUCING {List {b|U13}|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
A7 -> {List {b|U13}|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
A7 -> {List {b|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {List {b|U13}|U14}
product, x3, x4, x7, x8, xs, ys |- {b|U13}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: {List|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U13} <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons ys
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons ys (Nil))} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons ys (Nil))} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
A7 -> {List {b|U13}|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons ys (Nil))} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U10} <: {List|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument Cons ys
                       Nil of type {List A6|_v == (Cons ys (Nil))}
Checking map f0 (Cons ys
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons ys (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons ys (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List {b|U11}|U12}
A6 -> {List {b|U9}|U10}
A7 -> {List {b|U13}|U14}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x11 == (Cons ys (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (x11 == (Cons ys (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x11 == (Cons ys (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons ys (Nil))) == 1 + len (Nil), len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), x11 == (Cons ys (Nil)), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons ys (Nil))) == 1 + len (Nil), len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x11 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (x11 == (Cons ys (Nil)) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len ((Cons ys (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (Cons ys
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ys
                                  Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH {List {A7|False}|_v == (Nil)} PRODUCING {List A8|U9}
UNIFY A5 WITH {List A8|U9} PRODUCING {List A9|U10}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List A9|U10}
A6 -> {List A8|U9}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List A9|U10}
A6 -> {List A8|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {List A9|U10}
product, x3, x4, x7, x8, xs, ys |- {List A8|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U9} <: {List|U10} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U9} /\ {List|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: {List|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (_v == (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons
           Nil :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons (Nil) x13)} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons (Nil) x13)} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons (Nil) x13)} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|_v == (Cons (Nil) x13)} <: X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List A9|U10}
A6 -> {List A8|U9}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons (Nil) X2)} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U9} <: {List|U10} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons (Nil) x13)} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U9} /\ {List|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List List A8
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  x3)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x4 :: List List A8
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  x4)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List List A8
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x8 :: List List A8
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking xs :: List List A8
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking ys :: List List A8
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A10
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
UNIFY A10 WITH {List A8|U9} PRODUCING {List A11|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {List A11|U11}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List A9|U10}
A6 -> {List A8|U9}
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A9
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A11
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A11 <: A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {List A11|U11}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List A9|U10}
A6 -> {List A8|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {List A11|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: {List|U9} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
  U11 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Nil of type {List {A10|False}|_v == (Nil)}
Checking Cons Nil
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons (Nil) (Nil))} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons (Nil) (Nil))} <: List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A9
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A11
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A11 <: A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {List A11|U11}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List A9|U10}
A6 -> {List A8|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons (Nil) (Nil))} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|U9} <: {List|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
  U11 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Cons Nil
                       Nil of type {List A6|_v == (Cons (Nil) (Nil))}
Checking map f0 (Cons Nil
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons (Nil) (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|_v == (Cons (Nil) (Nil))}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A9
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 <: A9 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A8 /\ A9 ()
product, x3, x4, x7, x8, xs, ys |- A11
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A11 <: A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {List A11|U11}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {List A9|U10}
A6 -> {List A8|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x11 == (Cons (Nil) (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
  U11 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {len _v == len ys * len xs, len _v == len x8 * len x4, len _v == len xs * len x4, len _v == len xs * len x8, len _v == len ys * len x4, len _v == len ys * len x8}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (x11 == (Cons (Nil) (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x11 == (Cons (Nil) (Nil)) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len ((Cons (Nil) (Nil))) == 1 + len (Nil)
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), x11 == (Cons (Nil) (Nil)), len _v == len x11, len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len ((Cons (Nil) (Nil))) == 1 + len (Nil), len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x11 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (x11 == (Cons (Nil) (Nil)) && (len _v == len x11 && (len (Nil) == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len ((Cons (Nil) (Nil))) == 1 + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (Cons Nil
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Cons Nil
                                  Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x12:A7 -> x13:A6 -> {Pair A7 A6|_v == (Pair x12 x13)}
Trying Pair
Checking Pair :: X3:_ -> X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A7 -> x13:A6 -> {Pair A7 A6|_v == (Pair x12 x13)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A7 -> x13:A6 -> {Pair A7 A6|_v == (Pair x12 x13)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A7 -> x13:A6 -> {Pair A7 A6|_v == (Pair x12 x13)} /\ X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A7 -> x13:A6 -> {Pair A7 A6|_v == (Pair x12 x13)} <: X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
TYPE ERROR: Cannot match shape 'Pair (A6)'
with shape 'List'
when checking Pair ::
X3:_ -> X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (Pair ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x12:List A6 -> x13:List A6 -> {List A6|len _v == len x12 + len x13}
Trying append
Checking append :: X3:_ -> X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> x13:List A6 -> {List A6|len _v == len x12 + len x13} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> x13:List A6 -> {List A6|len _v == len x12 + len x13} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> x13:List A6 -> {List A6|len _v == len x12 + len x13} /\ X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> x13:List A6 -> {List A6|len _v == len x12 + len x13} <: X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X3 + len X2} <: List ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x12 + len x13} /\ List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x3
                                  ??)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH a PRODUCING {a|U9}
UNIFY A5 WITH {a|U9} PRODUCING {a|U10}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking append
           x4 :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len x4 + len x13} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len x4 + len x13} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len x4 + len x13} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len x4 + len x13} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 + len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 + len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  x3)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument xs of type {List a|_v == xs}
Checking append x4
           xs :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4 + len xs} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4 + len xs} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 + len xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append x4
                       xs of type {List A6|len _v == len x4 + len xs}
Checking map f0 (append x4
                   xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x4 + len xs}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x4 + len xs}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len x4 + len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len x4 + len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len x4 + len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len x4 + len xs, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len x4 + len xs && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append x4
                        xs) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  ys)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking append x4
           x4 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4 + len x4} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4 + len x4} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 + len x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append x4
                       x4 of type {List A6|len _v == len x4 + len x4}
Checking map f0 (append x4
                   x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x4 + len x4}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x4 + len x4}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len x4 + len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len x4 + len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len x4 + len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len x4 + len x4, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len x4 + len x4 && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append x4
                        x4) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  x4)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {a|U9} PRODUCING {a|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U9} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append x4
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4 + len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4 + len (Nil)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 + len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append x4
                       Nil of type {List A6|len _v == len x4 + len (Nil)}
Checking map f0 (append x4
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x4 + len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x4 + len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len x4 + len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len x4 + len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len x4 + len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len x4 + len (Nil), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len x4 + len (Nil) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append x4
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x4
                                  Nil)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x7
                                  ??)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH b PRODUCING {b|U9}
UNIFY A5 WITH {b|U9} PRODUCING {b|U10}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U10}
product, x3, x4, x7, x8, xs, ys |- {b|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking append
           x8 :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len x8 + len x13} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len x8 + len x13} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len x8 + len x13} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len x8 + len x13} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8 + len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8 + len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  x3)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  x4)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  x7)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument ys of type {List b|_v == ys}
Checking append x8
           ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len ys} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8 + len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append x8
                       ys of type {List A6|len _v == len x8 + len ys}
Checking map f0 (append x8
                   ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x8 + len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x8 + len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len x8 + len ys && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len x8 + len ys && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len x8 + len ys && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len x8 + len ys, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x11 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len x8 + len ys && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append x8
                        ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  ys)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking append x8
           x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len x8} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8 + len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append x8
                       x8 of type {List A6|len _v == len x8 + len x8}
Checking map f0 (append x8
                   x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x8 + len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x8 + len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len x8 + len x8 && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len x8 + len x8 && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len x8 + len x8 && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len x8 + len x8, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x11 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len x8 + len x8 && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append x8
                        x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  x8)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {b|U9} PRODUCING {b|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U9} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append x8
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len (Nil)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8 + len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append x8
                       Nil of type {List A6|len _v == len x8 + len (Nil)}
Checking map f0 (append x8
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x8 + len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x8 + len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len x8 + len (Nil) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len x8 + len (Nil) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len x8 + len (Nil) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len x8 + len (Nil), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x11 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len x8 + len (Nil) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append x8
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append x8
                                  Nil)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH a PRODUCING {a|U9}
UNIFY A5 WITH {a|U9} PRODUCING {a|U10}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument xs of type {List a|_v == xs}
Checking append
           xs :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len xs + len x13} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len xs + len x13} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len xs + len x13} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len xs + len x13} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len xs + len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len xs + len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  x3)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking append xs
           x4 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs + len x4} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs + len x4} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len xs + len x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append xs
                       x4 of type {List A6|len _v == len xs + len x4}
Checking map f0 (append xs
                   x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len xs + len x4}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len xs + len x4}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len xs + len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len xs + len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len xs + len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len xs + len x4, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len xs + len x4 && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append xs
                        x4) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  x4)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  x8)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: List a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  ys)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument xs of type {List a|_v == xs}
Checking append xs
           xs :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs + len xs} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs + len xs} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len xs + len xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append xs
                       xs of type {List A6|len _v == len xs + len xs}
Checking map f0 (append xs
                   xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len xs + len xs}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len xs + len xs}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len xs + len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len xs + len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len xs + len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len xs + len xs, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len xs + len xs && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append xs
                        xs) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  xs)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {a|U9} PRODUCING {a|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U9} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append xs
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs + len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs + len (Nil)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len xs + len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append xs
                       Nil of type {List A6|len _v == len xs + len (Nil)}
Checking map f0 (append xs
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len xs + len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len xs + len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len xs + len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len xs + len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len xs + len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len xs + len (Nil), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len xs + len (Nil) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append xs
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append xs
                                  Nil)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH b PRODUCING {b|U9}
UNIFY A5 WITH {b|U9} PRODUCING {b|U10}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U10}
product, x3, x4, x7, x8, xs, ys |- {b|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument ys of type {List b|_v == ys}
Checking append
           ys :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len ys + len x13} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len ys + len x13} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len ys + len x13} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len ys + len x13} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys + len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys + len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  x3)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  x4)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking append ys
           x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len x8} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys + len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append ys
                       x8 of type {List A6|len _v == len ys + len x8}
Checking map f0 (append ys
                   x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len ys + len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len ys + len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len ys + len x8 && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len ys + len x8 && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len ys + len x8 && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len ys + len x8, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x11 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len ys + len x8 && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append ys
                        x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument ys of type {List b|_v == ys}
Checking append ys
           ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len ys} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys + len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append ys
                       ys of type {List A6|len _v == len ys + len ys}
Checking map f0 (append ys
                   ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len ys + len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len ys + len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len ys + len ys && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len ys + len ys && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len ys + len ys && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len ys + len ys, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x11 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len ys + len ys && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append ys
                        ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {b|U9} PRODUCING {b|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U9} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append ys
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len (Nil)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys + len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append ys
                       Nil of type {List A6|len _v == len ys + len (Nil)}
Checking map f0 (append ys
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len ys + len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len ys + len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len ys + len (Nil) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len ys + len (Nil) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len ys + len (Nil) && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len ys + len (Nil), len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x11 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len ys + len (Nil) && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append ys
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ys
                                  Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append
           Nil :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len (Nil) + len x13} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len (Nil) + len x13} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len (Nil) + len x13} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A6|len _v == len (Nil) + len x13} <: X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X2} <: List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x13} /\ List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  x3)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH a PRODUCING {a|U9}
UNIFY A5 WITH {a|U9} PRODUCING {a|U10}
UNIFY A7 WITH {a|U9} PRODUCING {a|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U10} ()
product, x3, x4, x7, x8, xs, ys |- {a|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U9} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking append Nil
           x4 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len x4} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len x4} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append Nil
                       x4 of type {List A6|len _v == len (Nil) + len x4}
Checking map f0 (append Nil
                   x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil) + len x4}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil) + len x4}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len (Nil) + len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len (Nil) + len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len (Nil) + len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len (Nil) + len x4, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len (Nil) + len x4 && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append Nil
                        x4) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  x4)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH b PRODUCING {b|U9}
UNIFY A5 WITH {b|U9} PRODUCING {b|U10}
UNIFY A7 WITH {b|U9} PRODUCING {b|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U10}
product, x3, x4, x7, x8, xs, ys |- {b|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U10} ()
product, x3, x4, x7, x8, xs, ys |- {b|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U9} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking append Nil
           x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len x8} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append Nil
                       x8 of type {List A6|len _v == len (Nil) + len x8}
Checking map f0 (append Nil
                   x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil) + len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil) + len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len (Nil) + len x8 && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len (Nil) + len x8 && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len (Nil) + len x8 && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len (Nil) + len x8, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x11 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len (Nil) + len x8 && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append Nil
                        x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH a PRODUCING {a|U9}
UNIFY A5 WITH {a|U9} PRODUCING {a|U10}
UNIFY A7 WITH {a|U9} PRODUCING {a|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U10} ()
product, x3, x4, x7, x8, xs, ys |- {a|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U9} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument xs of type {List a|_v == xs}
Checking append Nil
           xs :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len xs} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len xs} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append Nil
                       xs of type {List A6|len _v == len (Nil) + len xs}
Checking map f0 (append Nil
                   xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil) + len xs}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil) + len xs}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {a|U10}
A6 -> {a|U9}
A7 -> {a|U11}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len (Nil) + len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len (Nil) + len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len (Nil) + len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len (Nil) + len xs, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len (Nil) + len xs && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append Nil
                        xs) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH b PRODUCING {b|U9}
UNIFY A5 WITH {b|U9} PRODUCING {b|U10}
UNIFY A7 WITH {b|U9} PRODUCING {b|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U10}
product, x3, x4, x7, x8, xs, ys |- {b|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U10} ()
product, x3, x4, x7, x8, xs, ys |- {b|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U9} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} /\ {b|U10} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U10 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument ys of type {List b|_v == ys}
Checking append Nil
           ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len ys} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U9} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 0)
Synthesized argument append Nil
                       ys of type {List A6|len _v == len (Nil) + len ys}
Checking map f0 (append Nil
                   ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil) + len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil) + len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {b|U9}
A7 -> {b|U11}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len (Nil) + len ys && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len (Nil) + len ys && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len (Nil) + len ys && (len _v == len x11 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len (Nil) + len ys, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x11 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len (Nil) + len ys && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x11 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append Nil
                        ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking append Nil
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len (Nil)} <: List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A8|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Synthesized argument append Nil
                       Nil of type {List A6|len _v == len (Nil) + len (Nil)}
Checking map f0 (append Nil
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil) + len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil) + len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A8|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A7|False} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len (Nil) + len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len (Nil) + len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len (Nil) + len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len (Nil) + len (Nil), len _v == len x11, len (Nil) == 0, len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len (Nil) + len (Nil) && (len _v == len x11 && (len (Nil) == 0 && (len (Nil) == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (append Nil
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (append Nil
                                  Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x12:(x13:A7 -> A6) -> x14:List A7 -> {List A6|len _v == len x14}
Trying map
Checking map :: X3:_ -> X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:(x13:A7 -> A6) -> x14:List A7 -> {List A6|len _v == len x14} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:(x13:A7 -> A6) -> x14:List A7 -> {List A6|len _v == len x14} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:(x13:A7 -> A6) -> x14:List A7 -> {List A6|len _v == len x14} /\ X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:(x13:A7 -> A6) -> x14:List A7 -> {List A6|len _v == len x14} <: X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X2} <: List ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x14} /\ List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Checking map
           f1 :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> {List A6|len _v == len x14} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> {List A6|len _v == len x14} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> {List A6|len _v == len x14} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> {List A6|len _v == len x14} <: X2:_ -> List A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X2} <: List ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x14} /\ List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 x3)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A7 WITH a PRODUCING {a|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {a|U9}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking map f1 x4 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument map f1
                       x4 of type {List A6|len _v == len x4}
Checking map f0 (map f1
                   x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x4}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x4}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {a|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len x4 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len x4, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len x4 && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (map f1 x4)
::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 x4)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 x7)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A7 WITH b PRODUCING {b|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {b|U9}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking map f1 x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument map f1
                       x8 of type {List A6|len _v == len x8}
Checking map f0 (map f1
                   x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {b|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len x8 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len x8 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len x8 && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len x8, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len x8 && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (map f1 x8)
::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 x8)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A7 WITH a PRODUCING {a|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {a|U9}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument xs of type {List a|_v == xs}
Checking map f1 xs :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len xs} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument map f1
                       xs of type {List A6|len _v == len xs}
Checking map f0 (map f1
                   xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len xs}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len xs}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {a|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len xs && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len xs, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len xs && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (map f1 xs)
::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 xs)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A7 WITH b PRODUCING {b|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {b|U9}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument ys of type {List b|_v == ys}
Checking map f1 ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys} <: List A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 0)
Synthesized argument map f1
                       ys of type {List A6|len _v == len ys}
Checking map f0 (map f1
                   ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A6
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A7 -> {b|U9}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len ys && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (4 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len ys && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len ys && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len ys, len _v == len x11, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len ys && (len _v == len x11 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (map f1 ys)
::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking map f1
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil)} <: List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A8|False} <: A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Synthesized argument map f1
                       Nil of type {List A6|len _v == len (Nil)}
Checking map f0 (map f1
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List A6|len _v == len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A8|False} <: A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x14, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A5 ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x11 == len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x11 == len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x11 == len (Nil) && (len _v == len x11 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x11 == len (Nil), len _v == len x11, len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x11 >= 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x11 == len (Nil) && (len _v == len x11 && (len (Nil) == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x11 >= 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (map f1
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (map f1
                                  Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . <b> . x0:{List a|len _v >= 0 && len _v < len xs} -> ys:List b -> {List Pair a b|len _v == len x0 * len ys}
INTO x12:{List A6|len _v >= 0 && len _v < len xs} -> x13:List A7 -> {List Pair A6 A7|len _v == len x12 * len x13}
Trying product
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> x13:List A7 -> {List {Pair {A6|False} {A7|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
Checking product :: X3:_ -> X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:{List A6|len _v >= 0 && len _v < len xs} -> x13:List A7 -> {List Pair A6 A7|len _v == len x12 * len x13} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:{List A6|len _v >= 0 && len _v < len xs} -> x13:List A7 -> {List Pair A6 A7|len _v == len x12 * len x13} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:{List A6|len _v >= 0 && len _v < len xs} -> x13:List A7 -> {List Pair A6 A7|len _v == len x12 * len x13} /\ X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:{List A6|len _v >= 0 && len _v < len xs} -> x13:List A7 -> {List Pair A6 A7|len _v == len x12 * len x13} <: X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> x13:List A7 -> {List {Pair {A6|False} {A7|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH Pair A6 A7 PRODUCING {Pair A8 A9|U9}
UNIFY A6 WITH {a|False} PRODUCING {a|U10}
UNIFY A7 WITH {b|False} PRODUCING {b|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A7 <: A9 ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 <: A8 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A7 /\ A9 ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- A6 /\ A8 ()
UNIFY A9 WITH {b|U11} PRODUCING {b|U12}
UNIFY A8 WITH {a|U10} PRODUCING {a|U13}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A9
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U12}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} /\ {a|U13} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} /\ {b|U12} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} <: {a|U13} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} <: {b|U12} ()
product, x3, x4, x7, x8, xs, ys |- {Pair A8 A9|U9}
product, x3, x4, x7, x8, xs, ys |- {a|U10}
product, x3, x4, x7, x8, xs, ys |- {b|U11}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: a ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U11} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U10} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X3 * len X2} <: List ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U9} ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x12 * len x13} /\ List ()
product, x12, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U10 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Trying x3
Checking x3 :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A6|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x3
                                  ??)
Trying x4
Checking x4 :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A6|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking product
           x4 :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List Pair A6 A7|len _v == len x4 * len x13} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List Pair A6 A7|len _v == len x4 * len x13} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List Pair A6 A7|len _v == len x4 * len x13} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List Pair A6 A7|len _v == len x4 * len x13} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U9} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} <: {b|U12} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} <: {a|U13} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U9} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} /\ {b|U12} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} /\ {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U11 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U10 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  x3)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  x7)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product x4
           x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len x8} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U9} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} <: {b|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument product x4
                       x8 of type {List Pair A6 A7|len _v == len x4 * len x8}
Checking map f0 (product x4
                   x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len x4 * len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len x4 * len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x11, len x11 == len x4 * len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x11 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x11 && (len x11 == len x4 * len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (product x4
                        x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  x8)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  xs)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product x4
           ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len ys} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U9} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} <: {b|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument product x4
                       ys of type {List Pair A6 A7|len _v == len x4 * len ys}
Checking map f0 (product x4
                   ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len x4 * len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len x4 * len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x11, len x11 == len x4 * len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x11 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x11 && (len x11 == len x4 * len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (product x4
                        ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  ys)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  x4)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A10
UNIFY A10 WITH {b|U11} PRODUCING {b|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U11} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument Nil of type {List {A10|False}|_v == (Nil)}
Checking product x4
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len x4 * len (Nil)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U9} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} <: {b|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument product x4
                       Nil of type {List Pair A6 A7|len _v == len x4 * len (Nil)}
Checking map f0 (product x4
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len x4 * len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len x4 * len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x11, len x11 == len x4 * len (Nil), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x11 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x11 && (len x11 == len x4 * len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (product x4
                        Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x4
                                  Nil)
Trying x7
Checking x7 :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A6|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x7
                                  ??)
Trying x8
Checking x8 :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A6|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product x8
                                  ??)
Trying xs
Checking xs :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A6|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Strengthening: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
_v == xs, xs == (Cons x3 x4), ys == (Cons x7 x8), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v >= 0 && len _v < len xs
assumption _v == xs && (xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v >= 0 && len _v < len xs)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product xs
                                  ??)
Trying ys
Checking ys :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A6|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product ys
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List A6|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product ??
                                  ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: {List A6|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: {List A6|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys |- A10
UNIFY A10 WITH {a|U10} PRODUCING {a|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U10} ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 0} <: {List|len _v < len xs && len _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v < len xs && len _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument Nil of type {List {A10|False}|_v == (Nil)}
Checking product
           Nil :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List Pair A6 A7|len _v == len (Nil) * len x13} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List Pair A6 A7|len _v == len (Nil) * len x13} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List Pair A6 A7|len _v == len (Nil) * len x13} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List Pair A6 A7|len _v == len (Nil) * len x13} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U9} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} <: {b|U12} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} <: {a|U13} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U9} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} /\ {b|U12} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} /\ {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U11 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U10 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil x3)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil x4)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil x7)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product Nil
           x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len x8} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U9} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} <: {b|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument product Nil
                       x8 of type {List Pair A6 A7|len _v == len (Nil) * len x8}
Checking map f0 (product Nil
                   x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len (Nil) * len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len (Nil) * len x8}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len (Nil) * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len (Nil) * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len (Nil) * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x11, len x11 == len (Nil) * len x8, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x11 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x11 && (len x11 == len (Nil) * len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (product
                        Nil x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil x8)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil xs)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product Nil
           ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len ys} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U9} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} <: {b|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument product Nil
                       ys of type {List Pair A6 A7|len _v == len (Nil) * len ys}
Checking map f0 (product Nil
                   ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len (Nil) * len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len (Nil) * len ys}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len (Nil) * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len (Nil) * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len (Nil) * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x11, len x11 == len (Nil) * len ys, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x11 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x11 && (len x11 == len (Nil) * len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (product
                        Nil ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A11
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A11|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A11|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A11|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A11
UNIFY A11 WITH {b|U11} PRODUCING {b|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A11 -> {b|U15}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A11 -> {b|U15}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U11} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument Nil of type {List {A11|False}|_v == (Nil)}
Checking product Nil
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A6 A7|len _v == len (Nil) * len (Nil)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A11 -> {b|U15}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U9} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U11} <: {b|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U10} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument product Nil
                       Nil of type {List Pair A6 A7|len _v == len (Nil) * len (Nil)}
Checking map f0 (product Nil
                   Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len (Nil) * len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x11:({List Pair A6 A7|len _v == len (Nil) * len (Nil)}) IN {List A4|len _v == len x11} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U14}
A11 -> {b|U15}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair A8 A9|U9}
A6 -> {a|U10}
A7 -> {b|U11}
A8 -> {a|U13}
A9 -> {b|U12}
Simple Constraints
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x11, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len (Nil) * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len (Nil) * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x11 && (len x11 == len (Nil) * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x11, len x11 == len (Nil) * len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x11 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x11 && (len x11 == len (Nil) * len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x11 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking map f0 (product
                        Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> map f0 (product
                                  Nil Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <a> . <b> . x0:{List a|len _v >= 0 && len _v < len xs} -> ys:List b -> {List Pair a b|len _v == len x0 * len ys}
INTO x9:{List A4|len _v >= 0 && len _v < len xs} -> x10:List A5 -> {List Pair A4 A5|len _v == len x9 * len x10}
Trying product
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A5 -> {List {Pair {A4|False} {A5|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
Checking product :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:{List A4|len _v >= 0 && len _v < len xs} -> x10:List A5 -> {List Pair A4 A5|len _v == len x9 * len x10} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:{List A4|len _v >= 0 && len _v < len xs} -> x10:List A5 -> {List Pair A4 A5|len _v == len x9 * len x10} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:{List A4|len _v >= 0 && len _v < len xs} -> x10:List A5 -> {List Pair A4 A5|len _v == len x9 * len x10} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:{List A4|len _v >= 0 && len _v < len xs} -> x10:List A5 -> {List Pair A4 A5|len _v == len x9 * len x10} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A5 -> {List {Pair {A4|False} {A5|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A4 WITH a PRODUCING {a|U6}
UNIFY A5 WITH b PRODUCING {b|U7}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, x7, x8, xs, ys |- {a|U6}
product, x3, x4, x7, x8, xs, ys |- {b|U7}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: a ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U6} ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X1 * len X0} <: {List|len _v == len xs * len ys} ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 * len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X1 * len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len x9 * len x10 && (len _v == len xs * len ys && (len x4 >= 0 && (len x9 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x9 >= 0 && len x9 < len xs)))))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (3 0)
Trying x3
Checking x3 :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A4|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A4)'
when checking x3 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x3 ??
Trying x4
Checking x4 :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A4|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (5 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking product
           x4 :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len x4 * len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len x4 * len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len x4 * len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len x4 * len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair /\ Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len x4 * len x10 && (len _v == len xs * len ys && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (5 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (5 0)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x11:A6 -> x12:List A6 -> {List A6|_v == (Cons x11 x12)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (?? ??
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:List A6 -> {List A6|_v == (Cons x11 x12)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:List A6 -> {List A6|_v == (Cons x11 x12)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:List A6 -> {List A6|_v == (Cons x11 x12)} /\ X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:List A6 -> {List A6|_v == (Cons x11 x12)} <: X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {b|U7} PRODUCING {b|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U8}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X3 X2)} <: List ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x11 x12)} /\ List ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} /\ {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U7 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Trying x3
Checking x3 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x3 :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x3 ??)
Trying x7
Checking x7 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {b|U8} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Synthesized argument x7 of type {b|_v == x7}
Checking Cons
           x7 :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|_v == (Cons x7 x12)} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|_v == (Cons x7 x12)} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|_v == (Cons x7 x12)} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|_v == (Cons x7 x12)} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x7 X2)} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x7 x12)} /\ List ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} /\ {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U7 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 x3)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U8} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking Cons x7
           x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 x8)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 x8)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x7 x8)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 0)
Synthesized argument Cons x7
                       x8 of type {List A6|_v == (Cons x7 x8)}
Checking product x4 (Cons x7
                       x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|_v == (Cons x7 x8)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|_v == (Cons x7 x8)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x10 == (Cons x7 x8) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 == (Cons x7 x8) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x10 == (Cons x7 x8) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), x10 == (Cons x7 x8), ys == (Cons x7 x8), len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (x10 == (Cons x7 x8) && (ys == (Cons x7 x8) && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (Cons
                            x7 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U8} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 0)
Synthesized argument ys of type {List b|_v == ys}
Checking Cons x7
           ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 ys)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 ys)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x7 ys)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 0)
Synthesized argument Cons x7
                       ys of type {List A6|_v == (Cons x7 ys)}
Checking product x4 (Cons x7
                       ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|_v == (Cons x7 ys)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|_v == (Cons x7 ys)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x10 == (Cons x7 ys) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 == (Cons x7 ys) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x10 == (Cons x7 ys) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x7 ys)) == 1 + len ys
All assumptions:
xs == (Cons x3 x4), x10 == (Cons x7 ys), ys == (Cons x7 x8), len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x7 ys)) == 1 + len ys, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (x10 == (Cons x7 ys) && (ys == (Cons x7 x8) && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len ((Cons x7 ys)) == 1 + len ys && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (Cons
                            x7 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 ys)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 x4)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 x7)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {b|U8} PRODUCING {b|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U8} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons x7
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 (Nil))} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|_v == (Cons x7 (Nil))} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x7 (Nil))} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument Cons x7
                       Nil of type {List A6|_v == (Cons x7 (Nil))}
Checking product x4 (Cons x7
                       Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|_v == (Cons x7 (Nil))}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|_v == (Cons x7 (Nil))}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (x10 == (Cons x7 (Nil)) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 == (Cons x7 (Nil)) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (x10 == (Cons x7 (Nil)) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x7 (Nil))) == 1 + len (Nil), len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), x10 == (Cons x7 (Nil)), ys == (Cons x7 x8), len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len ((Cons x7 (Nil))) == 1 + len (Nil), len (Nil) == 0, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (x10 == (Cons x7 (Nil)) && (ys == (Cons x7 x8) && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len ((Cons x7 (Nil))) == 1 + len (Nil) && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (Cons
                            x7 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x7 Nil)
Trying x8
Checking x8 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A6 ()
TYPE ERROR: Cannot match shape 'List (b)'
with shape 'b'
when checking x8 :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x8 ??)
Trying xs
Checking xs :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A6 ()
TYPE ERROR: Cannot match shape 'List (a)'
with shape 'b'
when checking xs :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      xs ??)
Trying ys
Checking ys :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A6 ()
TYPE ERROR: Cannot match shape 'List (b)'
with shape 'b'
when checking ys :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      ys ??)
Trying x4
Checking x4 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A6 ()
TYPE ERROR: Cannot match shape 'List (a)'
with shape 'b'
when checking x4 :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
TYPE ERROR: Cannot match shape 'List (A7)'
with shape 'b'
when checking Nil :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Cons
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x11:A7 -> x12:A6 -> {Pair A7 A6|_v == (Pair x11 x12)}
Trying Pair
Checking Pair :: X3:_ -> X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (?? ??
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A7 -> x12:A6 -> {Pair A7 A6|_v == (Pair x11 x12)} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A7 -> x12:A6 -> {Pair A7 A6|_v == (Pair x11 x12)} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A7 -> x12:A6 -> {Pair A7 A6|_v == (Pair x11 x12)} /\ X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A7 -> x12:A6 -> {Pair A7 A6|_v == (Pair x11 x12)} <: X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A7 WITH {b|U7} PRODUCING {b|U8}
TYPE ERROR: Cannot match shape 'Pair (A6)'
with shape 'List'
when checking Pair ::
X3:_ -> X2:_ -> List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (Pair
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x11:List A6 -> x12:List A6 -> {List A6|len _v == len x11 + len x12}
Trying append
Checking append :: X3:_ -> X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (?? ??
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A6 -> {List A6|len _v == len x11 + len x12} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A6 -> {List A6|len _v == len x11 + len x12} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A6 -> {List A6|len _v == len x11 + len x12} /\ X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A6 -> {List A6|len _v == len x11 + len x12} <: X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {b|U7} PRODUCING {b|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U8}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X3 + len X2} <: List ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x11 + len x12} /\ List ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} /\ {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U7 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x3 ??)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x7 ??)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U8} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking append
           x8 :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len x8 + len x12} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len x8 + len x12} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len x8 + len x12} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len x8 + len x12} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8 + len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8 + len x12} /\ List ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} /\ {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U7 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 x3)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 x7)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U8} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Synthesized argument ys of type {List b|_v == ys}
Checking append x8
           ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len ys} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8 + len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Synthesized argument append x8
                       ys of type {List A6|len _v == len x8 + len ys}
Checking product x4 (append x8
                       ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x8 + len ys}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x8 + len ys}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len x8 + len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len x8 + len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len x8 + len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len x8 + len ys, len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len x8 + len ys && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (append
                            x8 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 ys)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 x4)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U8} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking append x8
           x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len x8} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8 + len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Synthesized argument append x8
                       x8 of type {List A6|len _v == len x8 + len x8}
Checking product x4 (append x8
                       x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x8 + len x8}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x8 + len x8}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len x8 + len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len x8 + len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len x8 + len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len x8 + len x8, len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len x8 + len x8 && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (append
                            x8 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 x8)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {b|U8} PRODUCING {b|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U8} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append x8
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8 + len (Nil)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8 + len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument append x8
                       Nil of type {List A6|len _v == len x8 + len (Nil)}
Checking product x4 (append x8
                       Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x8 + len (Nil)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x8 + len (Nil)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len x8 + len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len x8 + len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len x8 + len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len x8 + len (Nil), len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len x8 + len (Nil) && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (append
                            x8 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x8 Nil)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      xs ??)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U8} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Synthesized argument ys of type {List b|_v == ys}
Checking append
           ys :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len ys + len x12} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len ys + len x12} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len ys + len x12} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len ys + len x12} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys + len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys + len x12} /\ List ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} /\ {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U7 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys x3)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U8} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking append ys
           x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len x8} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys + len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Synthesized argument append ys
                       x8 of type {List A6|len _v == len ys + len x8}
Checking product x4 (append ys
                       x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len ys + len x8}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len ys + len x8}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len ys + len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len ys + len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len ys + len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len ys + len x8, len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len ys + len x8 && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (append
                            ys x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys xs)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys x4)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U8} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Synthesized argument ys of type {List b|_v == ys}
Checking append ys
           ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len ys} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys + len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 0)
Synthesized argument append ys
                       ys of type {List A6|len _v == len ys + len ys}
Checking product x4 (append ys
                       ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len ys + len ys}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len ys + len ys}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len ys + len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len ys + len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len ys + len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len ys + len ys, len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len ys + len ys && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (append
                            ys ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {b|U8} PRODUCING {b|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U8} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append ys
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys + len (Nil)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys + len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument append ys
                       Nil of type {List A6|len _v == len ys + len (Nil)}
Checking product x4 (append ys
                       Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len ys + len (Nil)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len ys + len (Nil)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len ys + len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len ys + len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len ys + len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len ys + len (Nil), len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len ys + len (Nil) && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (append
                            ys Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ys Nil)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {b|U8} PRODUCING {b|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U8} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append
           Nil :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len (Nil) + len x12} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len (Nil) + len x12} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len (Nil) + len x12} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:List A6 -> {List A6|len _v == len (Nil) + len x12} <: X2:_ -> List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x12} /\ List ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} /\ {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U7 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil x3)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil x7)
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U8} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking append Nil
           x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len x8} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument append Nil
                       x8 of type {List A6|len _v == len (Nil) + len x8}
Checking product x4 (append Nil
                       x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil) + len x8}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil) + len x8}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len (Nil) + len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len (Nil) + len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len (Nil) + len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len (Nil) + len x8, len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len (Nil) + len x8 && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (append
                            Nil x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil x8)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil xs)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U8} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument ys of type {List b|_v == ys}
Checking append Nil
           ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len ys} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument append Nil
                       ys of type {List A6|len _v == len (Nil) + len ys}
Checking product x4 (append Nil
                       ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil) + len ys}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil) + len ys}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len (Nil) + len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len (Nil) + len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len (Nil) + len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len (Nil) + len ys, len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len (Nil) + len ys && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (append
                            Nil ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil ys)
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil x4)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {b|U8} PRODUCING {b|U10}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
A8 -> {b|U10}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
A8 -> {b|U10}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U10}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U8} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking append Nil
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil) + len (Nil)} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
A8 -> {b|U10}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Synthesized argument append Nil
                       Nil of type {List A6|len _v == len (Nil) + len (Nil)}
Checking product x4 (append Nil
                       Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil) + len (Nil)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil) + len (Nil)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
A8 -> {b|U10}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len (Nil) + len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len (Nil) + len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len (Nil) + len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len (Nil) + len (Nil), len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len (Nil) + len (Nil) && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (append
                            Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (append
                                      Nil Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x11:(x12:A7 -> A6) -> x13:List A7 -> {List A6|len _v == len x13}
Trying map
Checking map :: X3:_ -> X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (?? ??
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A7 -> A6) -> x13:List A7 -> {List A6|len _v == len x13} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A7 -> A6) -> x13:List A7 -> {List A6|len _v == len x13} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A7 -> A6) -> x13:List A7 -> {List A6|len _v == len x13} /\ X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A7 -> A6) -> x13:List A7 -> {List A6|len _v == len x13} <: X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {b|U7} PRODUCING {b|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A7
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U8}
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} /\ {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U7 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Checking map
           f0 :: X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List A6|len _v == len x13} <: X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List A6|len _v == len x13} /\ X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List A6|len _v == len x13} /\ X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> {List A6|len _v == len x13} <: X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} /\ {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U7 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      x3)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      x7)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH b PRODUCING {b|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking map f0 x8 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x8} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument map f0
                       x8 of type {List A6|len _v == len x8}
Checking product x4 (map f0
                       x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x8}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x8}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len x8 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len x8, len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len x8 && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (map f0
                            x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      x8)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH a PRODUCING {a|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {a|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument xs of type {List a|_v == xs}
Checking map f0 xs :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len xs} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument map f0
                       xs of type {List A6|len _v == len xs}
Checking product x4 (map f0
                       xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len xs}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len xs}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {a|U9}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len xs && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len xs && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len xs && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len xs, len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len xs && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (map f0
                            xs) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      xs)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH b PRODUCING {b|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument ys of type {List b|_v == ys}
Checking map f0 ys :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len ys} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument map f0
                       ys of type {List A6|len _v == len ys}
Checking product x4 (map f0
                       ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len ys}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len ys}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {b|U9}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len ys && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len ys, len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len ys && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (map f0
                            ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      ys)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH a PRODUCING {a|U9}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {a|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U9}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking map f0 x4 :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len x4} <: List A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument map f0
                       x4 of type {List A6|len _v == len x4}
Checking product x4 (map f0
                       x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x4}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len x4}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
A7 -> {a|U9}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len x4 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len x4 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len x4 && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len x4, len _v == len x4 * len x10, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len x4 && (len _v == len x4 * len x10 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (map f0
                            x4) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      x4)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking map f0
           Nil :: List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil)} <: List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A6|len _v == len (Nil)} <: List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A8|False} <: A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U8} <: {b|U7} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 0)
Synthesized argument map f0
                       Nil of type {List A6|len _v == len (Nil)}
Checking product x4 (map f0
                       Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A6|len _v == len (Nil)}) IN {List Pair A4 A5|len _v == len x4 * len x10} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A8|False} <: A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {b|U8}
Simple Constraints
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len x10 == len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (6 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x10 == len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len x10 == len (Nil) && (len _v == len x4 * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len x10 == len (Nil), len _v == len x4 * len x10, len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x10 >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len x10 == len (Nil) && (len _v == len x4 * len x10 && (len (Nil) == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking product x4 (map f0
                            Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (map f0
                                      Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . <b> . x0:{List a|len _v >= 0 && len _v < len xs} -> ys:List b -> {List Pair a b|len _v == len x0 * len ys}
INTO x11:{List A6|len _v >= 0 && len _v < len xs} -> x12:List A7 -> {List Pair A6 A7|len _v == len x11 * len x12}
Trying product
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A7 -> {List {Pair {A6|False} {A7|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
Checking product :: X3:_ -> X2:_ -> List A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4 (?? ??
                                      ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A6|len _v >= 0 && len _v < len xs} -> x12:List A7 -> {List Pair A6 A7|len _v == len x11 * len x12} <: X3:_ -> X2:_ -> List A5 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A6|len _v >= 0 && len _v < len xs} -> x12:List A7 -> {List Pair A6 A7|len _v == len x11 * len x12} /\ X3:_ -> X2:_ -> List A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A6|len _v >= 0 && len _v < len xs} -> x12:List A7 -> {List Pair A6 A7|len _v == len x11 * len x12} /\ X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A6|len _v >= 0 && len _v < len xs} -> x12:List A7 -> {List Pair A6 A7|len _v == len x11 * len x12} <: X3:_ -> X2:_ -> List A5 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A6 -> x12:List A7 -> {List {Pair {A6|False} {A7|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
product, x3, x4, x7, x8, xs, ys |- A7
product, x3, x4, x7, x8, xs, ys |- A6
TYPE ERROR: Cannot match shape 'Pair (A6) (A7)'
with shape 'b'
when checking product ::
X3:_ -> X2:_ -> List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x4
                          (product ?? ??)
Trying x7
Checking x7 :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A4|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A4)'
when checking x7 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x7 ??
Trying x8
Checking x8 :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A4|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product x8 ??
Trying xs
Checking xs :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A4|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (4 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}] (4 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Strengthening: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
_v == xs, xs == (Cons x3 x4), ys == (Cons x7 x8), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v >= 0 && len _v < len xs
assumption _v == xs && (xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v >= 0 && len _v < len xs)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product xs ??
Trying ys
Checking ys :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A4|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ys ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List A4|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: {List A4|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: {List A4|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {a|U6} PRODUCING {a|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {a|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {a|U8}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U8}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U6} ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 0} <: {List|len _v < len xs && len _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v < len xs && len _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (4 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (4 0)
Synthesized argument Nil of type {List {A6|False}|_v == (Nil)}
Checking product
           Nil :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len (Nil) * len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len (Nil) * len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len (Nil) * len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:List A5 -> {List Pair A4 A5|len _v == len (Nil) * len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {a|U6}
A5 -> {b|U7}
A6 -> {a|U8}
Simple Constraints
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair <: Pair ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- Pair /\ Pair ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len (Nil) * len x10 && (len x4 >= 0 && (len xs >= 0 && (len x10 >= 0 && (len x8 >= 0 && len ys >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (4 0)
Remaining Candidates (0)
TYPE ERROR: Found inconsistent refinements
when checking product Nil ::
X0:_ -> {List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> product Nil ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)}
Trying Cons
Checking Cons :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A4 -> x10:List A4 -> {List A4|_v == (Cons x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A4 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U6} {b|U7}|U8}
product, x3, x4, x7, x8, xs, ys |- {b|U7}
product, x3, x4, x7, x8, xs, ys |- {a|U6}
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X1 X0)} <: {List|len _v == len xs * len ys} ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && ([_v -> x9]U8 && (_v == (Cons x9 x10) && (len _v == len xs * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x11:A6 -> x12:A5 -> {Pair A6 A5|_v == (Pair x11 x12)}
Trying Pair
Checking Pair :: X3:_ -> X2:_ -> A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (?? ?? ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:A5 -> {Pair A6 A5|_v == (Pair x11 x12)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:A5 -> {Pair A6 A5|_v == (Pair x11 x12)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:A5 -> {Pair A6 A5|_v == (Pair x11 x12)} /\ X3:_ -> X2:_ -> A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:A5 -> {Pair A6 A5|_v == (Pair x11 x12)} <: X3:_ -> X2:_ -> A4 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH {a|U6} PRODUCING {a|U9}
UNIFY A5 WITH {b|U7} PRODUCING {b|U10}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|_v == (Pair X3 X2)} <: {Pair|U8} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|_v == (Pair x11 x12)} /\ {Pair|U8} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} /\ {b|U7} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U6} ()
Pred assignment
Constraints
  False ==> U8
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U8 && ([_v -> x11]U9 && ([_v -> x12]U10 && (_v == (Pair x11 x12) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
  C2 && (M1 && (M3 && (U10 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U6 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Trying x3
Checking x3 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A6 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {a|U9} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument x3 of type {a|_v == x3}
Checking Pair
           x3 :: X2:_ -> A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (?? ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A5 -> {Pair A6 A5|_v == (Pair x3 x12)} <: X2:_ -> A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A5 -> {Pair A6 A5|_v == (Pair x3 x12)} /\ X2:_ -> A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A5 -> {Pair A6 A5|_v == (Pair x3 x12)} /\ X2:_ -> A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x12:A5 -> {Pair A6 A5|_v == (Pair x3 x12)} <: X2:_ -> A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|_v == (Pair x3 X2)} <: {Pair|U8} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|_v == (Pair x3 x12)} /\ {Pair|U8} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} /\ {b|U7} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U6} ()
Pred assignment
Constraints
  False ==> U8
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U8 && ([_v -> x12]U10 && (_v == (Pair x3 x12) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
  C2 && (M1 && (M3 && (U10 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U6 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Trying x4
Checking x4 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A5 ()
TYPE ERROR: Cannot match shape 'List (a)'
with shape 'b'
when checking x4 :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x4)
                          ??
Trying x7
Checking x7 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {b|U10} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U10
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (8 0)
Synthesized argument x7 of type {b|_v == x7}
Checking Pair x3 x7 :: A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair A6 A5|_v == (Pair x3 x7)} <: A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair A6 A5|_v == (Pair x3 x7)} <: A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|_v == (Pair x3 x7)} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == (Pair x3 x7) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument Pair x3
                       x7 of type {Pair A6 A5|_v == (Pair x3 x7)}
Checking Cons (Pair x3
                 x7) :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
Simple Constraints
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 X0)} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (_v == (Cons x9 x10) && (x9 == (Pair x3 x7) && (len _v == len xs * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Trying x4
Checking x4 :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
x9:{Pair a b|_v == (Pair x3 x7)} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          x4
Trying x8
Checking x8 :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
x9:{Pair a b|_v == (Pair x3 x7)} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          x8
Trying xs
Checking xs :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
x9:{Pair a b|_v == (Pair x3 x7)} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          xs
Trying ys
Checking ys :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
x9:{Pair a b|_v == (Pair x3 x7)} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ys
Trying x3
Checking x3 :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A4)'
when checking x3 ::
x9:{Pair a b|_v == (Pair x3 x7)} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          x3
Trying x7
Checking x7 :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A4)'
when checking x7 ::
x9:{Pair a b|_v == (Pair x3 x7)} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          x7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U11} {b|U12}|U13}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U11} {b|U12}|U13}
product, x3, x4, x7, x8, xs, ys |- {b|U12}
product, x3, x4, x7, x8, xs, ys |- {a|U11}
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking Cons (Pair x3 x7)
           Nil :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 (Nil))} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 (Nil))} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 (Nil))} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len (Nil)} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                Nil ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          Nil
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x13:List A7 -> x14:List A7 -> {List A7|len _v == len x13 + len x14}
Trying append
Checking append :: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> x14:List A7 -> {List A7|len _v == len x13 + len x14} <: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> x14:List A7 -> {List A7|len _v == len x13 + len x14} /\ X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> x14:List A7 -> {List A7|len _v == len x13 + len x14} /\ X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> x14:List A7 -> {List A7|len _v == len x13 + len x14} <: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U11} {b|U12}|U13}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U11} {b|U12}|U13}
product, x3, x4, x7, x8, xs, ys |- {b|U12}
product, x3, x4, x7, x8, xs, ys |- {a|U11}
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X5 + len X4} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x13 + len x14} /\ List ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} /\ {Pair|U8} ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} /\ {b|U7} ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U13 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append x4 ??)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append x8 ??)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append xs ??)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append ys ??)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append x3 ??)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append x7 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {Pair {a|U11} {b|U12}|U13} PRODUCING {Pair {a|U14} {b|U15}|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {Pair {a|U14} {b|U15}|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {Pair {a|U14} {b|U15}|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U14} {b|U15}|U16}
product, x3, x4, x7, x8, xs, ys |- {b|U15}
product, x3, x4, x7, x8, xs, ys |- {a|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U13} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U15} <: {b|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U14} <: {a|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking append
           Nil :: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> {List A7|len _v == len (Nil) + len x14} <: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> {List A7|len _v == len (Nil) + len x14} /\ X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> {List A7|len _v == len (Nil) + len x14} /\ X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> {List A7|len _v == len (Nil) + len x14} <: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {Pair {a|U14} {b|U15}|U16}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x14} /\ List ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} /\ {Pair|U8} ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} /\ {b|U7} ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U13 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil x4)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil x8)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil xs)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil ys)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil x3)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil x7)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {Pair {a|U11} {b|U12}|U13} PRODUCING {Pair {a|U17} {b|U18}|U19}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {Pair {a|U14} {b|U15}|U16}
A9 -> {Pair {a|U17} {b|U18}|U19}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {Pair {a|U14} {b|U15}|U16}
A9 -> {Pair {a|U17} {b|U18}|U19}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U17} {b|U18}|U19}
product, x3, x4, x7, x8, xs, ys |- {b|U18}
product, x3, x4, x7, x8, xs, ys |- {a|U17}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U13} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U18} <: {b|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U17} <: {a|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U18 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U12
  C2 && (M1 && (M3 && (U17 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (16 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (16 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking append Nil
           Nil :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil) + len (Nil)} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil) + len (Nil)} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {Pair {a|U14} {b|U15}|U16}
A9 -> {Pair {a|U17} {b|U18}|U19}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (16 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (16 0)
Synthesized argument append Nil
                       Nil of type {List A7|len _v == len (Nil) + len (Nil)}
Checking Cons (Pair x3 x7)
           (append Nil
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil) + len (Nil)}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil) + len (Nil)}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {Pair {a|U14} {b|U15}|U16}
A9 -> {Pair {a|U17} {b|U18}|U19}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (16 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (16 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len (Nil) + len (Nil), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len (Nil) + len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (append Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (append Nil Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x13:(x14:A8 -> A7) -> x15:List A8 -> {List A7|len _v == len x15}
Trying map
Checking map :: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:(x14:A8 -> A7) -> x15:List A8 -> {List A7|len _v == len x15} <: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:(x14:A8 -> A7) -> x15:List A8 -> {List A7|len _v == len x15} /\ X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:(x14:A8 -> A7) -> x15:List A8 -> {List A7|len _v == len x15} /\ X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:(x14:A8 -> A7) -> x15:List A8 -> {List A7|len _v == len x15} <: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U11} {b|U12}|U13}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U11} {b|U12}|U13}
product, x3, x4, x7, x8, xs, ys |- {b|U12}
product, x3, x4, x7, x8, xs, ys |- {a|U11}
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U13 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Checking map
           f0 :: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List A7|len _v == len x15} <: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List A7|len _v == len x15} /\ X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List A7|len _v == len x15} /\ X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List A7|len _v == len x15} <: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U13 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH a PRODUCING {a|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {a|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {a|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking map f0
           x4 :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x4} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x4} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {a|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument map f0
                       x4 of type {List A7|len _v == len x4}
Checking Cons (Pair x3 x7) (map
                              f0
                              x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x4}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x4}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {a|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (map f0 x4) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 x4)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH b PRODUCING {b|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {b|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking map f0
           x8 :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x8} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x8} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument map f0
                       x8 of type {List A7|len _v == len x8}
Checking Cons (Pair x3 x7) (map
                              f0
                              x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x8}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x8}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {b|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (map f0 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 x8)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH a PRODUCING {a|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {a|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {a|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument xs of type {List a|_v == xs}
Checking map f0
           xs :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len xs} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len xs} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {a|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len xs} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument map f0
                       xs of type {List A7|len _v == len xs}
Checking Cons (Pair x3 x7) (map
                              f0
                              xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len xs}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len xs}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {a|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (map f0 xs) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 xs)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH b PRODUCING {b|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {b|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument ys of type {List b|_v == ys}
Checking map f0
           ys :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len ys} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len ys} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument map f0
                       ys of type {List A7|len _v == len ys}
Checking Cons (Pair x3 x7) (map
                              f0
                              ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len ys}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len ys}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
A8 -> {b|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (map f0 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 ys)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 x3)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 x7)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking map f0
           Nil :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil)} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil)} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A9|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument map f0
                       Nil of type {List A7|len _v == len (Nil)}
Checking Cons (Pair x3 x7) (map
                              f0
                              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil)}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil)}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A9|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len (Nil), len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len (Nil) && (len (Nil) == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (map f0 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (map f0 Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x13:A7 -> x14:List A7 -> {List A7|_v == (Cons x13 x14)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:A7 -> x14:List A7 -> {List A7|_v == (Cons x13 x14)} <: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:A7 -> x14:List A7 -> {List A7|_v == (Cons x13 x14)} /\ X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:A7 -> x14:List A7 -> {List A7|_v == (Cons x13 x14)} /\ X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:A7 -> x14:List A7 -> {List A7|_v == (Cons x13 x14)} <: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U11} {b|U12}|U13}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {Pair {a|U11} {b|U12}|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U11} {b|U12}|U13}
product, x3, x4, x7, x8, xs, ys |- {b|U12}
product, x3, x4, x7, x8, xs, ys |- {a|U11}
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X5 X4)} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x13 x14)} /\ List ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U13} /\ {Pair|U8} ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} /\ {b|U7} ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U13 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U12 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x4
Checking x4 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A7 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking x4 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons x4 ??)
Trying x8
Checking x8 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons x8 ??)
Trying xs
Checking xs :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A7 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking xs :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons xs ??)
Trying ys
Checking ys :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons ys ??)
Trying x3
Checking x3 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x3 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons x3 ??)
Trying x7
Checking x7 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x7 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons x7 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {a|U11} PRODUCING {a|U14}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Nil :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Cons Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x13:A8 -> x14:A7 -> {Pair A8 A7|_v == (Pair x13 x14)}
Trying Pair
Checking Pair :: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:A8 -> x14:A7 -> {Pair A8 A7|_v == (Pair x13 x14)} <: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:A8 -> x14:A7 -> {Pair A8 A7|_v == (Pair x13 x14)} /\ X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:A8 -> x14:A7 -> {Pair A8 A7|_v == (Pair x13 x14)} /\ X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:A8 -> x14:A7 -> {Pair A8 A7|_v == (Pair x13 x14)} <: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A8 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U11} {b|U12}|U13}
TYPE ERROR: Cannot match shape 'Pair (A7)'
with shape 'List'
when checking Pair ::
X5:_ -> X4:_ -> x9:{Pair a b|_v == (Pair x3 x7)} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (Pair ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . <b> . x0:{List a|len _v >= 0 && len _v < len xs} -> ys:List b -> {List Pair a b|len _v == len x0 * len ys}
INTO x13:{List A7|len _v >= 0 && len _v < len xs} -> x14:List A8 -> {List Pair A7 A8|len _v == len x13 * len x14}
Trying product
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> x14:List A8 -> {List {Pair {A7|False} {A8|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
Checking product :: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:{List A7|len _v >= 0 && len _v < len xs} -> x14:List A8 -> {List Pair A7 A8|len _v == len x13 * len x14} <: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:{List A7|len _v >= 0 && len _v < len xs} -> x14:List A8 -> {List Pair A7 A8|len _v == len x13 * len x14} /\ X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:{List A7|len _v >= 0 && len _v < len xs} -> x14:List A8 -> {List Pair A7 A8|len _v == len x13 * len x14} /\ X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:{List A7|len _v >= 0 && len _v < len xs} -> x14:List A8 -> {List Pair A7 A8|len _v == len x13 * len x14} <: X5:_ -> X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A7 -> x14:List A8 -> {List {Pair {A7|False} {A8|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {a|U6} PRODUCING {a|U11}
UNIFY A8 WITH {b|U7} PRODUCING {b|U12}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U11}
product, x3, x4, x7, x8, xs, ys |- {b|U12}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: a ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U12} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U11} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X5 * len X4} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x13 * len x14} /\ List ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} /\ {b|U7} ()
product, x13, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U12 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x4
Checking x4 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A7|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking product
           x4 :: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A8 -> {List Pair A7 A8|len _v == len x4 * len x14} <: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A8 -> {List Pair A7 A8|len _v == len x4 * len x14} /\ X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A8 -> {List Pair A7 A8|len _v == len x4 * len x14} /\ X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A8 -> {List Pair A7 A8|len _v == len x4 * len x14} <: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x14} /\ List ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} /\ {b|U7} ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U12 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product x4
           x8 :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len x8} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len x8} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 0)
Synthesized argument product x4
                       x8 of type {List Pair A7 A8|len _v == len x4 * len x8}
Checking Cons (Pair x3 x7)
           (product x4
              x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len x8}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len x8}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len x4 * len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len x4 * len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (product x4 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 x8)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 xs)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product x4
           ys :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len ys} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len ys} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 0)
Synthesized argument product x4
                       ys of type {List Pair A7 A8|len _v == len x4 * len ys}
Checking Cons (Pair x3 x7)
           (product x4
              ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len ys}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len ys}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (15 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len x4 * len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len x4 * len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (product x4 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 ys)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 x3)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 x4)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 x7)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {b|U12} PRODUCING {b|U13}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {b|U13}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {b|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U13}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U12} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking product x4
           Nil :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len (Nil)} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len (Nil)} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {b|U13}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument product x4
                       Nil of type {List Pair A7 A8|len _v == len x4 * len (Nil)}
Checking Cons (Pair x3 x7)
           (product x4
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len (Nil)}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len (Nil)}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {b|U13}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len x4 * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len x4 * len (Nil), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len x4 * len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (product x4 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x4 Nil)
Trying x8
Checking x8 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x8 ??)
Trying xs
Checking xs :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A7|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U11} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U11
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Strengthening: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
_v == xs, xs == (Cons x3 x4), ys == (Cons x7 x8), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v >= 0 && len _v < len xs
assumption _v == xs && (xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v >= 0 && len _v < len xs)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product xs ??)
Trying ys
Checking ys :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product ys ??)
Trying x3
Checking x3 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x3 ??)
Trying x7
Checking x7 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product x7 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: {List A7|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {a|U11} PRODUCING {a|U13}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U11} ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 0} <: {List|len _v < len xs && len _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v < len xs && len _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking product
           Nil :: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x14} <: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x14} /\ X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x14} /\ X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x14} <: X4:_ -> LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x14} /\ List ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} /\ {b|U7} ()
product, x14, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U12 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U11 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil x4)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product Nil
           x8 :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len x8} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len x8} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument product Nil
                       x8 of type {List Pair A7 A8|len _v == len (Nil) * len x8}
Checking Cons (Pair x3 x7)
           (product Nil
              x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len x8}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len x8}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) * len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len (Nil) * len x8, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len (Nil) * len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (product Nil x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil x8)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil xs)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product Nil
           ys :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len ys} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len ys} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument product Nil
                       ys of type {List Pair A7 A8|len _v == len (Nil) * len ys}
Checking Cons (Pair x3 x7)
           (product Nil
              ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len ys}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len ys}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) * len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len (Nil) * len ys, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len (Nil) * len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (product Nil ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil ys)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil x3)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil x7)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A10
UNIFY A10 WITH {b|U12} PRODUCING {b|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U12} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument Nil of type {List {A10|False}|_v == (Nil)}
Checking product Nil
           Nil :: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len (Nil)} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len (Nil)} <: LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U12} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U11} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument product Nil
                       Nil of type {List Pair A7 A8|len _v == len (Nil) * len (Nil)}
Checking Cons (Pair x3 x7)
           (product Nil
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len (Nil)}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len (Nil)}) IN LET x9:({Pair A6 A5|_v == (Pair x3 x7)}) IN {List A4|_v == (Cons x9 x10)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U14}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {b|U10}
A6 -> {a|U9}
A7 -> {a|U11}
A8 -> {b|U12}
A9 -> {a|U13}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x9 x10)} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == 1 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == 1 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == 1 + len x10, len x10 == len (Nil) * len (Nil), len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == 1 + len x10 && (len x10 == len (Nil) * len (Nil) && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x10 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking Cons (Pair x3 x7)
                (product Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x7)
                          (product Nil Nil)
Trying x8
Checking x8 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A5 ()
TYPE ERROR: Cannot match shape 'List (b)'
with shape 'b'
when checking x8 :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x8)
                          ??
Trying xs
Checking xs :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A5 ()
TYPE ERROR: Cannot match shape 'List (a)'
with shape 'b'
when checking xs :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 xs)
                          ??
Trying ys
Checking ys :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A5 ()
TYPE ERROR: Cannot match shape 'List (b)'
with shape 'b'
when checking ys :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 ys)
                          ??
Trying x3
Checking x3 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x3 :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 x3)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A7
TYPE ERROR: Cannot match shape 'List (A7)'
with shape 'b'
when checking Nil :: b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x3 Nil)
                          ??
Trying x4
Checking x4 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A6 ()
TYPE ERROR: Cannot match shape 'List (a)'
with shape 'a'
when checking x4 :: a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x4 ??)
                          ??
Trying x7
Checking x7 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A6 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x7 :: a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x7 ??)
                          ??
Trying x8
Checking x8 :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A6 ()
TYPE ERROR: Cannot match shape 'List (b)'
with shape 'a'
when checking x8 :: a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair x8 ??)
                          ??
Trying xs
Checking xs :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A6 ()
TYPE ERROR: Cannot match shape 'List (a)'
with shape 'a'
when checking xs :: a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair xs ??)
                          ??
Trying ys
Checking ys :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A6 ()
TYPE ERROR: Cannot match shape 'List (b)'
with shape 'a'
when checking ys :: a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair ys ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: A6 ()
product, x3, x4, x7, x8, xs, ys |- A7
TYPE ERROR: Cannot match shape 'List (A7)'
with shape 'a'
when checking Nil :: a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Pair Nil ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x11:List A5 -> x12:List A5 -> {List A5|len _v == len x11 + len x12}
Trying append
Checking append :: X3:_ -> X2:_ -> A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (?? ?? ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> x12:List A5 -> {List A5|len _v == len x11 + len x12} <: X3:_ -> X2:_ -> A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> x12:List A5 -> {List A5|len _v == len x11 + len x12} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> x12:List A5 -> {List A5|len _v == len x11 + len x12} /\ X3:_ -> X2:_ -> A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> x12:List A5 -> {List A5|len _v == len x11 + len x12} <: X3:_ -> X2:_ -> A4 ()
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH {a|U6} PRODUCING {a|U9}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking append ::
X3:_ -> X2:_ -> Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (append ??
                                ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x11:(x12:A6 -> A5) -> x13:List A6 -> {List A5|len _v == len x13}
Trying map
Checking map :: X3:_ -> X2:_ -> A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (?? ?? ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A6 -> A5) -> x13:List A6 -> {List A5|len _v == len x13} <: X3:_ -> X2:_ -> A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A6 -> A5) -> x13:List A6 -> {List A5|len _v == len x13} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A6 -> A5) -> x13:List A6 -> {List A5|len _v == len x13} /\ X3:_ -> X2:_ -> A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A6 -> A5) -> x13:List A6 -> {List A5|len _v == len x13} <: X3:_ -> X2:_ -> A4 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH {a|U6} PRODUCING {a|U9}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking map ::
X3:_ -> X2:_ -> Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (map ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x11:A5 -> x12:List A5 -> {List A5|_v == (Cons x11 x12)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (?? ?? ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A5 -> x12:List A5 -> {List A5|_v == (Cons x11 x12)} <: X3:_ -> X2:_ -> A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A5 -> x12:List A5 -> {List A5|_v == (Cons x11 x12)} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A5 -> x12:List A5 -> {List A5|_v == (Cons x11 x12)} /\ X3:_ -> X2:_ -> A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A5 -> x12:List A5 -> {List A5|_v == (Cons x11 x12)} <: X3:_ -> X2:_ -> A4 ()
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH {a|U6} PRODUCING {a|U9}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Cons ::
X3:_ -> X2:_ -> Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (Cons ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . <b> . x0:{List a|len _v >= 0 && len _v < len xs} -> ys:List b -> {List Pair a b|len _v == len x0 * len ys}
INTO x11:{List A5|len _v >= 0 && len _v < len xs} -> x12:List A6 -> {List Pair A5 A6|len _v == len x11 * len x12}
Trying product
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> x12:List A6 -> {List {Pair {A5|False} {A6|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
Checking product :: X3:_ -> X2:_ -> A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (?? ?? ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A5|len _v >= 0 && len _v < len xs} -> x12:List A6 -> {List Pair A5 A6|len _v == len x11 * len x12} <: X3:_ -> X2:_ -> A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A5|len _v >= 0 && len _v < len xs} -> x12:List A6 -> {List Pair A5 A6|len _v == len x11 * len x12} /\ X3:_ -> X2:_ -> A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A5|len _v >= 0 && len _v < len xs} -> x12:List A6 -> {List Pair A5 A6|len _v == len x11 * len x12} /\ X3:_ -> X2:_ -> A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:{List A5|len _v >= 0 && len _v < len xs} -> x12:List A6 -> {List Pair A5 A6|len _v == len x11 * len x12} <: X3:_ -> X2:_ -> A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:List A5 -> x12:List A6 -> {List {Pair {A5|False} {A6|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
TYPE ERROR: Cannot match shape 'Pair (A5) (A6)'
with shape 'a'
when checking product ::
X3:_ -> X2:_ -> Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Cons (product ??
                                ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)}
Trying Pair
Checking Pair :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:A5 -> x10:A4 -> {Pair A5 A4|_v == (Pair x9 x10)} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A5
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A5 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
TYPE ERROR: Cannot match shape 'Pair (A4)'
with shape 'List'
when checking Pair ::
X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> Pair ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A4
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10}
Trying append
Checking append :: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} /\ X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x9:List A4 -> x10:List A4 -> {List A4|len _v == len x9 + len x10} <: X1:_ -> X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys |- A4
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, xs, ys |- A3
UNIFY A4 WITH Pair a b PRODUCING {Pair {a|U6} {b|U7}|U8}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
Simple Constraints
product, x3, x4, xs, ys |- b
product, x3, x4, x7, x8, xs, ys |- C2
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U6} {b|U7}|U8}
product, x3, x4, x7, x8, xs, ys |- {b|U7}
product, x3, x4, x7, x8, xs, ys |- {a|U6}
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X1 + len X0} <: {List|len _v == len xs * len ys} ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, X1, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X1 + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len x9 + len x10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}] (3 0)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x11:A5 -> x12:List A5 -> {List A5|_v == (Cons x11 x12)}
Trying Cons
Checking Cons :: X3:_ -> X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (?? ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A5 -> x12:List A5 -> {List A5|_v == (Cons x11 x12)} <: X3:_ -> X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A5 -> x12:List A5 -> {List A5|_v == (Cons x11 x12)} /\ X3:_ -> X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A5 -> x12:List A5 -> {List A5|_v == (Cons x11 x12)} /\ X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A5 -> x12:List A5 -> {List A5|_v == (Cons x11 x12)} <: X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U9} {b|U10}|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U9} {b|U10}|U11}
product, x3, x4, x7, x8, xs, ys |- {b|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X3 X2)} <: List ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U11} <: {Pair|U8} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
X2, X3, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x11 x12)} /\ List ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U11} /\ {Pair|U8} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} /\ {b|U7} ()
product, x11, x12, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U11 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U10 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U6 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Trying x3
Checking x3 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons ??
                                  ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A5 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x3 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons x3
                                  ??) ??
Trying x4
Checking x4 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons ??
                                  ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A5 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking x4 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons x4
                                  ??) ??
Trying x7
Checking x7 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons ??
                                  ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A5 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x7 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons x7
                                  ??) ??
Trying x8
Checking x8 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons ??
                                  ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A5 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons x8
                                  ??) ??
Trying xs
Checking xs :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons ??
                                  ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A5 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking xs :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons xs
                                  ??) ??
Trying ys
Checking ys :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons ??
                                  ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A5 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons ys
                                  ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A6|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons ??
                                  ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: A5 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A6|False}|_v == (Nil)} <: A5 ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH {a|U9} PRODUCING {a|U12}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Nil :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Cons Nil
                                  ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x11:A6 -> x12:A5 -> {Pair A6 A5|_v == (Pair x11 x12)}
Trying Pair
Checking Pair :: X3:_ -> X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (?? ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:A5 -> {Pair A6 A5|_v == (Pair x11 x12)} <: X3:_ -> X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:A5 -> {Pair A6 A5|_v == (Pair x11 x12)} /\ X3:_ -> X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:A5 -> {Pair A6 A5|_v == (Pair x11 x12)} /\ X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:A6 -> x12:A5 -> {Pair A6 A5|_v == (Pair x11 x12)} <: X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A6 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U9} {b|U10}|U11}
TYPE ERROR: Cannot match shape 'Pair (A5)'
with shape 'List'
when checking Pair ::
X3:_ -> X2:_ -> List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (Pair ??
                                  ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys |- A5
Adding constraint product, x3, x4, x7, x8, xs, ys |- A6
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x11:(x12:A6 -> A5) -> x13:List A6 -> {List A5|len _v == len x13}
Trying map
Checking map :: X3:_ -> X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (?? ?? ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A6 -> A5) -> x13:List A6 -> {List A5|len _v == len x13} <: X3:_ -> X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A6 -> A5) -> x13:List A6 -> {List A5|len _v == len x13} /\ X3:_ -> X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A6 -> A5) -> x13:List A6 -> {List A5|len _v == len x13} /\ X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x11:(x12:A6 -> A5) -> x13:List A6 -> {List A5|len _v == len x13} <: X3:_ -> X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys |- A6
product, x3, x4, x7, x8, xs, ys |- A5
UNIFY A5 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U9} {b|U10}|U11}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A6
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U9} {b|U10}|U11}
product, x3, x4, x7, x8, xs, ys |- {b|U10}
product, x3, x4, x7, x8, xs, ys |- {a|U9}
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U11} <: {Pair|U8} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U11} /\ {Pair|U8} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} /\ {b|U7} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U11 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U10 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U6 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Checking map
           f0 :: X2:_ -> List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (?? ??) ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A5|len _v == len x13} <: X2:_ -> List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A5|len _v == len x13} /\ X2:_ -> List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A5|len _v == len x13} /\ X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x13:List A6 -> {List A5|len _v == len x13} <: X2:_ -> List A4 ()
product, x3, x4, x7, x8, xs, ys |- A6
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
Simple Constraints
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len X2} <: List ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U11} <: {Pair|U8} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
X2, product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x13} /\ List ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U11} /\ {Pair|U8} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} /\ {b|U7} ()
product, x13, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U11 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U10 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U6 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (6 0)
Trying x3
Checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A6
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A6)'
when checking x3 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x3)
                          ??
Trying x4
Checking x4 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH a PRODUCING {a|U12}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U12}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking map f0 x4 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A5|len _v == len x4} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A5|len _v == len x4} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U11} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument map f0
                       x4 of type {List A5|len _v == len x4}
Checking append (map f0
                   x4) :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len x4}) IN List A4 -> LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len x4}) IN List A4 -> LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len x4}) IN List A4 -> LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len x4}) IN List A4 -> LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
Simple Constraints
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len x9 + len x10 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Trying x3
Checking x3 :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A4)'
when checking x3 ::
x9:{List Pair a b|len _v == len x4} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          x3
Trying x7
Checking x7 :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A4)'
when checking x7 ::
x9:{List Pair a b|len _v == len x4} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          x7
Trying x8
Checking x8 :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
x9:{List Pair a b|len _v == len x4} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          x8
Trying xs
Checking xs :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
x9:{List Pair a b|len _v == len x4} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          xs
Trying ys
Checking ys :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
x9:{List Pair a b|len _v == len x4} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ys
Trying x4
Checking x4 :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
x9:{List Pair a b|len _v == len x4} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          x4
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append (map f0 x4)
           Nil :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len (Nil)} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len (Nil)} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len (Nil), len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len (Nil) && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                Nil ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          Nil
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X5 X4)} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x14 x15)} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x3 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons x3 ??)
Trying x7
Checking x7 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x7 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons x7 ??)
Trying x8
Checking x8 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons x8 ??)
Trying xs
Checking xs :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A7 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking xs :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons xs ??)
Trying ys
Checking ys :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons ys ??)
Trying x4
Checking x4 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A7 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking x4 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {a|U13} PRODUCING {a|U16}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Nil :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Cons Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)}
Trying Pair
Checking Pair :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A8 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
TYPE ERROR: Cannot match shape 'Pair (A7)'
with shape 'List'
when checking Pair ::
X5:_ -> X4:_ -> x9:{List Pair a b|len _v == len x4} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (Pair ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15}
Trying append
Checking append :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X5 + len X4} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x14 + len x15} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append x3 ??)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append x7 ??)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append x8 ??)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append xs ??)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append ys ??)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {Pair {a|U13} {b|U14}|U15} PRODUCING {Pair {a|U16} {b|U17}|U18}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U16} {b|U17}|U18}
product, x3, x4, x7, x8, xs, ys |- {b|U17}
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U15} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U17} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U16} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U17 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U14
  C2 && (M1 && (M3 && (U16 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking append
           Nil :: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} <: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} <: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil x3)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil x7)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil x8)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil xs)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil ys)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil x4)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {Pair {a|U13} {b|U14}|U15} PRODUCING {Pair {a|U19} {b|U20}|U21}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U19} {b|U20}|U21}
product, x3, x4, x7, x8, xs, ys |- {b|U20}
product, x3, x4, x7, x8, xs, ys |- {a|U19}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U15} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U20} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U19} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U20 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U14
  C2 && (M1 && (M3 && (U19 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking append Nil
           Nil :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil) + len (Nil)} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil) + len (Nil)} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument append Nil
                       Nil of type {List A7|len _v == len (Nil) + len (Nil)}
Checking append (map f0 x4)
           (append Nil
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil) + len (Nil)}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil) + len (Nil)}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) + len (Nil), len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (append Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (append Nil Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16}
Trying map
Checking map :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x16} /\ List ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Checking map
           f1 :: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} <: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} /\ X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} /\ X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} <: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x16} /\ List ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 x3)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 x7)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH b PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking map f1
           x8 :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x8} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x8} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       x8 of type {List A7|len _v == len x8}
Checking append (map f0 x4) (map
                               f1
                               x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x8}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x8}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x8, len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (map f1 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 x8)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH a PRODUCING {a|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument xs of type {List a|_v == xs}
Checking map f1
           xs :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len xs} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len xs} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len xs} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       xs of type {List A7|len _v == len xs}
Checking append (map f0 x4) (map
                               f1
                               xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len xs}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len xs}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len xs, len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (map f1 xs) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 xs)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH b PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument ys of type {List b|_v == ys}
Checking map f1
           ys :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len ys} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len ys} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       ys of type {List A7|len _v == len ys}
Checking append (map f0 x4) (map
                               f1
                               ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len ys}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len ys}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len ys, len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (map f1 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 ys)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH a PRODUCING {a|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking map f1
           x4 :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x4} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x4} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       x4 of type {List A7|len _v == len x4}
Checking append (map f0 x4) (map
                               f1
                               x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x4}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x4}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4, len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (map f1 x4) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 x4)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking map f1
           Nil :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil)} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil)} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A9|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument map f1
                       Nil of type {List A7|len _v == len (Nil)}
Checking append (map f0 x4) (map
                               f1
                               Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil)}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil)}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A9|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil), len x9 == len x4, len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len x4 && (len (Nil) == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (map f1 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (map f1 Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . <b> . x0:{List a|len _v >= 0 && len _v < len xs} -> ys:List b -> {List Pair a b|len _v == len x0 * len ys}
INTO x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15}
Trying product
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A8 -> {List {Pair {A7|False} {A8|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
Checking product :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A8 -> {List {Pair {A7|False} {A8|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {a|U6} PRODUCING {a|U13}
UNIFY A8 WITH {b|U7} PRODUCING {b|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: a ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U13} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X5 * len X4} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x14 * len x15} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x3 ??)
Trying x7
Checking x7 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x7 ??)
Trying x8
Checking x8 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x8 ??)
Trying xs
Checking xs :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A7|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Strengthening: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
_v == xs, xs == (Cons x3 x4), ys == (Cons x7 x8), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v >= 0 && len _v < len xs
assumption _v == xs && (xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v >= 0 && len _v < len xs)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product xs ??)
Trying ys
Checking ys :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product ys ??)
Trying x4
Checking x4 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A7|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking product
           x4 :: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} <: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} <: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 x3)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 x7)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product x4
           x8 :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len x8} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len x8} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument product x4
                       x8 of type {List Pair A7 A8|len _v == len x4 * len x8}
Checking append (map f0 x4)
           (product x4
              x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len x8}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len x8}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4 * len x8, len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (product x4 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 x8)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 xs)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product x4
           ys :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len ys} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len ys} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument product x4
                       ys of type {List Pair A7 A8|len _v == len x4 * len ys}
Checking append (map f0 x4)
           (product x4
              ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len ys}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len ys}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4 * len ys, len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (product x4 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 ys)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 x4)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {b|U14} PRODUCING {b|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U14} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking product x4
           Nil :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len (Nil)} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len (Nil)} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument product x4
                       Nil of type {List Pair A7 A8|len _v == len x4 * len (Nil)}
Checking append (map f0 x4)
           (product x4
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len (Nil)}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len (Nil)}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4 * len (Nil), len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (product x4 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product x4 Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: {List A7|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {a|U13} PRODUCING {a|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U13} ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 0} <: {List|len _v < len xs && len _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v < len xs && len _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking product
           Nil :: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} <: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} <: X4:_ -> LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil x3)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil x7)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product Nil
           x8 :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len x8} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len x8} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument product Nil
                       x8 of type {List Pair A7 A8|len _v == len (Nil) * len x8}
Checking append (map f0 x4)
           (product Nil
              x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len x8}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len x8}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) * len x8, len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (product Nil x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil x8)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil xs)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product Nil
           ys :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len ys} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len ys} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument product Nil
                       ys of type {List Pair A7 A8|len _v == len (Nil) * len ys}
Checking append (map f0 x4)
           (product Nil
              ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len ys}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len ys}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) * len ys, len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (product Nil ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil ys)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil x4)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A10
UNIFY A10 WITH {b|U14} PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U14} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument Nil of type {List {A10|False}|_v == (Nil)}
Checking product Nil
           Nil :: LET x9:({List A5|len _v == len x4}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len (Nil)} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len (Nil)} <: LET x9:({List A5|len _v == len x4}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument product Nil
                       Nil of type {List Pair A7 A8|len _v == len (Nil) * len (Nil)}
Checking append (map f0 x4)
           (product Nil
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len (Nil)}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len (Nil)}) IN LET x9:({List A5|len _v == len x4}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) * len (Nil), len x9 == len x4, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len x4 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x4)
                (product Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x4)
                          (product Nil Nil)
Trying x7
Checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A6
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A6)'
when checking x7 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x7)
                          ??
Trying x8
Checking x8 :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH b PRODUCING {b|U12}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U12}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking map f0 x8 :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A5|len _v == len x8} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A5|len _v == len x8} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U11} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument map f0
                       x8 of type {List A5|len _v == len x8}
Checking append (map f0
                   x8) :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len x8}) IN List A4 -> LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len x8}) IN List A4 -> LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len x8}) IN List A4 -> LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len x8}) IN List A4 -> LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
Simple Constraints
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len x9 + len x10 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Trying x3
Checking x3 :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A4)'
when checking x3 ::
x9:{List Pair a b|len _v == len x8} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          x3
Trying x4
Checking x4 :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
x9:{List Pair a b|len _v == len x8} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          x4
Trying x7
Checking x7 :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A4)'
when checking x7 ::
x9:{List Pair a b|len _v == len x8} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          x7
Trying xs
Checking xs :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
x9:{List Pair a b|len _v == len x8} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          xs
Trying ys
Checking ys :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
x9:{List Pair a b|len _v == len x8} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ys
Trying x8
Checking x8 :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
x9:{List Pair a b|len _v == len x8} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          x8
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append (map f0 x8)
           Nil :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len (Nil)} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len (Nil)} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len (Nil), len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len (Nil) && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                Nil ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          Nil
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X5 X4)} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x14 x15)} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x3 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons x3 ??)
Trying x4
Checking x4 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A7 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking x4 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons x4 ??)
Trying x7
Checking x7 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x7 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons x7 ??)
Trying xs
Checking xs :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A7 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking xs :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons xs ??)
Trying ys
Checking ys :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons ys ??)
Trying x8
Checking x8 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons x8 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {a|U13} PRODUCING {a|U16}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Nil :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Cons Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)}
Trying Pair
Checking Pair :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A8 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
TYPE ERROR: Cannot match shape 'Pair (A7)'
with shape 'List'
when checking Pair ::
X5:_ -> X4:_ -> x9:{List Pair a b|len _v == len x8} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (Pair ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15}
Trying append
Checking append :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X5 + len X4} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x14 + len x15} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append x3 ??)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append x4 ??)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append x7 ??)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append xs ??)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append ys ??)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append x8 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {Pair {a|U13} {b|U14}|U15} PRODUCING {Pair {a|U16} {b|U17}|U18}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U16} {b|U17}|U18}
product, x3, x4, x7, x8, xs, ys |- {b|U17}
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U15} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U17} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U16} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U17 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U14
  C2 && (M1 && (M3 && (U16 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking append
           Nil :: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} <: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} <: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil x3)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil x4)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil x7)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil xs)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil ys)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil x8)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {Pair {a|U13} {b|U14}|U15} PRODUCING {Pair {a|U19} {b|U20}|U21}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U19} {b|U20}|U21}
product, x3, x4, x7, x8, xs, ys |- {b|U20}
product, x3, x4, x7, x8, xs, ys |- {a|U19}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U15} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U20} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U19} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U20 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U14
  C2 && (M1 && (M3 && (U19 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking append Nil
           Nil :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil) + len (Nil)} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil) + len (Nil)} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument append Nil
                       Nil of type {List A7|len _v == len (Nil) + len (Nil)}
Checking append (map f0 x8)
           (append Nil
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil) + len (Nil)}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil) + len (Nil)}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) + len (Nil), len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (append Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (append Nil Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16}
Trying map
Checking map :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x16} /\ List ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Checking map
           f1 :: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} <: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} /\ X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} /\ X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} <: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x16} /\ List ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 x3)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH a PRODUCING {a|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking map f1
           x4 :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x4} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x4} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       x4 of type {List A7|len _v == len x4}
Checking append (map f0 x8) (map
                               f1
                               x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x4}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x4}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4, len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (map f1 x4) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 x4)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 x7)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH a PRODUCING {a|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument xs of type {List a|_v == xs}
Checking map f1
           xs :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len xs} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len xs} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len xs} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       xs of type {List A7|len _v == len xs}
Checking append (map f0 x8) (map
                               f1
                               xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len xs}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len xs}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len xs, len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (map f1 xs) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 xs)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH b PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument ys of type {List b|_v == ys}
Checking map f1
           ys :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len ys} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len ys} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       ys of type {List A7|len _v == len ys}
Checking append (map f0 x8) (map
                               f1
                               ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len ys}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len ys}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len ys, len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (map f1 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 ys)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH b PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking map f1
           x8 :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x8} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x8} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       x8 of type {List A7|len _v == len x8}
Checking append (map f0 x8) (map
                               f1
                               x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x8}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x8}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x8, len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (map f1 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 x8)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking map f1
           Nil :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil)} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil)} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A9|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument map f1
                       Nil of type {List A7|len _v == len (Nil)}
Checking append (map f0 x8) (map
                               f1
                               Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil)}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil)}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A9|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil), len x9 == len x8, len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len x8 && (len (Nil) == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (map f1 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (map f1 Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . <b> . x0:{List a|len _v >= 0 && len _v < len xs} -> ys:List b -> {List Pair a b|len _v == len x0 * len ys}
INTO x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15}
Trying product
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A8 -> {List {Pair {A7|False} {A8|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
Checking product :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A8 -> {List {Pair {A7|False} {A8|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {a|U6} PRODUCING {a|U13}
UNIFY A8 WITH {b|U7} PRODUCING {b|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: a ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U13} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X5 * len X4} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x14 * len x15} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x3 ??)
Trying x4
Checking x4 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A7|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking product
           x4 :: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} <: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} <: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 x3)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 x7)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 xs)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product x4
           ys :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len ys} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len ys} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument product x4
                       ys of type {List Pair A7 A8|len _v == len x4 * len ys}
Checking append (map f0 x8)
           (product x4
              ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len ys}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len ys}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4 * len ys, len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (product x4 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 ys)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 x4)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product x4
           x8 :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len x8} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len x8} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument product x4
                       x8 of type {List Pair A7 A8|len _v == len x4 * len x8}
Checking append (map f0 x8)
           (product x4
              x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len x8}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len x8}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4 * len x8, len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (product x4 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 x8)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {b|U14} PRODUCING {b|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U14} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking product x4
           Nil :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len (Nil)} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len (Nil)} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument product x4
                       Nil of type {List Pair A7 A8|len _v == len x4 * len (Nil)}
Checking append (map f0 x8)
           (product x4
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len (Nil)}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len (Nil)}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4 * len (Nil), len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (product x4 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x4 Nil)
Trying x7
Checking x7 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x7 ??)
Trying xs
Checking xs :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A7|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Strengthening: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
_v == xs, xs == (Cons x3 x4), ys == (Cons x7 x8), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v >= 0 && len _v < len xs
assumption _v == xs && (xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v >= 0 && len _v < len xs)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product xs ??)
Trying ys
Checking ys :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product ys ??)
Trying x8
Checking x8 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product x8 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: {List A7|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {a|U13} PRODUCING {a|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U13} ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 0} <: {List|len _v < len xs && len _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v < len xs && len _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking product
           Nil :: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} <: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} <: X4:_ -> LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil x3)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil x4)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil x7)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil xs)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product Nil
           ys :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len ys} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len ys} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument product Nil
                       ys of type {List Pair A7 A8|len _v == len (Nil) * len ys}
Checking append (map f0 x8)
           (product Nil
              ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len ys}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len ys}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) * len ys, len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (product Nil ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil ys)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product Nil
           x8 :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len x8} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len x8} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument product Nil
                       x8 of type {List Pair A7 A8|len _v == len (Nil) * len x8}
Checking append (map f0 x8)
           (product Nil
              x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len x8}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len x8}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) * len x8, len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (product Nil x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil x8)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A10
UNIFY A10 WITH {b|U14} PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U14} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument Nil of type {List {A10|False}|_v == (Nil)}
Checking product Nil
           Nil :: LET x9:({List A5|len _v == len x8}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len (Nil)} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len (Nil)} <: LET x9:({List A5|len _v == len x8}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument product Nil
                       Nil of type {List Pair A7 A8|len _v == len (Nil) * len (Nil)}
Checking append (map f0 x8)
           (product Nil
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len (Nil)}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len (Nil)}) IN LET x9:({List A5|len _v == len x8}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) * len (Nil), len x9 == len x8, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len x8 && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 x8)
                (product Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 x8)
                          (product Nil Nil)
Trying xs
Checking xs :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH a PRODUCING {a|U12}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U12}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument xs of type {List a|_v == xs}
Checking map f0 xs :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A5|len _v == len xs} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A5|len _v == len xs} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U11} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument map f0
                       xs of type {List A5|len _v == len xs}
Checking append (map f0
                   xs) :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len xs}) IN List A4 -> LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len xs}) IN List A4 -> LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len xs}) IN List A4 -> LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len xs}) IN List A4 -> LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
Simple Constraints
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len x9 + len x10 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Trying x3
Checking x3 :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A4)'
when checking x3 ::
x9:{List Pair a b|len _v == len xs} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          x3
Trying x4
Checking x4 :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
x9:{List Pair a b|len _v == len xs} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          x4
Trying x7
Checking x7 :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A4)'
when checking x7 ::
x9:{List Pair a b|len _v == len xs} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          x7
Trying x8
Checking x8 :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
x9:{List Pair a b|len _v == len xs} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          x8
Trying ys
Checking ys :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
x9:{List Pair a b|len _v == len xs} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ys
Trying xs
Checking xs :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
x9:{List Pair a b|len _v == len xs} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          xs
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append (map f0 xs)
           Nil :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len (Nil)} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len (Nil)} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len (Nil), len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len (Nil) && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                Nil ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          Nil
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X5 X4)} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x14 x15)} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x3 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons x3 ??)
Trying x4
Checking x4 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A7 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking x4 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons x4 ??)
Trying x7
Checking x7 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x7 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons x7 ??)
Trying x8
Checking x8 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons x8 ??)
Trying ys
Checking ys :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons ys ??)
Trying xs
Checking xs :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A7 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking xs :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons xs ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {a|U13} PRODUCING {a|U16}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Nil :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Cons Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)}
Trying Pair
Checking Pair :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A8 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
TYPE ERROR: Cannot match shape 'Pair (A7)'
with shape 'List'
when checking Pair ::
X5:_ -> X4:_ -> x9:{List Pair a b|len _v == len xs} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (Pair ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15}
Trying append
Checking append :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X5 + len X4} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x14 + len x15} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append x3 ??)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append x4 ??)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append x7 ??)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append x8 ??)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append ys ??)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append xs ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {Pair {a|U13} {b|U14}|U15} PRODUCING {Pair {a|U16} {b|U17}|U18}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U16} {b|U17}|U18}
product, x3, x4, x7, x8, xs, ys |- {b|U17}
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U15} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U17} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U16} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U17 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U14
  C2 && (M1 && (M3 && (U16 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking append
           Nil :: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} <: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} /\ X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} /\ X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} <: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil x3)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil x4)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil x7)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil x8)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil ys)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil xs)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {Pair {a|U13} {b|U14}|U15} PRODUCING {Pair {a|U19} {b|U20}|U21}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U19} {b|U20}|U21}
product, x3, x4, x7, x8, xs, ys |- {b|U20}
product, x3, x4, x7, x8, xs, ys |- {a|U19}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U15} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U20} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U19} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U20 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U14
  C2 && (M1 && (M3 && (U19 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking append Nil
           Nil :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil) + len (Nil)} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil) + len (Nil)} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument append Nil
                       Nil of type {List A7|len _v == len (Nil) + len (Nil)}
Checking append (map f0 xs)
           (append Nil
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil) + len (Nil)}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil) + len (Nil)}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) + len (Nil), len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (append Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (append Nil Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16}
Trying map
Checking map :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x16} /\ List ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Checking map
           f1 :: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} <: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} /\ X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} /\ X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} <: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x16} /\ List ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 x3)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH a PRODUCING {a|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking map f1
           x4 :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x4} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x4} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       x4 of type {List A7|len _v == len x4}
Checking append (map f0 xs) (map
                               f1
                               x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x4}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x4}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4, len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (map f1 x4) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 x4)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 x7)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH b PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking map f1
           x8 :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x8} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x8} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       x8 of type {List A7|len _v == len x8}
Checking append (map f0 xs) (map
                               f1
                               x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x8}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x8}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x8, len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (map f1 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 x8)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH b PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument ys of type {List b|_v == ys}
Checking map f1
           ys :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len ys} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len ys} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       ys of type {List A7|len _v == len ys}
Checking append (map f0 xs) (map
                               f1
                               ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len ys}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len ys}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len ys, len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (map f1 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 ys)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH a PRODUCING {a|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument xs of type {List a|_v == xs}
Checking map f1
           xs :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len xs} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len xs} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len xs} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       xs of type {List A7|len _v == len xs}
Checking append (map f0 xs) (map
                               f1
                               xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len xs}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len xs}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len xs, len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (map f1 xs) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 xs)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking map f1
           Nil :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil)} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil)} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A9|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument map f1
                       Nil of type {List A7|len _v == len (Nil)}
Checking append (map f0 xs) (map
                               f1
                               Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil)}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil)}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A9|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil), len x9 == len xs, len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len xs && (len (Nil) == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (map f1 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (map f1 Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . <b> . x0:{List a|len _v >= 0 && len _v < len xs} -> ys:List b -> {List Pair a b|len _v == len x0 * len ys}
INTO x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15}
Trying product
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A8 -> {List {Pair {A7|False} {A8|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
Checking product :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A8 -> {List {Pair {A7|False} {A8|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {a|U6} PRODUCING {a|U13}
UNIFY A8 WITH {b|U7} PRODUCING {b|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: a ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U13} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X5 * len X4} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x14 * len x15} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x3 ??)
Trying x4
Checking x4 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A7|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking product
           x4 :: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} <: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} <: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 x3)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 x7)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product x4
           x8 :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len x8} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len x8} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument product x4
                       x8 of type {List Pair A7 A8|len _v == len x4 * len x8}
Checking append (map f0 xs)
           (product x4
              x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len x8}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len x8}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4 * len x8, len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (product x4 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 x8)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product x4
           ys :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len ys} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len ys} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument product x4
                       ys of type {List Pair A7 A8|len _v == len x4 * len ys}
Checking append (map f0 xs)
           (product x4
              ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len ys}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len ys}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4 * len ys, len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (product x4 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 ys)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 x4)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 xs)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {b|U14} PRODUCING {b|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U14} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking product x4
           Nil :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len (Nil)} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len (Nil)} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument product x4
                       Nil of type {List Pair A7 A8|len _v == len x4 * len (Nil)}
Checking append (map f0 xs)
           (product x4
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len (Nil)}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len (Nil)}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4 * len (Nil), len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 * len (Nil) && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (product x4 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x4 Nil)
Trying x7
Checking x7 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x7 ??)
Trying x8
Checking x8 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product x8 ??)
Trying ys
Checking ys :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product ys ??)
Trying xs
Checking xs :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: {List A7|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Strengthening: C2 && (M1 && (M3 && (_v == xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
_v == xs, xs == (Cons x3 x4), ys == (Cons x7 x8), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: len _v >= 0 && len _v < len xs
assumption _v == xs && (xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
mustHave !(len _v >= 0 && len _v < len xs)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product xs ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: {List A7|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {a|U13} PRODUCING {a|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U15}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U13} ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == 0} <: {List|len _v < len xs && len _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (len _v == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v < len xs && len _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking product
           Nil :: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} <: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len (Nil) * len x15} <: X4:_ -> LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil x3)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil x4)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil x7)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product Nil
           x8 :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len x8} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len x8} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument product Nil
                       x8 of type {List Pair A7 A8|len _v == len (Nil) * len x8}
Checking append (map f0 xs)
           (product Nil
              x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len x8}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len x8}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) * len x8, len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len x8 && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (product Nil x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil x8)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product Nil
           ys :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len ys} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len ys} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument product Nil
                       ys of type {List Pair A7 A8|len _v == len (Nil) * len ys}
Checking append (map f0 xs)
           (product Nil
              ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len ys}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len ys}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) * len ys, len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len ys && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (product Nil ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil ys)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil xs)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A10
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A10|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A10|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A10
UNIFY A10 WITH {b|U14} PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U14} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument Nil of type {List {A10|False}|_v == (Nil)}
Checking product Nil
           Nil :: LET x9:({List A5|len _v == len xs}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len (Nil)} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len (Nil) * len (Nil)} <: LET x9:({List A5|len _v == len xs}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) * len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument product Nil
                       Nil of type {List Pair A7 A8|len _v == len (Nil) * len (Nil)}
Checking append (map f0 xs)
           (product Nil
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len (Nil)}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len (Nil) * len (Nil)}) IN LET x9:({List A5|len _v == len xs}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {b|U16}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {a|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {a|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len xs && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) * len (Nil), len x9 == len xs, len ((Cons x3 x4)) == 1 + len x4, len (Nil) == 0, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) * len (Nil) && (len x9 == len xs && (len ((Cons x3 x4)) == 1 + len x4 && (len (Nil) == 0 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 xs)
                (product Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 xs)
                          (product Nil Nil)
Trying ys
Checking ys :: List A6 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ??)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A6 ()
product, x3, x4, x7, x8, xs, ys |- A6
UNIFY A6 WITH b PRODUCING {b|U12}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U12}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U12} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U12
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument ys of type {List b|_v == ys}
Checking map f0 ys :: List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A5|len _v == len ys} <: List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A5|len _v == len ys} <: List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|len _v == len ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|U11} <: {Pair|U8} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U10} <: {b|U7} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U9} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Synthesized argument map f0
                       ys of type {List A5|len _v == len ys}
Checking append (map f0
                   ys) :: X0:_ -> {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ?? ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len ys}) IN List A4 -> LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len ys}) IN List A4 -> LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len ys}) IN List A4 -> LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} /\ X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x10:LET x9:({List A5|len _v == len ys}) IN List A4 -> LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: X0:_ -> {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
Simple Constraints
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len X0} <: {List|len _v == len xs * len ys} ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} /\ {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} /\ Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} /\ b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} /\ a ()
Pred assignment
addSplitConstraint X0, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len X0} <: {List|len _v == len xs * len ys} ()
Constraints
  False ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (len _v == len xs * len ys && (len _v == len x9 + len x10 && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (7 0)
Trying x3
Checking x3 :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A4)'
when checking x3 ::
x9:{List Pair a b|len _v == len ys} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          x3
Trying x4
Checking x4 :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
x9:{List Pair a b|len _v == len ys} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          x4
Trying x7
Checking x7 :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A4)'
when checking x7 ::
x9:{List Pair a b|len _v == len ys} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          x7
Trying x8
Checking x8 :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
x9:{List Pair a b|len _v == len ys} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          x8
Trying xs
Checking xs :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
x9:{List Pair a b|len _v == len ys} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          xs
Trying ys
Checking ys :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
x9:{List Pair a b|len _v == len ys} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ys
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A7|False}|_v == (Nil)}
Trying Nil
Checking Nil :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A7|False}|_v == (Nil)} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 0)
Synthesized argument Nil of type {List {A7|False}|_v == (Nil)}
Checking append (map f0 ys)
           Nil :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len (Nil)} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len (Nil)} <: {List|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len (Nil)} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len (Nil) && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0)))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len (Nil), len x9 == len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len (Nil) && (len x9 == len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && len x9 >= 0))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 ys)
                Nil ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          Nil
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)}
Trying Cons
Checking Cons :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A7 -> x15:List A7 -> {List A7|_v == (Cons x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons X5 X4)} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|_v == (Cons x14 x15)} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x3 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons x3 ??)
Trying x4
Checking x4 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: A7 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking x4 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons x4 ??)
Trying x7
Checking x7 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x7 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons x7 ??)
Trying x8
Checking x8 :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons x8 ??)
Trying xs
Checking xs :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: A7 ()
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking xs :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons xs ??)
Trying ys
Checking ys :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {a|U13} PRODUCING {a|U16}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Nil :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Cons Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)}
Trying Pair
Checking Pair :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:A8 -> x15:A7 -> {Pair A8 A7|_v == (Pair x14 x15)} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A8 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
TYPE ERROR: Cannot match shape 'Pair (A7)'
with shape 'List'
when checking Pair ::
X5:_ -> X4:_ -> x9:{List Pair a b|len _v == len ys} -> List Pair a b
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (Pair ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
INSTANTIATE <a> . xs:List a -> ys:List a -> {List a|len _v == len xs + len ys}
INTO x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15}
Trying append
Checking append :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A7 -> {List A7|len _v == len x14 + len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X5 + len X4} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x14 + len x15} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append x3 ??)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append x4 ??)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append x7 ??)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append x8 ??)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append xs ??)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append ys ??)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A8|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A8|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH {Pair {a|U13} {b|U14}|U15} PRODUCING {Pair {a|U16} {b|U17}|U18}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U16} {b|U17}|U18}
product, x3, x4, x7, x8, xs, ys |- {b|U17}
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U15} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U17} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U16} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U17 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U14
  C2 && (M1 && (M3 && (U16 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument Nil of type {List {A8|False}|_v == (Nil)}
Checking append
           Nil :: X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} <: X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} /\ X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} /\ X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A7 -> {List A7|len _v == len (Nil) + len x15} <: X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x3
Checking x3 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil x3)
Trying x4
Checking x4 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x4 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil x4)
Trying x7
Checking x7 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A7)'
when checking x7 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil x7)
Trying x8
Checking x8 :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x8 ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil x8)
Trying xs
Checking xs :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A7 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking xs ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil xs)
Trying ys
Checking ys :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A7 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking ys ::
List Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A7 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A7 ()
product, x3, x4, x7, x8, xs, ys |- A9
UNIFY A9 WITH {Pair {a|U13} {b|U14}|U15} PRODUCING {Pair {a|U19} {b|U20}|U21}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U19} {b|U20}|U21}
product, x3, x4, x7, x8, xs, ys |- {b|U20}
product, x3, x4, x7, x8, xs, ys |- {a|U19}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: {Pair|U15} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|U20} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|U19} <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U20 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U14
  C2 && (M1 && (M3 && (U19 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking append Nil
           Nil :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil) + len (Nil)} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil) + len (Nil)} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil) + len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Synthesized argument append Nil
                       Nil of type {List A7|len _v == len (Nil) + len (Nil)}
Checking append (map f0 ys)
           (append Nil
              Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil) + len (Nil)}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil) + len (Nil)}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {Pair {a|U16} {b|U17}|U18}
A9 -> {Pair {a|U19} {b|U20}|U21}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U17 -> {}
  U18 -> {}
  U19 -> {}
  U2 -> {}
  U20 -> {}
  U21 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U17 -> {}, U18 -> {}, U19 -> {}, U2 -> {}, U20 -> {}, U21 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil) + len (Nil), len x9 == len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len (Nil) == 0, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) + len (Nil) && (len x9 == len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len (Nil) == 0 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 ys)
                (append Nil Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (append Nil Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <b> . <a> . f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
INTO x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16}
Trying map
Checking map :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:(x15:A8 -> A7) -> x16:List A8 -> {List A7|len _v == len x16} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {Pair {a|U6} {b|U7}|U8} PRODUCING {Pair {a|U13} {b|U14}|U15}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Typing Constraints
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {Pair {a|U13} {b|U14}|U15}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys |- {a|U13}
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x16} /\ List ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Checking map
           f1 :: X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} <: X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} /\ X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} /\ X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x16:List A8 -> {List A7|len _v == len x16} <: X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x16} /\ List ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} /\ {Pair|U8} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x16, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U15 && (U8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 x3)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH a PRODUCING {a|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking map f1
           x4 :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x4} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x4} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       x4 of type {List A7|len _v == len x4}
Checking append (map f0 ys) (map
                               f1
                               x4) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x4}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x4}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4, len x9 == len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 && (len x9 == len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 ys)
                (map f1 x4) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 x4)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 x7)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH b PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking map f1
           x8 :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x8} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len x8} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       x8 of type {List A7|len _v == len x8}
Checking append (map f0 ys) (map
                               f1
                               x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x8}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len x8}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x8, len x9 == len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x8 && (len x9 == len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 ys)
                (map f1 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 x8)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH a PRODUCING {a|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == xs} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument xs of type {List a|_v == xs}
Checking map f1
           xs :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len xs} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len xs} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len xs} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       xs of type {List A7|len _v == len xs}
Checking append (map f0 ys) (map
                               f1
                               xs) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len xs}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len xs}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {a|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len xs, len x9 == len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len xs && (len x9 == len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 ys)
                (map f1 xs) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 xs)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A8
UNIFY A8 WITH b PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U16} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument ys of type {List b|_v == ys}
Checking map f1
           ys :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len ys} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len ys} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 0)
Synthesized argument map f1
                       ys of type {List A7|len _v == len ys}
Checking append (map f0 ys) (map
                               f1
                               ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len ys}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len ys}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
A8 -> {b|U16}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len ys, len x9 == len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len ys && (len x9 == len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 ys)
                (map f1 ys) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 ys)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List {A9|False}|_v == (Nil)} <: List A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == (Nil)} <: List ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument Nil of type {List {A9|False}|_v == (Nil)}
Checking map f1
           Nil :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil)} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List A7|len _v == len (Nil)} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A9|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len (Nil)} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U15} <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Synthesized argument map f1
                       Nil of type {List A7|len _v == len (Nil)}
Checking append (map f0 ys) (map
                               f1
                               Nil) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil)}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List A7|len _v == len (Nil)}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {A9|False} <: A8 ()
product, x3, x4, x7, x8, xs, ys |- A9
product, x3, x4, x7, x8, xs, ys |- A8
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {Pair {a|U13} {b|U14}|U15}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len (Nil), len x9 == len ys, len (Nil) == 0, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len (Nil) && (len x9 == len ys && (len (Nil) == 0 && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0))))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 ys)
                (map f1 Nil) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (map f1 Nil)
Adding constraint product, x3, x4, x7, x8, xs, ys |- A7
Adding constraint product, x3, x4, x7, x8, xs, ys |- A8
INSTANTIATE <a> . <b> . x0:{List a|len _v >= 0 && len _v < len xs} -> ys:List b -> {List Pair a b|len _v == len x0 * len ys}
INTO x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15}
Trying product
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A8 -> {List {Pair {A7|False} {A8|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
Checking product :: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (?? ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} /\ X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:{List A7|len _v >= 0 && len _v < len xs} -> x15:List A8 -> {List Pair A7 A8|len _v == len x14 * len x15} <: X5:_ -> X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x14:List A7 -> x15:List A8 -> {List {Pair {A7|False} {A8|False}|False}|False} <: xs:{List {a|False}|False} -> ys:{List {b|False}|False} -> List Pair a b ()
product, x3, x4, x7, x8, xs, ys |- A8
product, x3, x4, x7, x8, xs, ys |- A7
UNIFY A7 WITH {a|U6} PRODUCING {a|U13}
UNIFY A8 WITH {b|U7} PRODUCING {b|U14}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys |- {a|U13}
product, x3, x4, x7, x8, xs, ys |- {b|U14}
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Pair|False} <: Pair ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: b ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: a ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|False} <: {b|U14} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|False} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U13} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len X5 * len X4} <: List ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, X5, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x14 * len x15} /\ List ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x14, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (10 0)
Trying x3
Checking x3 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: {List A7|len _v >= 0 && len _v < len xs} ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A7)'
when checking x3 ::
{List a|len _v >= 0 && len _v < len xs}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x3 ??)
Trying x4
Checking x4 :: {List A7|len _v >= 0 && len _v < len xs} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product ?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A7|len _v >= 0 && len _v < len xs} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: {List A7|len _v >= 0 && len _v < len xs} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x4} <: {List|len _v >= 0 && len _v < len xs} ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- a <: {a|U13} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Synthesized argument x4 of type {List a|_v == x4}
Checking product
           x4 :: X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (?? ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} <: X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} /\ X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- x15:List A8 -> {List Pair A7 A8|len _v == len x4 * len x15} <: X4:_ -> LET x9:({List A5|len _v == len ys}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len X4} <: List ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
X4, product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x15} /\ List ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair /\ {Pair|U8} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} /\ {b|U7} ()
product, x15, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} /\ {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (M1 && (M3 && (U14 && (U7 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
  C2 && (M1 && (M3 && (U13 && (U6 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (12 0)
Trying x3
Checking x3 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {a|_v == x3} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'List (A8)'
when checking x3 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x4 x3)
Trying x7
Checking x7 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {b|_v == x7} <: List A8 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'List (A8)'
when checking x7 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x4 x7)
Trying x8
Checking x8 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == x8} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == x8} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument x8 of type {List b|_v == x8}
Checking product x4
           x8 :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len x8} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len x8} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len x8} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument product x4
                       x8 of type {List Pair A7 A8|len _v == len x4 * len x8}
Checking append (map f0 ys)
           (product x4
              x8) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len x8}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len x8}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Strengthening: C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
xs == (Cons x3 x4), ys == (Cons x7 x8), len _v == len x9 + len x10, len x10 == len x4 * len x8, len x9 == len ys, len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0, len x10 >= 0, len x9 >= 0
RHS: len _v == len xs * len ys
assumption xs == (Cons x3 x4) && (ys == (Cons x7 x8) && (len _v == len x9 + len x10 && (len x10 == len x4 * len x8 && (len x9 == len ys && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))))
mustHave !(len _v == len xs * len ys)
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking append (map f0 ys)
                (product x4 x8) ::
{List Pair a b|len _v == len xs * len ys}
in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x4 x8)
Trying xs
Checking xs :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == xs} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking xs :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x4 xs)
Trying x4
Checking x4 :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List a|_v == x4} <: List A8 ()
TYPE ERROR: Cannot match shape 'a'
with shape 'b'
when checking x4 :: List b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x4 x4)
Trying ys
Checking ys :: List A8 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          (product x4 ??)
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List b|_v == ys} <: List A8 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List|_v == ys} <: List ()
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- b <: {b|U14} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument ys of type {List b|_v == ys}
Checking product x4
           ys :: LET x9:({List A5|len _v == len ys}) IN List A4 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> append (map f0 ys)
                          ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len ys} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {List Pair A7 A8|len _v == len x4 * len ys} <: LET x9:({List A5|len _v == len ys}) IN List A4 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x4 * len ys} <: List ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- Pair <: {Pair|U8} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U14} <: {b|U7} ()
product, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U13} <: {a|U6} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (13 0)
Synthesized argument product x4
                       ys of type {List Pair A7 A8|len _v == len x4 * len ys}
Checking append (map f0 ys)
           (product x4
              ys) :: {List Pair a b|len _v == len xs * len ys} in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> ??
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len ys}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- LET x10:({List Pair A7 A8|len _v == len x4 * len ys}) IN LET x9:({List A5|len _v == len ys}) IN {List A4|len _v == len x9 + len x10} <: {List Pair a b|len _v == len xs * len ys} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {Pair|U8} <: Pair ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {b|U7} <: b ()
product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint product, x10, x3, x4, x7, x8, x9, xs, ys True, C2, M1, M3 |- {List|len _v == len x9 + len x10} <: {List|len _v == len xs * len ys} ()
Constraints
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 0)
Auxiliary goals are:
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- f0 :: x12:A6 -> A5
f0 = ??
(depth: 0)
PICK AUXILIARY GOAL product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- f0 :: x12:A6 -> A5
f0 = ??
(depth: 0)
Checking error in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> error
Adding constraint product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Int|x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys))))} <: {Int|False} ()
Typing Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Int|x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys))))} <: {Int|False} ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
Simple Constraints
product, x3, x4, x7, x8, xs, ys True, C2, M1, M3 |- {Int|x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys))))} <: {Int|False} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys))))))))))) ==> False
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Chosen candidate: 0.1: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (14 1)
Invalid Constraint: C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys))))))))))) ==> False
Strengthening: C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (x8 == x8 && ys == ys))))))))))) ==> False
Instantiated axioms:
len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8
All assumptions:
x3 == x3, x7 == x7, x4 == x4, xs == xs, xs == (Cons x3 x4), x8 == x8, ys == ys, ys == (Cons x7 x8), len ((Cons x3 x4)) == 1 + len x4, len ((Cons x7 x8)) == 1 + len x8, len x4 >= 0, len xs >= 0, len x8 >= 0, len ys >= 0
RHS: False
assumption True
mustHave x3 == x3 && (x7 == x7 && (x4 == x4 && (xs == xs && (xs == (Cons x3 x4) && (x8 == x8 && (ys == ys && (ys == (Cons x7 x8) && (len ((Cons x3 x4)) == 1 + len x4 && (len ((Cons x7 x8)) == 1 + len x8 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))))))
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> error
Adding constraint product, x12, x3, x4, x7, x8, xs, ys |- C3
Looking for type {Pair {a|U9} {b|U10}|U11}
Trying x12
Checking x12 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {A6|_v == x12} <: A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {A6|_v == x12} <: A5 ()
product, x12, x3, x4, x7, x8, xs, ys |- C3
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x12 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . x12
Trying x3
Checking x3 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {a|_v == x3} <: A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {a|_v == x3} <: A5 ()
product, x12, x3, x4, x7, x8, xs, ys |- C3
TYPE ERROR: Cannot match shape 'a'
with shape 'Pair (a) (b)'
when checking x3 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . x3
Trying x7
Checking x7 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {b|_v == x7} <: A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {b|_v == x7} <: A5 ()
product, x12, x3, x4, x7, x8, xs, ys |- C3
TYPE ERROR: Cannot match shape 'b'
with shape 'Pair (a) (b)'
when checking x7 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . x7
Trying x8
Checking x8 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {List b|_v == x8} <: A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {List b|_v == x8} <: A5 ()
product, x12, x3, x4, x7, x8, xs, ys |- C3
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x8 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . x8
Trying xs
Checking xs :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {List a|_v == xs} <: A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {List a|_v == xs} <: A5 ()
product, x12, x3, x4, x7, x8, xs, ys |- C3
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking xs :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . xs
Trying x4
Checking x4 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {List a|_v == x4} <: A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {List a|_v == x4} <: A5 ()
product, x12, x3, x4, x7, x8, xs, ys |- C3
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking x4 :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . x4
Trying ys
Checking ys :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {List b|_v == ys} <: A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {List b|_v == ys} <: A5 ()
product, x12, x3, x4, x7, x8, xs, ys |- C3
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking ys :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ys
Adding constraint product, x12, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . {List a|_v == (Nil)}
INTO {List {A9|False}|_v == (Nil)}
Trying Nil
Checking Nil :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {List {A9|False}|_v == (Nil)} <: A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {List {A9|False}|_v == (Nil)} <: A5 ()
product, x12, x3, x4, x7, x8, xs, ys |- A9
product, x12, x3, x4, x7, x8, xs, ys |- C3
UNIFY A9 WITH {a|U9} PRODUCING {a|U15}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Nil :: Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . Nil
Adding constraint product, x12, x3, x4, x7, x8, xs, ys |- A9
INSTANTIATE <a> . x:a -> xs:List a -> {List a|_v == (Cons x xs)}
INTO x16:A9 -> x17:List A9 -> {List A9|_v == (Cons x16 x17)}
Trying Cons
Checking Cons :: X7:_ -> X6:_ -> A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ?? ?? ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x16:A9 -> x17:List A9 -> {List A9|_v == (Cons x16 x17)} <: X7:_ -> X6:_ -> A5 ()
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x16:A9 -> x17:List A9 -> {List A9|_v == (Cons x16 x17)} /\ X7:_ -> X6:_ -> A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x16:A9 -> x17:List A9 -> {List A9|_v == (Cons x16 x17)} /\ X7:_ -> X6:_ -> A5 ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x16:A9 -> x17:List A9 -> {List A9|_v == (Cons x16 x17)} <: X7:_ -> X6:_ -> A5 ()
product, x12, x3, x4, x7, x8, xs, ys |- A9
product, x12, x3, x4, x7, x8, xs, ys |- C3
UNIFY A9 WITH {a|U9} PRODUCING {a|U15}
TYPE ERROR: Cannot match shape 'List'
with shape 'Pair (b)'
when checking Cons ::
X7:_ -> X6:_ -> Pair a b in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . Cons ?? ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys |- A9
Adding constraint product, x12, x3, x4, x7, x8, xs, ys |- A10
INSTANTIATE <b> . <a> . x:a -> y:b -> {Pair a b|_v == (Pair x y)}
INTO x16:A10 -> x17:A9 -> {Pair A10 A9|_v == (Pair x16 x17)}
Trying Pair
Checking Pair :: X7:_ -> X6:_ -> A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ?? ?? ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x16:A10 -> x17:A9 -> {Pair A10 A9|_v == (Pair x16 x17)} <: X7:_ -> X6:_ -> A5 ()
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x16:A10 -> x17:A9 -> {Pair A10 A9|_v == (Pair x16 x17)} /\ X7:_ -> X6:_ -> A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x16:A10 -> x17:A9 -> {Pair A10 A9|_v == (Pair x16 x17)} /\ X7:_ -> X6:_ -> A5 ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x16:A10 -> x17:A9 -> {Pair A10 A9|_v == (Pair x16 x17)} <: X7:_ -> X6:_ -> A5 ()
product, x12, x3, x4, x7, x8, xs, ys |- A10
product, x12, x3, x4, x7, x8, xs, ys |- A9
product, x12, x3, x4, x7, x8, xs, ys |- C3
UNIFY A10 WITH {a|U9} PRODUCING {a|U15}
UNIFY A9 WITH {b|U10} PRODUCING {b|U16}
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U15}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U16}
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U15}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U16}
Simple Constraints
product, x12, x3, x4, x7, x8, xs, ys |- C3
product, x12, x3, x4, x7, x8, xs, ys |- {b|U16}
product, x12, x3, x4, x7, x8, xs, ys |- {a|U15}
X6, X7, product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {Pair|_v == (Pair X7 X6)} <: {Pair|U11} ()
X6, X7, product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {b|U16} <: {b|U10} ()
X6, X7, product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {a|U15} <: {a|U9} ()
product, x12, x16, x17, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {Pair|_v == (Pair x16 x17)} /\ {Pair|U11} ()
product, x12, x16, x17, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {b|U16} /\ {b|U10} ()
product, x12, x16, x17, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {a|U15} /\ {a|U9} ()
Pred assignment
Constraints
  False ==> U11
  C2 && (C3 && (M1 && (M3 && (U16 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))) ==> U10
  C2 && (C3 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  C3 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (C3 && (M1 && (M3 && (U11 && ([_v -> x16]U15 && ([_v -> x17]U16 && (_v == (Pair x16 x17) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))))
  C2 && (C3 && (M1 && (M3 && (U10 && (U16 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
  C2 && (C3 && (M1 && (M3 && (U15 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (17 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (17 0)
Trying x12
Checking x12 :: A10 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . Pair ?? ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {A6|_v == x12} <: A10 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {A6|_v == x12} <: A10 ()
TYPE ERROR: Cannot match shape 'b'
with shape 'a'
when checking x12 :: a in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . Pair x12 ??
Trying x3
Checking x3 :: A10 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . Pair ?? ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {a|_v == x3} <: A10 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {a|_v == x3} <: A10 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U15}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U16}
Simple Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {a|_v == x3} <: {a|U15} ()
Pred assignment
Constraints
  C2 && (C3 && (M1 && (M3 && (_v == x3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))) ==> U15
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  C3 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (18 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (18 0)
Synthesized argument x3 of type {a|_v == x3}
Checking Pair
           x3 :: X6:_ -> A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ?? ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x17:A9 -> {Pair A10 A9|_v == (Pair x3 x17)} <: X6:_ -> A5 ()
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x17:A9 -> {Pair A10 A9|_v == (Pair x3 x17)} /\ X6:_ -> A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x17:A9 -> {Pair A10 A9|_v == (Pair x3 x17)} /\ X6:_ -> A5 ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- x17:A9 -> {Pair A10 A9|_v == (Pair x3 x17)} <: X6:_ -> A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U15}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U16}
Simple Constraints
X6, product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {Pair|_v == (Pair x3 X6)} <: {Pair|U11} ()
X6, product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {b|U16} <: {b|U10} ()
X6, product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {a|U15} <: {a|U9} ()
product, x12, x17, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {Pair|_v == (Pair x3 x17)} /\ {Pair|U11} ()
product, x12, x17, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {b|U16} /\ {b|U10} ()
product, x12, x17, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {a|U15} /\ {a|U9} ()
Pred assignment
Constraints
  False ==> U11
  C2 && (C3 && (M1 && (M3 && (U16 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))) ==> U10
  C2 && (C3 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  C3 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
  C2 && (C3 && (M1 && (M3 && (U11 && ([_v -> x17]U16 && (_v == (Pair x3 x17) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))))
  C2 && (C3 && (M1 && (M3 && (U10 && (U16 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
  C2 && (C3 && (M1 && (M3 && (U15 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))))
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (18 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (18 0)
Trying x12
Checking x12 :: A9 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . Pair x3 ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {A6|_v == x12} <: A9 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {A6|_v == x12} <: A9 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U15}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U16}
Simple Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {b|_v == x12} <: {b|U16} ()
Pred assignment
Constraints
  C2 && (C3 && (M1 && (M3 && ([_v -> x12]U12 && (_v == x12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> U16
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  C3 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (19 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (19 0)
Synthesized argument x12 of type {A6|_v == x12}
Checking Pair x3 x12 :: A5 in
\xs . \ys . 
    match xs with
      Cons x3 x4 -> 
        match ys with
          Cons x7 x8 -> \x12 . ??
Adding constraint product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {Pair A10 A9|_v == (Pair x3 x12)} <: A5 ()
Typing Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {Pair A10 A9|_v == (Pair x3 x12)} <: A5 ()
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U15}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U16}
Simple Constraints
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {Pair|_v == (Pair x3 x12)} <: {Pair|U11} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {b|U16} <: {b|U10} ()
product, x12, x3, x4, x7, x8, xs, ys True, C2, C3, M1, M3 |- {a|U15} <: {a|U9} ()
Pred assignment
Constraints
  C2 && (C3 && (M1 && (M3 && ([_v -> x12]U12 && (_v == (Pair x3 x12) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> U11
  C2 && (C3 && (M1 && (M3 && (U16 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))) ==> U10
  C2 && (C3 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))) ==> U9
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  C3 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (20 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (20 0)
Typing Constraints
Type assignment
A0 -> {Pair {a|U0} {b|U1}|U2}
A1 -> a
A10 -> {a|U15}
A2 -> {Pair {a|U3} {b|U4}|U5}
A3 -> b
A4 -> {Pair {a|U6} {b|U7}|U8}
A5 -> {Pair {a|U9} {b|U10}|U11}
A6 -> {b|U12}
A7 -> {a|U13}
A8 -> {b|U14}
A9 -> {b|U16}
Simple Constraints
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {}
  C3 -> {}
  M0 -> {ys == (Nil), xs == (Nil)}
  M1 -> {xs == (Cons x3 x4)}
  M2 -> {ys == (Nil)}
  M3 -> {ys == (Cons x7 x8)}
  U0 -> {}
  U1 -> {}
  U10 -> {}
  U11 -> {}
  U12 -> {}
  U13 -> {}
  U14 -> {}
  U15 -> {}
  U16 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
  U5 -> {}
  U6 -> {}
  U7 -> {}
  U8 -> {}
  U9 -> {}
Checking consistency
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (20 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {ys == (Cons x7 x8)}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (20 0)
Auxiliary goals are:
Auxiliary goals are:
Re-checking candidates after updating M3
Checking validity
  C2 && (C3 && (M1 && (M3 && (U15 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))) ==> U9
  C2 && (C3 && (M1 && (M3 && (U16 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))) ==> U10
  C2 && (C3 && (M1 && (M3 && ([_v -> x12]U12 && (_v == x12 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> U16
  C2 && (C3 && (M1 && (M3 && ([_v -> x12]U12 && (_v == (Pair x3 x12) && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))))) ==> U11
  C2 && (C3 && (M1 && (M3 && (_v == x3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))))) ==> U15
  C2 && (M1 && (M3 && (U10 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U11 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U8
  C2 && (M1 && (M3 && (U13 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
  C2 && (M1 && (M3 && (U14 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U7
  C2 && (M1 && (M3 && (U9 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> U6
  C2 && (M1 && (M3 && (_v == x4 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0)))))) ==> len _v >= 0 && len _v < len xs
  C2 && (M1 && (M3 && (len _v == len x9 + len x10 && (len x10 == len x4 * len ys && (len x9 == len ys && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && (len ys >= 0 && (len x10 >= 0 && len x9 >= 0)))))))))) ==> len _v == len xs * len ys
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U12
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U13
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U14
  C2 && (M1 && (M3 && (len x4 >= 0 && (len xs >= 0 && (len x8 >= 0 && len ys >= 0))))) ==> U8
Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (20 0)
Remaining Candidates (1)
  0.1: [C0 -> {}, C1 -> {}, C2 -> {}, C3 -> {}, M0 -> {xs == (Nil)}, M1 -> {xs == (Cons x3 x4)}, M2 -> {ys == (Nil)}, M3 -> {}, U0 -> {}, U1 -> {}, U10 -> {}, U11 -> {}, U12 -> {}, U13 -> {}, U14 -> {}, U15 -> {}, U16 -> {}, U2 -> {}, U3 -> {}, U4 -> {}, U5 -> {}, U6 -> {}, U7 -> {}, U8 -> {}, U9 -> {}] (20 0)
