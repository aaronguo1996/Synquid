ADD __goal__ : All {a,}. {{IList |  | a, |  | },{IList |  | a, |  | },}->{IList |  | a, |  | }
ADD ICons : All {A0,}. {A0,{IList |  | A0, |  | },}->{IList |  | A0, |  | }
ADD INil : All {A1,}. {IList |  | A1, |  | }
ADD merge : All {A2,}. {{IList |  | A2, |  | },{IList |  | A2, |  | },}->{IList |  | A2, |  | }
Checking error in
error
Typing Constraints
merge |- Int <: {Int|False} ()
Type assignment
Simple Constraints
merge |- Int <: {Int|False} ()
Pred assignment
Constraints
  True ==> False
QMap
Candidates (1)
  0: [] (0 1)
Chosen candidate: 0: [] (0 1)
Invalid Constraint: True ==> False
Strengthening: True ==> False
Instantiated axioms:
All assumptions:
True
RHS: False
assumption True
mustHave True
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
error
ADD xs : All {a,}. {IList |  | a, |  | }
ADD ys : All {a,}. {IList |  | a, |  | }
Checking error in
\xs . \ys . error
Typing Constraints
merge, xs, ys C0, M0 |- {Int|xs == xs && ys == ys} <: {Int|False} ()
merge, xs, ys |- C0
merge, xs, ys |- (match) M0
Type assignment
Simple Constraints
merge, xs, ys |- (match) M0
merge, xs, ys |- C0
merge, xs, ys C0, M0 |- {Int|xs == xs && ys == ys} <: {Int|False} ()
Pred assignment
Constraints
  C0 && (M0 && (ilen xs >= 0 && (ilen ys >= 0 && (xs == xs && ys == ys)))) ==> False
QMap
  C0 -> {}
  M0 -> {ys == (INil), xs == (INil)}
Candidates (1)
  0: [C0 -> {}, M0 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}, M0 -> {}] (0 1)
Invalid Constraint: C0 && (M0 && (ilen xs >= 0 && (ilen ys >= 0 && (xs == xs && ys == ys)))) ==> False
Strengthening: C0 && (M0 && (ilen xs >= 0 && (ilen ys >= 0 && (xs == xs && ys == ys)))) ==> False
Instantiated axioms:
ilen (INil) == 0, ielems (INil) == []
All assumptions:
xs == xs, ys == ys, ilen (INil) == 0, ielems (INil) == [], ilen xs >= 0, ilen ys >= 0
RHS: False
assumption True
mustHave xs == xs && (ys == ys && (ilen (INil) == 0 && (ielems (INil) == [] && (ilen xs >= 0 && ilen ys >= 0))))
qualsList [xs == (INil)
          ,ys == (INil)]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\xs . \ys . error
Looking for type {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
*******************Filling holes in (?? :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys})
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A3|False}|_v == (INil)}
Checking INil :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . ??
Typing Constraints
merge, xs, ys C0, M0 |- {IList {A3|False}|_v == (INil)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, xs, ys |- A3
merge, xs, ys |- C0
merge, xs, ys |- (match) M0
UNIFY A3 WITH a PRODUCING {a|U0}
Type assignment
A3 -> {a|U0}
Typing Constraints
Type assignment
A3 -> {a|U0}
Simple Constraints
merge, xs, ys |- (match) M0
merge, xs, ys |- C0
merge, xs, ys |- {a|U0}
merge, xs, ys C0, M0 |- {IList|_v == (INil)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, xs, ys C0, M0 |- {a|False} <: a ()
Pred assignment
addSplitConstraint merge, xs, ys C0, M0 |- {IList|ilen _v == 0} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, xs, ys C0, M0 |- {IList|ielems _v == []} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C0 && (M0 && (ilen _v == 0 && (ilen xs >= 0 && ilen ys >= 0))) ==> ilen _v == ilen xs + ilen ys
  C0 && (M0 && (ielems _v == [] && (ilen xs >= 0 && ilen ys >= 0))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  U0 -> {}
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (0 2)
Chosen candidate: 0: [C0 -> {}, M0 -> {}, U0 -> {}] (0 2)
Invalid Constraint: C0 && (M0 && (ilen _v == 0 && (ilen xs >= 0 && ilen ys >= 0))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C0 && (M0 && (ilen _v == 0 && (ilen xs >= 0 && ilen ys >= 0))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen (INil) == 0, ielems (INil) == []
All assumptions:
ilen _v == 0, ilen (INil) == 0, ielems (INil) == [], ilen xs >= 0, ilen ys >= 0
RHS: ilen _v == ilen xs + ilen ys
assumption ilen _v == 0 && (ilen (INil) == 0 && (ielems (INil) == [] && (ilen xs >= 0 && ilen ys >= 0)))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [xs == (INil)
          ,ys == (INil)]
Optimal valuations:
{xs == (INil), ys == (INil)}
Pruned valuations:
{xs == (INil), ys == (INil)}
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking INil ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . INil
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x8:{IList A3|ilen _v >= 0 && ilen _v <= ilen xs} -> x9:{IList A3|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x8 >= 0 && ilen x8 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A3|ilen _v == ilen x8 + ilen x9 && ielems _v == ielems x8 + ielems x9}
Checking merge :: X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . ??
Typing Constraints
merge, xs, ys C0, M0 |- x8:{IList A3|ilen _v >= 0 && ilen _v <= ilen xs} -> x9:{IList A3|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x8 >= 0 && ilen x8 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A3|ilen _v == ilen x8 + ilen x9 && ielems _v == ielems x8 + ielems x9} /\ X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, xs, ys C0, M0 |- x8:{IList A3|ilen _v >= 0 && ilen _v <= ilen xs} -> x9:{IList A3|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x8 >= 0 && ilen x8 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A3|ilen _v == ilen x8 + ilen x9 && ielems _v == ielems x8 + ielems x9} <: X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, xs, ys |- A3
merge, xs, ys |- C0
merge, xs, ys |- (match) M0
UNIFY A3 WITH a PRODUCING {a|U0}
Type assignment
A3 -> {a|U0}
Typing Constraints
Type assignment
A3 -> {a|U0}
Simple Constraints
merge, xs, ys |- (match) M0
merge, xs, ys |- C0
merge, xs, ys |- {a|U0}
X0, X1, merge, xs, ys C0, M0 |- {IList|ilen _v == ilen X1 + ilen X0 && ielems _v == ielems X1 + ielems X0} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
X0, X1, merge, xs, ys C0, M0 |- {a|U0} <: a ()
merge, x8, x9, xs, ys C0, M0 |- {IList|ilen _v == ilen x8 + ilen x9 && ielems _v == ielems x8 + ielems x9} /\ {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x8, x9, xs, ys C0, M0 |- {a|U0} /\ a ()
Pred assignment
addSplitConstraint X0, X1, merge, xs, ys C0, M0 |- {IList|ilen _v == ilen X1 + ilen X0} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint X0, X1, merge, xs, ys C0, M0 |- {IList|ielems _v == ielems X1 + ielems X0} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  False ==> ilen _v == ilen xs + ilen ys
  False ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  U0 -> {}
Checking consistency
  C0 && (M0 && (ilen x8 >= 0 && (ilen x9 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v == ilen x8 + ilen x9 && ielems _v == ielems x8 + ielems x9) && ((ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys) && ((ilen x8 >= 0 && ilen x8 <= ilen xs) && ((ilen x9 >= 0 && ilen x9 <= ilen ys) && ((ilen x8 >= 0 && ilen x8 < ilen xs) || (ilen x9 >= 0 && ilen x9 < ilen ys)))))))))))
Candidates (1)
  0: [C0 -> {}, M0 -> {}, U0 -> {}] (2 0)
Remaining Candidates (0)
TYPE ERROR: Found inconsistent refinements
when checking merge ::
X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . merge
Checking xs :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . ??
Typing Constraints
merge, xs, ys C0, M0 |- {IList a|_v == xs} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, xs, ys |- C0
merge, xs, ys |- (match) M0
Type assignment
Simple Constraints
merge, xs, ys |- (match) M0
merge, xs, ys |- C0
merge, xs, ys C0, M0 |- {IList|_v == xs} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, xs, ys C0, M0 |- a <: a ()
Pred assignment
Constraints
  C0 && (M0 && (_v == xs && (ilen xs >= 0 && ilen ys >= 0))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  M0 -> {ys == (INil), xs == (INil)}
Candidates (1)
  0: [C0 -> {}, M0 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}, M0 -> {}] (0 1)
Invalid Constraint: C0 && (M0 && (_v == xs && (ilen xs >= 0 && ilen ys >= 0))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Strengthening: C0 && (M0 && (_v == xs && (ilen xs >= 0 && ilen ys >= 0))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen (INil) == 0, ielems (INil) == []
All assumptions:
_v == xs, ilen (INil) == 0, ielems (INil) == [], ilen xs >= 0, ilen ys >= 0
RHS: ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
assumption _v == xs && (ilen (INil) == 0 && (ielems (INil) == [] && (ilen xs >= 0 && ilen ys >= 0)))
mustHave !(ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys)
qualsList [xs == (INil)
          ,ys == (INil)]
Optimal valuations:
{ys == (INil)}
Pruned valuations:
{ys == (INil)}
Diffs: (1)
[C0 -> {}, M0 -> {ys == (INil)}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, M0 -> {ys == (INil)}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {ys == (INil)}] (1 0)
Checking ys :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . ??
Typing Constraints
merge, xs, ys C0, M0 |- {IList a|_v == ys} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, xs, ys |- C0
merge, xs, ys |- (match) M0
Type assignment
Simple Constraints
merge, xs, ys |- (match) M0
merge, xs, ys |- C0
merge, xs, ys C0, M0 |- {IList|_v == ys} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, xs, ys C0, M0 |- a <: a ()
Pred assignment
Constraints
  C0 && (M0 && (_v == ys && (ilen xs >= 0 && ilen ys >= 0))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  M0 -> {ys == (INil), xs == (INil)}
Candidates (1)
  0: [C0 -> {}, M0 -> {}] (0 1)
Chosen candidate: 0: [C0 -> {}, M0 -> {}] (0 1)
Invalid Constraint: C0 && (M0 && (_v == ys && (ilen xs >= 0 && ilen ys >= 0))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Strengthening: C0 && (M0 && (_v == ys && (ilen xs >= 0 && ilen ys >= 0))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen (INil) == 0, ielems (INil) == []
All assumptions:
_v == ys, ilen (INil) == 0, ielems (INil) == [], ilen xs >= 0, ilen ys >= 0
RHS: ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
assumption _v == ys && (ilen (INil) == 0 && (ielems (INil) == [] && (ilen xs >= 0 && ilen ys >= 0)))
mustHave !(ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys)
qualsList [xs == (INil)
          ,ys == (INil)]
Optimal valuations:
{xs == (INil)}
Pruned valuations:
{xs == (INil)}
Diffs: (1)
[C0 -> {}, M0 -> {xs == (INil)}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, M0 -> {xs == (INil)}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {xs == (INil)}] (1 0)
Checking program xs
Checking xs :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . ??
Typing Constraints
merge, xs, ys C0, M0 |- {IList a|_v == xs} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
Simple Constraints
merge, xs, ys C0, M0 |- {IList|_v == xs} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, xs, ys C0, M0 |- a <: a ()
Pred assignment
Constraints
  C0 && (M0 && (_v == xs && (ilen xs >= 0 && ilen ys >= 0))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  M0 -> {ys == (INil), xs == (INil)}
Checking consistency
Candidates (1)
  0: [C0 -> {}, M0 -> {ys == (INil)}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {ys == (INil)}] (1 0)
Typing Constraints
Type assignment
Simple Constraints
Pred assignment
Constraints
QMap
  C0 -> {}
  M0 -> {ys == (INil), xs == (INil)}
Checking consistency
Candidates (1)
  0: [C0 -> {}, M0 -> {ys == (INil)}] (1 0)
Remaining Candidates (1)
  0: [C0 -> {}, M0 -> {ys == (INil)}] (1 0)
Auxiliary goals are:
Match valuation [ys == (INil)]
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x8:A3 -> x9:IList {A3|x8 <= _v} -> {IList A3|_v == (ICons x8 x9)}
Matching constructor type
{IList A3|_v == (ICons x8 x9)}
with scrutinee
IList a
ADD x10 : All {a,}. a
ADD x11 : All {a,}. {IList |  | a, |  | }
Checking error in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> error
Typing Constraints
merge, x10, x11, xs, ys True, M1 |- {Int|x10 == x10 && (x11 == x11 && (xs == xs && ys == ys))} <: {Int|False} ()
merge, xs, ys |- A3
Type assignment
A3 -> a
Simple Constraints
merge, xs, ys |- a
merge, x10, x11, xs, ys True, M1 |- {Int|x10 == x10 && (x11 == x11 && (xs == xs && ys == ys))} <: {Int|False} ()
Pred assignment
Constraints
  M1 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((x10 == x10 && (x11 == x11 && (xs == xs && ys == ys))) && (forall _x . _x in ielems x11 ==> x10 <= _x))))) ==> False
QMap
  C0 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
Candidates (1)
  0: [C0 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}] (1 1)
Chosen candidate: 0: [C0 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}] (1 1)
Invalid Constraint: M1 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((x10 == x10 && (x11 == x11 && (xs == xs && ys == ys))) && (forall _x . _x in ielems x11 ==> x10 <= _x))))) ==> False
Strengthening: M1 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((x10 == x10 && (x11 == x11 && (xs == xs && ys == ys))) && (forall _x . _x in ielems x11 ==> x10 <= _x))))) ==> False
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ielems ((ICons x10 x11)) == [x10] + ielems x11
All assumptions:
x10 == x10, x11 == x11, xs == xs, ys == ys, ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ilen x11 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x
RHS: False
assumption True
mustHave x10 == x10 && (x11 == x11 && (xs == xs && (ys == ys && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))))))
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> error
Checking error in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> error
Typing Constraints
merge, x10, x11, xs, ys True, C1, M1, M2 |- {Int|x10 == x10 && (x11 == x11 && (xs == xs && ys == ys))} <: {Int|False} ()
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys |- (match) M2
merge, xs, ys |- A3
Type assignment
A3 -> a
Simple Constraints
merge, xs, ys |- a
merge, x10, x11, xs, ys |- (match) M2
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys True, C1, M1, M2 |- {Int|x10 == x10 && (x11 == x11 && (xs == xs && ys == ys))} <: {Int|False} ()
Pred assignment
Constraints
  C1 && (M1 && (M2 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((x10 == x10 && (x11 == x11 && (xs == xs && ys == ys))) && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> False
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}] (1 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}] (1 1)
Invalid Constraint: C1 && (M1 && (M2 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((x10 == x10 && (x11 == x11 && (xs == xs && ys == ys))) && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> False
Strengthening: C1 && (M1 && (M2 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((x10 == x10 && (x11 == x11 && (xs == xs && ys == ys))) && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> False
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems (INil) == []
All assumptions:
x10 == x10, x11 == x11, xs == xs, ys == ys, ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems (INil) == [], ilen x11 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x
RHS: False
assumption True
mustHave x10 == x10 && (x11 == x11 && (xs == xs && (ys == ys && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))))))))
qualsList [xs == (INil)]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> error
Looking for type {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
*******************Filling holes in (?? :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys})
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x12:A4 -> x13:IList {A4|x12 <= _v} -> {IList A4|_v == (ICons x12 x13)}
Checking ICons :: X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> ??
Typing Constraints
merge, x10, x11, xs, ys True, C1, M1, M2 |- x12:A4 -> x13:IList {A4|x12 <= _v} -> {IList A4|_v == (ICons x12 x13)} /\ X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys True, C1, M1, M2 |- x12:A4 -> x13:IList {A4|x12 <= _v} -> {IList A4|_v == (ICons x12 x13)} <: X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys |- A4
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys |- (match) M2
merge, xs, ys |- A3
UNIFY A4 WITH a PRODUCING {a|U0}
Type assignment
A3 -> a
A4 -> {a|U0}
Typing Constraints
Type assignment
A3 -> a
A4 -> {a|U0}
Simple Constraints
merge, xs, ys |- a
merge, x10, x11, xs, ys |- (match) M2
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys |- {a|U0}
X0, X1, merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|_v == (ICons X1 X0)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
X0, X1, merge, x10, x11, xs, ys True, C1, M1, M2 |- {a|U0} <: a ()
merge, x10, x11, x12, x13, xs, ys True, C1, M1, M2 |- {IList|_v == (ICons x12 x13)} /\ {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x12, x13, xs, ys True, C1, M1, M2 |- {a|U0} /\ a ()
Pred assignment
addSplitConstraint X0, X1, merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|ilen _v == 1 + ilen X0} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint X0, X1, merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|ielems _v == [X1] + ielems X0} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  False ==> ilen _v == ilen xs + ilen ys
  False ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  U0 -> {x10 <= _v}
Checking consistency
  C1 && (M1 && (M2 && ([_v -> x12]U0 && (_v == (ICons x12 x13) && (ilen x11 >= 0 && (ilen x13 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys)))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}, U0 -> {}] (3 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}, U0 -> {}] (3 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A4|False}|_v == (INil)}
Checking INil :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> ??
Typing Constraints
merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList {A4|False}|_v == (INil)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys |- A4
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys |- (match) M2
merge, xs, ys |- A3
UNIFY A4 WITH a PRODUCING {a|U0}
Type assignment
A3 -> a
A4 -> {a|U0}
Typing Constraints
Type assignment
A3 -> a
A4 -> {a|U0}
Simple Constraints
merge, xs, ys |- a
merge, x10, x11, xs, ys |- (match) M2
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys |- {a|U0}
merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|_v == (INil)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys True, C1, M1, M2 |- {a|False} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|ilen _v == 0} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|ielems _v == []} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C1 && (M1 && (M2 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys
  C1 && (M1 && (M2 && (ielems _v == [] && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  U0 -> {x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}, U0 -> {}] (1 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}, U0 -> {}] (1 2)
Invalid Constraint: C1 && (M1 && (M2 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C1 && (M1 && (M2 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems (INil) == []
All assumptions:
ys == (ICons x10 x11), ilen _v == 0, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems (INil) == [], ilen x11 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption ys == (ICons x10 x11) && (ilen _v == 0 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x)))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [xs == (INil)]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking INil ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> INil
Checking x11 :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> ??
Typing Constraints
merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList {a|x10 <= _v}|_v == x11} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys |- (match) M2
merge, xs, ys |- A3
Type assignment
A3 -> a
Simple Constraints
merge, xs, ys |- a
merge, x10, x11, xs, ys |- (match) M2
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|_v == x11} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys True, C1, M1, M2 |- {a|x10 <= _v} <: a ()
Pred assignment
Constraints
  C1 && (M1 && (M2 && (_v == x11 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}] (1 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}] (1 1)
Invalid Constraint: C1 && (M1 && (M2 && (_v == x11 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Strengthening: C1 && (M1 && (M2 && (_v == x11 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems (INil) == []
All assumptions:
_v == x11, ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems (INil) == [], ilen x11 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x
RHS: ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
assumption _v == x11 && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x)))))))))
mustHave !(ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys)
qualsList [xs == (INil)]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x12:{IList A4|ilen _v >= 0 && ilen _v <= ilen xs} -> x13:{IList A4|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x12 >= 0 && ilen x12 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A4|ilen _v == ilen x12 + ilen x13 && ielems _v == ielems x12 + ielems x13}
Checking merge :: X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> ??
Typing Constraints
merge, x10, x11, xs, ys True, C1, M1, M2 |- x12:{IList A4|ilen _v >= 0 && ilen _v <= ilen xs} -> x13:{IList A4|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x12 >= 0 && ilen x12 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A4|ilen _v == ilen x12 + ilen x13 && ielems _v == ielems x12 + ielems x13} /\ X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys True, C1, M1, M2 |- x12:{IList A4|ilen _v >= 0 && ilen _v <= ilen xs} -> x13:{IList A4|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x12 >= 0 && ilen x12 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A4|ilen _v == ilen x12 + ilen x13 && ielems _v == ielems x12 + ielems x13} <: X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys |- A4
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys |- (match) M2
merge, xs, ys |- A3
UNIFY A4 WITH a PRODUCING {a|U0}
Type assignment
A3 -> a
A4 -> {a|U0}
Typing Constraints
Type assignment
A3 -> a
A4 -> {a|U0}
Simple Constraints
merge, xs, ys |- a
merge, x10, x11, xs, ys |- (match) M2
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys |- {a|U0}
X0, X1, merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|ilen _v == ilen X1 + ilen X0 && ielems _v == ielems X1 + ielems X0} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
X0, X1, merge, x10, x11, xs, ys True, C1, M1, M2 |- {a|U0} <: a ()
merge, x10, x11, x12, x13, xs, ys True, C1, M1, M2 |- {IList|ilen _v == ilen x12 + ilen x13 && ielems _v == ielems x12 + ielems x13} /\ {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x12, x13, xs, ys True, C1, M1, M2 |- {a|U0} /\ a ()
Pred assignment
addSplitConstraint X0, X1, merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|ilen _v == ilen X1 + ilen X0} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint X0, X1, merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|ielems _v == ielems X1 + ielems X0} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  False ==> ilen _v == ilen xs + ilen ys
  False ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  U0 -> {x10 <= _v}
Checking consistency
  C1 && (M1 && (M2 && (ilen x11 >= 0 && (ilen x12 >= 0 && (ilen x13 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v == ilen x12 + ilen x13 && ielems _v == ielems x12 + ielems x13) && ((ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys) && ((ilen x12 >= 0 && ilen x12 <= ilen xs) && ((ilen x13 >= 0 && ilen x13 <= ilen ys) && ((ilen x12 >= 0 && ilen x12 < ilen xs) || (ilen x13 >= 0 && ilen x13 < ilen ys)))))))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}, U0 -> {}] (3 0)
Remaining Candidates (0)
TYPE ERROR: Found inconsistent refinements
when checking merge ::
X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> merge
Checking xs :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> ??
Typing Constraints
merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList a|_v == xs} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys |- (match) M2
merge, xs, ys |- A3
Type assignment
A3 -> a
Simple Constraints
merge, xs, ys |- a
merge, x10, x11, xs, ys |- (match) M2
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|_v == xs} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys True, C1, M1, M2 |- a <: a ()
Pred assignment
Constraints
  C1 && (M1 && (M2 && (_v == xs && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}] (1 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}] (1 1)
Invalid Constraint: C1 && (M1 && (M2 && (_v == xs && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Strengthening: C1 && (M1 && (M2 && (_v == xs && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems (INil) == []
All assumptions:
_v == xs, ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems (INil) == [], ilen x11 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x
RHS: ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
assumption _v == xs && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x)))))))))
mustHave !(ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys)
qualsList [xs == (INil)]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> xs
Checking ys :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> ??
Typing Constraints
merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList a|_v == ys} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys |- (match) M2
merge, xs, ys |- A3
Type assignment
A3 -> a
Simple Constraints
merge, xs, ys |- a
merge, x10, x11, xs, ys |- (match) M2
merge, x10, x11, xs, ys |- C1
merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|_v == ys} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys True, C1, M1, M2 |- a <: a ()
Pred assignment
Constraints
  C1 && (M1 && (M2 && (_v == ys && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}] (1 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}] (1 1)
Invalid Constraint: C1 && (M1 && (M2 && (_v == ys && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Strengthening: C1 && (M1 && (M2 && (_v == ys && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems (INil) == []
All assumptions:
_v == ys, ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems (INil) == [], ilen x11 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x
RHS: ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
assumption _v == ys && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x)))))))))
mustHave !(ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys)
qualsList [xs == (INil)]
Optimal valuations:
{xs == (INil)}
Pruned valuations:
{xs == (INil)}
Diffs: (1)
[C1 -> {}, M1 -> {}, M2 -> {xs == (INil)}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}] (2 0)
*******************Filling holes in ICons
                                      (?? :: A4)
                                      (?? :: IList {A4|x12 <= _v})
Checking x10 :: A4 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> ??
Typing Constraints
merge, x10, x11, xs, ys True, C1, M1, M2 |- {a|_v == x10} <: A4 ()
Type assignment
A3 -> a
A4 -> {a|U0}
Simple Constraints
merge, x10, x11, xs, ys True, C1, M1, M2 |- {a|_v == x10} <: {a|U0} ()
Pred assignment
Constraints
  C1 && (M1 && (M2 && (_v == x10 && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> U0
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  U0 -> {x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}, U0 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {}, U0 -> {}] (4 0)
Checking program ys
Checking ys :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> ??
Typing Constraints
merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList a|_v == ys} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
Simple Constraints
merge, x10, x11, xs, ys True, C1, M1, M2 |- {IList|_v == ys} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, xs, ys True, C1, M1, M2 |- a <: a ()
Pred assignment
Constraints
  C1 && (M1 && (M2 && (_v == ys && (ilen x11 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (forall _x . _x in ielems x11 ==> x10 <= _x))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}] (2 0)
Typing Constraints
Type assignment
A3 -> a
Simple Constraints
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}] (2 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}] (2 0)
Auxiliary goals are:
Match valuation [xs == (INil)]
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x12:A4 -> x13:IList {A4|x12 <= _v} -> {IList A4|_v == (ICons x12 x13)}
Matching constructor type
{IList A4|_v == (ICons x12 x13)}
with scrutinee
IList a
ADD x14 : All {a,}. a
ADD x15 : All {a,}. {IList |  | a, |  | }
Checking error in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> error
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, M1, M3 |- {Int|x10 == x10 && (x14 == x14 && (x11 == x11 && (x15 == x15 && (xs == xs && ys == ys))))} <: {Int|False} ()
merge, x10, x11, xs, ys |- A4
Type assignment
A3 -> a
A4 -> a
Simple Constraints
merge, x10, x11, xs, ys |- a
merge, x10, x11, x14, x15, xs, ys True, M1, M3 |- {Int|x10 == x10 && (x14 == x14 && (x11 == x11 && (x15 == x15 && (xs == xs && ys == ys))))} <: {Int|False} ()
Pred assignment
Constraints
  M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((x10 == x10 && (x14 == x14 && (x11 == x11 && (x15 == x15 && (xs == xs && ys == ys))))) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> False
QMap
  C0 -> {}
  C1 -> {}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}] (2 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}] (2 1)
Invalid Constraint: M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((x10 == x10 && (x14 == x14 && (x11 == x11 && (x15 == x15 && (xs == xs && ys == ys))))) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> False
Strengthening: M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((x10 == x10 && (x14 == x14 && (x11 == x11 && (x15 == x15 && (xs == xs && ys == ys))))) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> False
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
x10 == x10, x14 == x14, x11 == x11, x15 == x15, xs == xs, xs == (ICons x14 x15), ys == ys, ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: False
assumption True
mustHave x10 == x10 && (x14 == x14 && (x11 == x11 && (x15 == x15 && (xs == xs && (xs == (ICons x14 x15) && (ys == ys && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
qualsList []
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking error in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> error
Looking for type {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
*******************Filling holes in (?? :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys})
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x16:A5 -> x17:IList {A5|x16 <= _v} -> {IList A5|_v == (ICons x16 x17)}
Checking ICons :: X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x16:A5 -> x17:IList {A5|x16 <= _v} -> {IList A5|_v == (ICons x16 x17)} /\ X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x16:A5 -> x17:IList {A5|x16 <= _v} -> {IList A5|_v == (ICons x16 x17)} <: X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys |- A5
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, xs, ys |- A4
UNIFY A5 WITH a PRODUCING {a|U0}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, xs, ys |- a
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, x14, x15, xs, ys |- {a|U0}
X0, X1, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X1 X0)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
X0, X1, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
merge, x10, x11, x14, x15, x16, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x16 x17)} /\ {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x16, x17, xs, ys True, C2, M1, M3 |- {a|U0} /\ a ()
Pred assignment
addSplitConstraint X0, X1, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen X0} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint X0, X1, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [X1] + ielems X0} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  False ==> ilen _v == ilen xs + ilen ys
  False ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Checking consistency
  C2 && (M1 && (M3 && ([_v -> x16]U0 && (_v == (ICons x16 x17) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys))))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (4 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (4 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A5|False}|_v == (INil)}
Checking INil :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A5|False}|_v == (INil)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys |- A5
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, xs, ys |- A4
UNIFY A5 WITH a PRODUCING {a|U0}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, xs, ys |- a
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, x14, x15, xs, ys |- {a|U0}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ielems _v == []} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (2 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (2 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 0, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 0 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking INil ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> INil
Checking x15 :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, xs, ys |- A4
Type assignment
A3 -> a
A4 -> a
Simple Constraints
merge, x10, x11, xs, ys |- a
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: a ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}] (2 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}] (2 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, xs, ys |- A4
Type assignment
A3 -> a
A4 -> a
Simple Constraints
merge, x10, x11, xs, ys |- a
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: a ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}] (2 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}] (2 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x16:{IList A5|ilen _v >= 0 && ilen _v <= ilen xs} -> x17:{IList A5|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x16 >= 0 && ilen x16 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A5|ilen _v == ilen x16 + ilen x17 && ielems _v == ielems x16 + ielems x17}
Checking merge :: X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x16:{IList A5|ilen _v >= 0 && ilen _v <= ilen xs} -> x17:{IList A5|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x16 >= 0 && ilen x16 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A5|ilen _v == ilen x16 + ilen x17 && ielems _v == ielems x16 + ielems x17} /\ X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x16:{IList A5|ilen _v >= 0 && ilen _v <= ilen xs} -> x17:{IList A5|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x16 >= 0 && ilen x16 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A5|ilen _v == ilen x16 + ilen x17 && ielems _v == ielems x16 + ielems x17} <: X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys |- A5
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, xs, ys |- A4
UNIFY A5 WITH a PRODUCING {a|U0}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, xs, ys |- a
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, x14, x15, xs, ys |- {a|U0}
X0, X1, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X1 + ilen X0 && ielems _v == ielems X1 + ielems X0} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
X0, X1, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
merge, x10, x11, x14, x15, x16, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x16 + ilen x17 && ielems _v == ielems x16 + ielems x17} /\ {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x16, x17, xs, ys True, C2, M1, M3 |- {a|U0} /\ a ()
Pred assignment
addSplitConstraint X0, X1, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X1 + ilen X0} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint X0, X1, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ielems _v == ielems X1 + ielems X0} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  False ==> ilen _v == ilen xs + ilen ys
  False ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Checking consistency
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x16 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v == ilen x16 + ilen x17 && ielems _v == ielems x16 + ielems x17) && ((ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys) && ((ilen x16 >= 0 && ilen x16 <= ilen xs) && ((ilen x17 >= 0 && ilen x17 <= ilen ys) && ((ilen x16 >= 0 && ilen x16 < ilen xs) || (ilen x17 >= 0 && ilen x17 < ilen ys))))))))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (4 0)
Remaining Candidates (0)
TYPE ERROR: Found inconsistent refinements
when checking merge ::
X1:_ -> X0:_ -> {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> merge
Checking xs :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, xs, ys |- A4
Type assignment
A3 -> a
A4 -> a
Simple Constraints
merge, x10, x11, xs, ys |- a
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: a ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}] (2 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}] (2 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, xs, ys |- A4
Type assignment
A3 -> a
A4 -> a
Simple Constraints
merge, x10, x11, xs, ys |- a
merge, x10, x11, x14, x15, xs, ys |- C2
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: a ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}] (2 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}] (2 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      (?? :: A5)
                                      (?? :: IList {A5|x16 <= _v})
Checking x14 :: A5 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A5 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U0} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 0)
Checking x10 :: A5 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A5 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U0} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 0)
*******************Filling holes in ICons
                                      x14 (?? :: IList {A5|x14 <= _v})
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x18:A6 -> x19:IList {A6|x18 <= _v} -> {IList A6|_v == (ICons x18 x19)}
Checking ICons :: X3:_ -> X2:_ -> IList {A5|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x18:A6 -> x19:IList {A6|x18 <= _v} -> {IList A6|_v == (ICons x18 x19)} /\ X3:_ -> X2:_ -> IList {A5|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x18:A6 -> x19:IList {A6|x18 <= _v} -> {IList A6|_v == (ICons x18 x19)} <: X3:_ -> X2:_ -> IList {A5|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A6
UNIFY A6 WITH {a|U0 && x14 <= _v} PRODUCING {a|U1}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U1}
X2, X3, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X3 X2)} <: IList ()
X2, X3, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U1} <: {a|U0 && x14 <= _v} ()
merge, x10, x11, x14, x15, x18, x19, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x18 x19)} /\ IList ()
merge, x10, x11, x14, x15, x18, x19, xs, ys True, C2, M1, M3 |- {a|U1} /\ {a|U0 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> True && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(True && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U1 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U0 && x14 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (6 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A6|False}|_v == (INil)}
Checking INil :: IList {A5|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A6|False}|_v == (INil)} <: IList {A5|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A6
UNIFY A6 WITH {a|U0 && x14 <= _v} PRODUCING {a|U1}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U1}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U0 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 0)
Checking x15 :: IList {A5|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A5|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U0 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 0)
Checking x11 :: IList {A5|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A5|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U0 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> True && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(True && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x18:{IList A6|ilen _v >= 0 && ilen _v <= ilen xs} -> x19:{IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A6|ilen _v == ilen x18 + ilen x19 && ielems _v == ielems x18 + ielems x19}
Checking merge :: X3:_ -> X2:_ -> IList {A5|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x18:{IList A6|ilen _v >= 0 && ilen _v <= ilen xs} -> x19:{IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A6|ilen _v == ilen x18 + ilen x19 && ielems _v == ielems x18 + ielems x19} /\ X3:_ -> X2:_ -> IList {A5|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x18:{IList A6|ilen _v >= 0 && ilen _v <= ilen xs} -> x19:{IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A6|ilen _v == ilen x18 + ilen x19 && ielems _v == ielems x18 + ielems x19} <: X3:_ -> X2:_ -> IList {A5|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A6
UNIFY A6 WITH {a|U0 && x14 <= _v} PRODUCING {a|U1}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U1}
X2, X3, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X3 + ilen X2 && ielems _v == ielems X3 + ielems X2} <: IList ()
X2, X3, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U1} <: {a|U0 && x14 <= _v} ()
merge, x10, x11, x14, x15, x18, x19, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x18 + ilen x19 && ielems _v == ielems x18 + ielems x19} /\ IList ()
merge, x10, x11, x14, x15, x18, x19, xs, ys True, C2, M1, M3 |- {a|U1} /\ {a|U0 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> True && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(True && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U1 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U0 && x14 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (6 0)
Checking xs :: IList {A5|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A5|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U0 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U0 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U0 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> True && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(True && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|True && x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A5|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A5|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U0 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U0 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U0 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> True && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(True && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|True && x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (?? :: IList {A5|x10 <= _v})
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x18:A6 -> x19:IList {A6|x18 <= _v} -> {IList A6|_v == (ICons x18 x19)}
Checking ICons :: X3:_ -> X2:_ -> IList {A5|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x18:A6 -> x19:IList {A6|x18 <= _v} -> {IList A6|_v == (ICons x18 x19)} /\ X3:_ -> X2:_ -> IList {A5|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x18:A6 -> x19:IList {A6|x18 <= _v} -> {IList A6|_v == (ICons x18 x19)} <: X3:_ -> X2:_ -> IList {A5|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A6
UNIFY A6 WITH {a|U0 && x10 <= _v} PRODUCING {a|U1}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U1}
X2, X3, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X3 X2)} <: IList ()
X2, X3, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U1} <: {a|U0 && x10 <= _v} ()
merge, x10, x11, x14, x15, x18, x19, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x18 x19)} /\ IList ()
merge, x10, x11, x14, x15, x18, x19, xs, ys True, C2, M1, M3 |- {a|U1} /\ {a|U0 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> True && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(True && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U1 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U0 && x10 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (6 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A6|False}|_v == (INil)}
Checking INil :: IList {A5|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A6|False}|_v == (INil)} <: IList {A5|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A6
UNIFY A6 WITH {a|U0 && x10 <= _v} PRODUCING {a|U1}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U1}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U0 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 0)
Checking x15 :: IList {A5|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A5|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U0 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> True && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(True && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 0)
Checking x11 :: IList {A5|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A5|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U0 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x18:{IList A6|ilen _v >= 0 && ilen _v <= ilen xs} -> x19:{IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A6|ilen _v == ilen x18 + ilen x19 && ielems _v == ielems x18 + ielems x19}
Checking merge :: X3:_ -> X2:_ -> IList {A5|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x18:{IList A6|ilen _v >= 0 && ilen _v <= ilen xs} -> x19:{IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A6|ilen _v == ilen x18 + ilen x19 && ielems _v == ielems x18 + ielems x19} /\ X3:_ -> X2:_ -> IList {A5|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x18:{IList A6|ilen _v >= 0 && ilen _v <= ilen xs} -> x19:{IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A6|ilen _v == ilen x18 + ilen x19 && ielems _v == ielems x18 + ielems x19} <: X3:_ -> X2:_ -> IList {A5|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A6
UNIFY A6 WITH {a|U0 && x10 <= _v} PRODUCING {a|U1}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U1}
X2, X3, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X3 + ilen X2 && ielems _v == ielems X3 + ielems X2} <: IList ()
X2, X3, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U1} <: {a|U0 && x10 <= _v} ()
merge, x10, x11, x14, x15, x18, x19, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x18 + ilen x19 && ielems _v == ielems x18 + ielems x19} /\ IList ()
merge, x10, x11, x14, x15, x18, x19, xs, ys True, C2, M1, M3 |- {a|U1} /\ {a|U0 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U0 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> True && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(True && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U1 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U1 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U0 && x10 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (6 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (6 0)
Checking xs :: IList {A5|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A5|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U0 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U0 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U0 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> True && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(True && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|True && x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A5|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A5|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U0 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U0 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (5 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U0 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> True && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(True && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|True && x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons (?? :: A6)
                                             (?? :: IList {A6|x18 <= _v}))
Checking x14 :: A6 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A6 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 0)
Checking x10 :: A6 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A6 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (6 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (6 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x10, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption _v == x10 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 0)
Checking program ICons x14 INil
Checking ICons x14
           INil :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList A5|_v == (ICons x14 (INil))} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems (INil)} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x14] + ielems (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 INil ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14 INil
Checking program ICons x14 x15
Checking ICons x14
           x15 :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList A5|_v == (ICons x14 x15)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x15)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x15} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x15, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x15 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 x15 ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14 x15
Checking program ICons x14 x11
Checking ICons x14
           x11 :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList A5|_v == (ICons x14 x11)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x11)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x11} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x14] + ielems x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 x11 ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14 x11
*******************Filling holes in ICons
                                      x14 (merge
                                             (?? :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs})
                                             (?? :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)}
Checking ICons :: X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} /\ X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} <: X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X5 X4)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x20 x21)} /\ {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen X4} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  False ==> ilen _v <= ilen xs && ilen _v >= 0
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && ([_v -> x20]U2 && (_v == (ICons x20 x21) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (ilen _v >= 0 && ilen _v <= ilen xs))))))))))
  C2 && (M1 && (M3 && (U1 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A7|False}|_v == (INil)}
Checking INil :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A7|False}|_v == (INil)} <: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 0)
Checking x15 :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 0)
Checking x11 :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (6 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (6 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}
Checking merge :: X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} <: X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4 && ielems _v == ielems X5 + ielems X4} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  False ==> ilen _v <= ilen xs && ilen _v >= 0
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x20 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21) && ((ilen _v >= 0 && ilen _v <= ilen xs) && ((ilen x20 >= 0 && ilen x20 <= ilen xs) && ((ilen x21 >= 0 && ilen x21 <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen x21 >= 0 && ilen x21 < ilen ys))))))))))))))
  C2 && (M1 && (M3 && (U1 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 0)
Checking xs :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (6 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (6 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons (?? :: A6)
                                             (?? :: IList {A6|x18 <= _v}))
Checking x14 :: A6 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A6 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (6 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (6 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x14, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption _v == x14 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 0)
Checking x10 :: A6 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A6 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 0)
Checking program ICons x10 INil
Checking ICons x10
           INil :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList A5|_v == (ICons x10 (INil))} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems (INil)} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x10] + ielems (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {}] (5 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 INil ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10 INil
Checking program ICons x10 x15
Checking ICons x10
           x15 :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList A5|_v == (ICons x10 x15)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x15)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x15} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x10] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x15, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x15 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 x15 ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10 x15
Checking program ICons x10 x11
Checking ICons x10
           x11 :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList A5|_v == (ICons x10 x11)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x11)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x11} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x10] + ielems x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}] (6 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 x11 ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10 x11
*******************Filling holes in ICons
                                      x10 (merge
                                             (?? :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs})
                                             (?? :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)}
Checking ICons :: X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} /\ X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} <: X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X5 X4)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x20 x21)} /\ {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen X4} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  False ==> ilen _v <= ilen xs && ilen _v >= 0
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && ([_v -> x20]U2 && (_v == (ICons x20 x21) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (ilen _v >= 0 && ilen _v <= ilen xs))))))))))
  C2 && (M1 && (M3 && (U1 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A7|False}|_v == (INil)}
Checking INil :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A7|False}|_v == (INil)} <: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 0)
Checking x15 :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 0)
Checking x11 :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}
Checking merge :: X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} <: X5:_ -> X4:_ -> {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4 && ielems _v == ielems X5 + ielems X4} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  False ==> ilen _v <= ilen xs && ilen _v >= 0
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x20 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21) && ((ilen _v >= 0 && ilen _v <= ilen xs) && ((ilen x20 >= 0 && ilen x20 <= ilen xs) && ((ilen x21 >= 0 && ilen x21 <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen x21 >= 0 && ilen x21 < ilen ys))))))))))))))
  C2 && (M1 && (M3 && (U1 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 0)
Checking xs :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A6|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (6 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (6 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x14
                                             (?? :: IList {A6|x14 <= _v}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)}
Checking ICons :: X5:_ -> X4:_ -> IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} /\ X5:_ -> X4:_ -> IList {A6|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} <: X5:_ -> X4:_ -> IList {A6|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x14 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X5 X4)} <: IList ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1 && x14 <= _v} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x20 x21)} /\ IList ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U1 && x14 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A7|False}|_v == (INil)}
Checking INil :: IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A7|False}|_v == (INil)} <: IList {A6|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x14 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 0)
Checking x15 :: IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A6|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 0)
Checking x11 :: IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A6|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}
Checking merge :: X5:_ -> X4:_ -> IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ X5:_ -> X4:_ -> IList {A6|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} <: X5:_ -> X4:_ -> IList {A6|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x14 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4 && ielems _v == ielems X5 + ielems X4} <: IList ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1 && x14 <= _v} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ IList ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U1 && x14 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 0)
Checking xs :: IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A6|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A6|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x10
                                             (?? :: IList {A6|x10 <= _v}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)}
Checking ICons :: X5:_ -> X4:_ -> IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} /\ X5:_ -> X4:_ -> IList {A6|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} <: X5:_ -> X4:_ -> IList {A6|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x10 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X5 X4)} <: IList ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1 && x10 <= _v} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x20 x21)} /\ IList ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U1 && x10 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (8 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A7|False}|_v == (INil)}
Checking INil :: IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A7|False}|_v == (INil)} <: IList {A6|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x10 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 0)
Checking x15 :: IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A6|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 0)
Checking x11 :: IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A6|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}
Checking merge :: X5:_ -> X4:_ -> IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ X5:_ -> X4:_ -> IList {A6|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} <: X5:_ -> X4:_ -> IList {A6|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x10 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4 && ielems _v == ielems X5 + ielems X4} <: IList ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1 && x10 <= _v} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ IList ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U1 && x10 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (8 0)
Checking xs :: IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A6|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A6|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (ICons (?? :: A7)
                                                    (?? :: IList {A7|x20 <= _v}))
                                             (?? :: LET x18:({IList A7|_v == (ICons x20 x21)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
Checking x14 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 0)
Checking x10 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x10, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption _v == x10 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 0)
*******************Filling holes in ICons
                                      x14 (merge INil
                                             (?? :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x20:A8 -> x21:IList {A8|x20 <= _v} -> {IList A8|_v == (ICons x20 x21)}
Checking ICons :: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A8 -> x21:IList {A8|x20 <= _v} -> {IList A8|_v == (ICons x20 x21)} /\ X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A8 -> x21:IList {A8|x20 <= _v} -> {IList A8|_v == (ICons x20 x21)} <: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X5 X4)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U3} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x20 x21)} /\ {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U3} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen X4} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  False ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U3 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && ([_v -> x20]U3 && (_v == (ICons x20 x21) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))))))))))))
  C2 && (M1 && (M3 && (U1 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (9 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {}] (8 0)
Checking x15 :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x20:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}
Checking merge :: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} <: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4 && ielems _v == ielems X5 + ielems X4} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U3} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U3} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  False ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U3 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x20 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21) && ((ilen x20 >= 0 && ilen x20 <= ilen xs) && (((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))) && ((ilen x21 >= 0 && ilen x21 <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen x21 >= 0 && ilen x21 < ilen ys))))))))))))))
  C2 && (M1 && (M3 && (U1 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (9 0)
Checking xs :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge x15
                                             (?? :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)}
Checking ICons :: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} /\ X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} <: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X5 X4)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x20 x21)} /\ {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen X4} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  False ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && ([_v -> x20]U2 && (_v == (ICons x20 x21) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))))))))))))
  C2 && (M1 && (M3 && (U1 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A7|False}|_v == (INil)}
Checking INil :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A7|False}|_v == (INil)} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 0)
Checking x15 :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}
Checking merge :: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} <: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4 && ielems _v == ielems X5 + ielems X4} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  False ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x20 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21) && ((ilen x20 >= 0 && ilen x20 <= ilen xs) && (((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))) && ((ilen x21 >= 0 && ilen x21 <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen x21 >= 0 && ilen x21 < ilen ys))))))))))))))
  C2 && (M1 && (M3 && (U1 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Checking xs :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (merge
                                                    (?? :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs})
                                                    (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
                                             (?? :: LET x18:({IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Checking x15 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Checking x11 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x14
                                             (?? :: IList {A6|x14 <= _v}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)}
Checking ICons :: X5:_ -> X4:_ -> IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} /\ X5:_ -> X4:_ -> IList {A6|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} <: X5:_ -> X4:_ -> IList {A6|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x14 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X5 X4)} <: IList ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1 && x14 <= _v} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x20 x21)} /\ IList ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U1 && x14 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (8 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A7|False}|_v == (INil)}
Checking INil :: IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A7|False}|_v == (INil)} <: IList {A6|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x14 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 0)
Checking x15 :: IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A6|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 0)
Checking x11 :: IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A6|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}
Checking merge :: X5:_ -> X4:_ -> IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ X5:_ -> X4:_ -> IList {A6|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} <: X5:_ -> X4:_ -> IList {A6|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x14 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4 && ielems _v == ielems X5 + ielems X4} <: IList ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1 && x14 <= _v} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ IList ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x14 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U1 && x14 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (8 0)
Checking xs :: IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A6|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A6|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A6|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x10
                                             (?? :: IList {A6|x10 <= _v}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)}
Checking ICons :: X5:_ -> X4:_ -> IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} /\ X5:_ -> X4:_ -> IList {A6|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} <: X5:_ -> X4:_ -> IList {A6|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x10 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X5 X4)} <: IList ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1 && x10 <= _v} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x20 x21)} /\ IList ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U1 && x10 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A7|False}|_v == (INil)}
Checking INil :: IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A7|False}|_v == (INil)} <: IList {A6|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x10 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 0)
Checking x15 :: IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A6|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 0)
Checking x11 :: IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A6|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}
Checking merge :: X5:_ -> X4:_ -> IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ X5:_ -> X4:_ -> IList {A6|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} <: X5:_ -> X4:_ -> IList {A6|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1 && x10 <= _v} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4 && ielems _v == ielems X5 + ielems X4} <: IList ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1 && x10 <= _v} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ IList ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && (U1 && x10 <= _v))))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 0)
Checking xs :: IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A6|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A6|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A6|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (7 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (ICons (?? :: A7)
                                                    (?? :: IList {A7|x20 <= _v}))
                                             (?? :: LET x18:({IList A7|_v == (ICons x20 x21)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
Checking x14 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x14, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption _v == x14 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 0)
Checking x10 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 0)
*******************Filling holes in ICons
                                      x10 (merge INil
                                             (?? :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x20:A8 -> x21:IList {A8|x20 <= _v} -> {IList A8|_v == (ICons x20 x21)}
Checking ICons :: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A8 -> x21:IList {A8|x20 <= _v} -> {IList A8|_v == (ICons x20 x21)} /\ X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A8 -> x21:IList {A8|x20 <= _v} -> {IList A8|_v == (ICons x20 x21)} <: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X5 X4)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U3} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x20 x21)} /\ {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U3} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen X4} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  False ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U3 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && ([_v -> x20]U3 && (_v == (ICons x20 x21) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))))))))))))
  C2 && (M1 && (M3 && (U1 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (9 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {}] (8 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {}] (8 0)
Checking x15 :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x20:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}
Checking merge :: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} <: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4 && ielems _v == ielems X5 + ielems X4} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U3} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U3} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  False ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U3 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x20 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21) && ((ilen x20 >= 0 && ilen x20 <= ilen xs) && (((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))) && ((ilen x21 >= 0 && ilen x21 <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen x21 >= 0 && ilen x21 < ilen ys))))))))))))))
  C2 && (M1 && (M3 && (U1 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (9 0)
Checking xs :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge x15
                                             (?? :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)}
Checking ICons :: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} /\ X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:A7 -> x21:IList {A7|x20 <= _v} -> {IList A7|_v == (ICons x20 x21)} <: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons X5 X4)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x20 x21)} /\ {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen X4} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  False ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v}
{x14 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && ([_v -> x20]U2 && (_v == (ICons x20 x21) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))))))))))))
  C2 && (M1 && (M3 && (U1 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A7|False}|_v == (INil)}
Checking INil :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A7|False}|_v == (INil)} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 0)
Checking x15 :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}
Checking merge :: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- x20:{IList A7|ilen _v >= 0 && ilen _v <= ilen xs} -> x21:{IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} <: X5:_ -> X4:_ -> {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A7
UNIFY A7 WITH {a|U1} PRODUCING {a|U2}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U2}
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4 && ielems _v == ielems X5 + ielems X4} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|U2} <: {a|U1} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21} /\ {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x20, x21, xs, ys True, C2, M1, M3 |- {a|U2} /\ {a|U1} ()
Pred assignment
addSplitConstraint X4, X5, merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == ilen X5 + ilen X4} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  False ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v}
{x14 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C2 -> {}, M1 -> {}, M3 -> {}, U2 -> {x10 <= _v}]
Checking consistency
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x20 >= 0 && (ilen x21 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21) && ((ilen x20 >= 0 && ilen x20 <= ilen xs) && (((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))) && ((ilen x21 >= 0 && ilen x21 <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen x21 >= 0 && ilen x21 < ilen ys))))))))))))))
  C2 && (M1 && (M3 && (U1 && (U2 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && ilen ys >= 0)))))))
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Checking xs :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (merge
                                                    (?? :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs})
                                                    (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
                                             (?? :: LET x18:({IList A7|ilen _v == ilen x20 + ilen x21 && ielems _v == ielems x20 + ielems x21}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Checking x15 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Checking x11 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x14 (ICons (?? :: A7)
                                                        (?? :: IList {A7|x20 <= _v})))
Checking x14 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 0)
Checking x10 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x10, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption _v == x10 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 0)
Checking program ICons x14
                   (ICons x14 INil)
Checking ICons x14 (ICons x14
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x14 (INil))}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 (INil)) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
x17 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 INil)
Checking program ICons x14
                   (ICons x14 x15)
Checking ICons x14 (ICons x14
                      x15) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x14 x15)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x15) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
x17 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 x15) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 x15)
Checking program ICons x14
                   (ICons x14 x11)
Checking ICons x14 (ICons x14
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x14 x11)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x11) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
x17 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 x11)
*******************Filling holes in ICons
                                      x14 (ICons x14 (merge
                                                        (?? :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs})
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Checking x15 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Checking x11 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x10 (ICons (?? :: A7)
                                                        (?? :: IList {A7|x20 <= _v})))
Checking x14 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x14, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption _v == x14 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 0)
Checking x10 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 0)
Checking program ICons x14
                   (ICons x10 INil)
Checking ICons x14 (ICons x10
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x10 (INil))}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x10 (INil)) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (7 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
x17 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x10 INil)
Checking program ICons x14
                   (ICons x10 x15)
Checking ICons x14 (ICons x10
                      x15) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x10 x15)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x10 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x10 x15) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x10 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x10 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
x17 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 x15) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x10 x15)
Checking program ICons x14
                   (ICons x10 x11)
Checking ICons x14 (ICons x10
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x10 x11)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x10 x11) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
x17 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x10 x11)
*******************Filling holes in ICons
                                      x14 (ICons x10 (merge
                                                        (?? :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs})
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Checking x15 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 0)
Checking x11 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (ICons x14
                                                    (?? :: IList {A7|x14 <= _v}))
                                             (?? :: LET x18:(LET x21:(IList {A7|x14 <= _v}) IN {IList A7|_v == (ICons x14 x21)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x14 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Checking x11 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (ICons x10
                                                    (?? :: IList {A7|x10 <= _v}))
                                             (?? :: LET x18:(LET x21:(IList {A7|x10 <= _v}) IN {IList A7|_v == (ICons x10 x21)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x10 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Checking x11 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge INil (ICons
                                                         (?? :: A8)
                                                         (?? :: IList {A8|x20 <= _v})))
Checking x14 :: A8 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A8 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 0)
Checking x10 :: A8 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A8 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
Strengthening: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x10, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption _v == x10 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 0)
Checking program ICons x14
                   (merge INil INil)
Checking ICons x14 (merge INil
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen (INil) && ielems x17 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen (INil) && ielems x17 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen (INil) && ielems x17 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen (INil) && ielems x17 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen x17 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x17 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x17 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x17 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (merge INil INil)
Checking program ICons x14
                   (merge INil x11)
Checking ICons x14 (merge INil
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen x11 && ielems x17 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen x11 && ielems x17 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen x11 && ielems x17 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen x11 && ielems x17 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen x17 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x17 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x17 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x17 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (merge INil x11)
*******************Filling holes in ICons
                                      x14 (merge INil (merge
                                                         (?? :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs})
                                                         (?? :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U3} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (9 0)
Checking x15 :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 0)
Checking x11 :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge x15 (ICons (?? :: A7)
                                                        (?? :: IList {A7|x20 <= _v})))
Checking x14 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 0)
Checking x10 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x10, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption _v == x10 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 0)
Checking program ICons x14
                   (merge x15 INil)
Checking ICons x14 (merge x15
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen (INil) && ielems x17 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen (INil) && ielems x17 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen (INil) && ielems x17 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen (INil) && ielems x17 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen x17 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x17 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x17 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x17 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           x15 INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (merge x15 INil)
Checking program ICons x14
                   (merge x15 x11)
Checking ICons x14 (merge x15
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x11 && ielems x17 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x11 && ielems x17 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x11 && ielems x17 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x11 && ielems x17 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen x17 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x17 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x17 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x17 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           x15 x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (merge x15 x11)
*******************Filling holes in ICons
                                      x14 (merge x15 (merge
                                                        (?? :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs})
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Checking x15 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 0)
Checking x11 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (merge INil
                                                    (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
                                             (?? :: LET x18:(LET x21:({IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}) IN {IList A7|ilen _v == ilen (INil) + ilen x21 && ielems _v == ielems (INil) + ielems x21}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U2} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (merge x15
                                                    (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
                                             (?? :: LET x18:(LET x21:({IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}) IN {IList A7|ilen _v == ilen x15 + ilen x21 && ielems _v == ielems x15 + ielems x21}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x14 (ICons (?? :: A7)
                                                        (?? :: IList {A7|x20 <= _v})))
Checking x14 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 0)
Checking x10 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x10, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption _v == x10 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 0)
Checking program ICons x10
                   (ICons x14 INil)
Checking ICons x10 (ICons x14
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x14 (INil))}) IN {IList A5|_v == (ICons x10 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 (INil)) && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
x17 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10
                             (ICons x14 INil)
Checking program ICons x10
                   (ICons x14 x15)
Checking ICons x10 (ICons x14
                      x15) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x14 x15)}) IN {IList A5|_v == (ICons x10 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x15) && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
x17 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 x15) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10
                             (ICons x14 x15)
Checking program ICons x10
                   (ICons x14 x11)
Checking ICons x10 (ICons x14
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x14 x11)}) IN {IList A5|_v == (ICons x10 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x11) && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
x17 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10
                             (ICons x14 x11)
*******************Filling holes in ICons
                                      x10 (ICons x14 (merge
                                                        (?? :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs})
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Checking x15 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 0)
Checking x11 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x10 (ICons (?? :: A7)
                                                        (?? :: IList {A7|x20 <= _v})))
Checking x14 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x14, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption _v == x14 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 0)
Checking x10 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 0)
Checking program ICons x10
                   (ICons x10 INil)
Checking ICons x10 (ICons x10
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x10 (INil))}) IN {IList A5|_v == (ICons x10 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x10 (INil)) && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (7 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
x17 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10
                             (ICons x10 INil)
Checking program ICons x10
                   (ICons x10 x15)
Checking ICons x10 (ICons x10
                      x15) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x10 x15)}) IN {IList A5|_v == (ICons x10 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x10 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x10 x15) && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x10 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x10 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
x17 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 x15) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10
                             (ICons x10 x15)
Checking program ICons x10
                   (ICons x10 x11)
Checking ICons x10 (ICons x10
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|_v == (ICons x10 x11)}) IN {IList A5|_v == (ICons x10 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x10 x11) && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
x17 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10
                             (ICons x10 x11)
*******************Filling holes in ICons
                                      x10 (ICons x10 (merge
                                                        (?? :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs})
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Checking x15 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Checking x11 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (ICons x14
                                                    (?? :: IList {A7|x14 <= _v}))
                                             (?? :: LET x18:(LET x21:(IList {A7|x14 <= _v}) IN {IList A7|_v == (ICons x14 x21)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x14 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Checking x11 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (ICons x10
                                                    (?? :: IList {A7|x10 <= _v}))
                                             (?? :: LET x18:(LET x21:(IList {A7|x10 <= _v}) IN {IList A7|_v == (ICons x10 x21)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x10 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Checking x11 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge INil (ICons
                                                         (?? :: A8)
                                                         (?? :: IList {A8|x20 <= _v})))
Checking x14 :: A8 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A8 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
Strengthening: C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x14, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption _v == x14 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 0)
Checking x10 :: A8 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A8 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 0)
Checking program ICons x10
                   (merge INil INil)
Checking ICons x10 (merge INil
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A5|_v == (ICons x10 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen (INil) && ielems x17 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen (INil) && ielems x17 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {}] (8 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {}] (8 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen (INil) && ielems x17 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen (INil) && ielems x17 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen x17 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x17 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x17 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x17 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10
                             (merge INil INil)
Checking program ICons x10
                   (merge INil x11)
Checking ICons x10 (merge INil
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A5|_v == (ICons x10 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen x11 && ielems x17 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen x11 && ielems x17 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen x11 && ielems x17 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen (INil) + ilen x11 && ielems x17 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen x17 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x17 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x17 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x17 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10
                             (merge INil x11)
*******************Filling holes in ICons
                                      x10 (merge INil (merge
                                                         (?? :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs})
                                                         (?? :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U3} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (9 0)
Checking x15 :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 0)
Checking x11 :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A8|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge x15 (ICons (?? :: A7)
                                                        (?? :: IList {A7|x20 <= _v})))
Checking x14 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x14} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 0)
Checking x10 :: A7 in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: A7 ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|_v == x10} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 0)
Checking program ICons x10
                   (merge x15 INil)
Checking ICons x10 (merge x15
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A5|_v == (ICons x10 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen (INil) && ielems x17 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen (INil) && ielems x17 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen (INil) && ielems x17 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen (INil) && ielems x17 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen x17 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x17 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x17 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x17 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10
                             (merge x15 INil)
Checking program ICons x10
                   (merge x15 x11)
Checking ICons x10 (merge x15
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:({IList A6|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A5|_v == (ICons x10 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x10 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x10] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x11 && ielems x17 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x11 && ielems x17 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x11 && ielems x17 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x11 && ielems x17 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen x17 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x17 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x17 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x17 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x10
                             (merge x15 x11)
*******************Filling holes in ICons
                                      x10 (merge x15 (merge
                                                        (?? :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs})
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x20 >= 0 && ilen x20 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Checking x15 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 0)
Checking x11 :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x11, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == x11 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x11 ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x11
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|ilen _v >= 0 && ilen _v <= ilen xs} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v >= 0 && ilen _v <= ilen xs
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(ilen _v >= 0 && ilen _v <= ilen xs)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|ilen _v >= 0 && ilen _v <= ilen xs}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (merge INil
                                                    (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
                                             (?? :: LET x18:(LET x21:({IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}) IN {IList A7|ilen _v == ilen (INil) + ilen x21 && ielems _v == ielems (INil) + ielems x21}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U2} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (merge x15
                                                    (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
                                             (?? :: LET x18:(LET x21:({IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}) IN {IList A7|ilen _v == ilen x15 + ilen x21 && ielems _v == ielems x15 + ielems x21}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x14 (ICons x14
                                                        (?? :: IList {A7|x14 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x14 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Checking x11 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x14 (ICons x10
                                                        (?? :: IList {A7|x10 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x10 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Checking x11 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x14 (merge INil
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U2} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x14 (merge x15
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x10 (ICons x14
                                                        (?? :: IList {A7|x14 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x14 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 0)
Checking x11 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x10 (ICons x10
                                                        (?? :: IList {A7|x10 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x10 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 0)
Checking x11 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x10 (merge INil
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U2} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (ICons x10 (merge x15
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (ICons x14 INil)
                                             (?? :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U1} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x14 (INil)) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
_v == x15, x18 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x14 <= _v}|_v == (ICons x14 (INil))} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
_v == xs, x18 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x14 <= _v}|_v == (ICons x14 (INil))} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
_v == ys, x18 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x14 <= _v}|_v == (ICons x14 (INil))} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (ICons x14 x15)
                                             (?? :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x14 x15) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, x18 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x14 <= _v}|_v == (ICons x14 x15)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, x18 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x14 <= _v}|_v == (ICons x14 x15)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, x18 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x14 <= _v}|_v == (ICons x14 x15)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (ICons x14 x11)
                                             (?? :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x14 x11) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, x18 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x14 <= _v}|_v == (ICons x14 x11)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, x18 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x14 <= _v}|_v == (ICons x14 x11)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, x18 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x14 <= _v}|_v == (ICons x14 x11)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (ICons x10 INil)
                                             (?? :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U1} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x10 (INil)) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, x18 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x14 <= _v}|_v == (ICons x10 (INil))} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, x18 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x14 <= _v}|_v == (ICons x10 (INil))} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == ys, x18 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x14 <= _v}|_v == (ICons x10 (INil))} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (ICons x10 x15)
                                             (?? :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x10 x15) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, x18 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x14 <= _v}|_v == (ICons x10 x15)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, x18 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x14 <= _v}|_v == (ICons x10 x15)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, x18 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x14 <= _v}|_v == (ICons x10 x15)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (ICons x10 x11)
                                             (?? :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x10 x11) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, x18 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x14 <= _v}|_v == (ICons x10 x11)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, x18 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x14 <= _v}|_v == (ICons x10 x11)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, x18 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x14 <= _v}|_v == (ICons x10 x11)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge INil (ICons x14
                                                         (?? :: IList {A8|x14 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: IList {A8|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U3 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (10 0)
Checking x15 :: IList {A8|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A8|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U3 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 0)
Checking x11 :: IList {A8|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A8|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U3 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A8|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A8|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A8|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A8|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge INil (ICons x10
                                                         (?? :: IList {A8|x10 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: IList {A8|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U3 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (10 0)
Checking x15 :: IList {A8|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A8|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U3 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 0)
Checking x11 :: IList {A8|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A8|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U3 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A8|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A8|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A8|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A8|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge INil (merge INil
                                                         (?? :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A10 -> x23:IList {A10|x22 <= _v} -> {IList A10|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
Checking INil :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A10
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U3} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}, U5 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}, U5 -> {}] (10 0)
Checking x15 :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge INil (merge x15
                                                         (?? :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U3} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}, U4 -> {}] (12 0)
Checking x15 :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (13 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {}, U3 -> {x14 <= _v}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge x15 (ICons x14
                                                        (?? :: IList {A7|x14 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x14 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Checking x15 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Checking x11 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge x15 (ICons x10
                                                        (?? :: IList {A7|x10 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x10 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Checking x15 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Checking x11 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge x15 (merge INil
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U2} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (13 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge x15 (merge x15
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (13 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (merge INil INil)
                                             (?? :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A10 -> x23:IList {A10|x22 <= _v} -> {IList A10|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A10|False}|_v == (INil)} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A10
UNIFY A10 WITH {a|U1} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (11 0)
Checking x15 :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (merge INil x11)
                                             (?? :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U1} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Checking x15 :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (13 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (merge x15 INil)
                                             (?? :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U1} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Checking x15 :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (13 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x14 (merge (merge x15 x11)
                                             (?? :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (13 0)
Checking x15 :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (13 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x18 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x18 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (14 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (14 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x18 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x18 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (12 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x18 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x18 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x14 <= _v}|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} -> {IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x14 (ICons x14
                                                        (?? :: IList {A7|x14 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x14 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 0)
Checking x11 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x14 (ICons x10
                                                        (?? :: IList {A7|x10 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x10 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 0)
Checking x11 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x14 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x14 (merge INil
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U2} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x14 (merge x15
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x14 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x14 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x10 (ICons x14
                                                        (?? :: IList {A7|x14 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x14 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Checking x11 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x10 (ICons x10
                                                        (?? :: IList {A7|x10 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x10 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 0)
Checking x15 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Checking x11 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (9 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x10 (merge INil
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U2} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (ICons x10 (merge x15
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (ICons x14 INil)
                                             (?? :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U1} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x14 (INil)) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
_v == x15, x18 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x10 <= _v}|_v == (ICons x14 (INil))} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
_v == xs, x18 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x10 <= _v}|_v == (ICons x14 (INil))} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
_v == ys, x18 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x10 <= _v}|_v == (ICons x14 (INil))} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (ICons x14 x15)
                                             (?? :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x14 x15) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, x18 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x10 <= _v}|_v == (ICons x14 x15)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, x18 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x10 <= _v}|_v == (ICons x14 x15)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, x18 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x10 <= _v}|_v == (ICons x14 x15)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (ICons x14 x11)
                                             (?? :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x14 x11) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, x18 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x10 <= _v}|_v == (ICons x14 x11)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, x18 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x10 <= _v}|_v == (ICons x14 x11)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, x18 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x10 <= _v}|_v == (ICons x14 x11)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (ICons x10 INil)
                                             (?? :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U1} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x10 (INil)) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, x18 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x10 <= _v}|_v == (ICons x10 (INil))} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, x18 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x10 <= _v}|_v == (ICons x10 (INil))} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == ys, x18 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x10 <= _v}|_v == (ICons x10 (INil))} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (ICons x10 x15)
                                             (?? :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x10 x15) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, x18 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x10 <= _v}|_v == (ICons x10 x15)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, x18 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x10 <= _v}|_v == (ICons x10 x15)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, x18 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x10 <= _v}|_v == (ICons x10 x15)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (ICons x10 x11)
                                             (?? :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (x18 == (ICons x10 x11) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Checking x15 :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, x18 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (x18 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x10 <= _v}|_v == (ICons x10 x11)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, x18 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (x18 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x10 <= _v}|_v == (ICons x10 x11)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (x18 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, x18 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (x18 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x10 <= _v}|_v == (ICons x10 x11)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge INil (ICons x14
                                                         (?? :: IList {A8|x14 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: IList {A8|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U3 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (10 0)
Checking x15 :: IList {A8|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A8|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U3 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 0)
Checking x11 :: IList {A8|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A8|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U3 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A8|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A8|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A8|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A8|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge INil (ICons x10
                                                         (?? :: IList {A8|x10 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: IList {A8|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U3 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (10 0)
Checking x15 :: IList {A8|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A8|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U3 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 0)
Checking x11 :: IList {A8|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A8|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U3 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A8|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A8|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A8|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A8|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge INil (merge INil
                                                         (?? :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A10 -> x23:IList {A10|x22 <= _v} -> {IList A10|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
Checking INil :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A10
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U3} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}, U5 -> {}] (10 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}, U5 -> {}] (10 0)
Checking x15 :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (11 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (10 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (10 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge INil (merge x15
                                                         (?? :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U3} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U3} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}, U4 -> {}] (12 0)
Checking x15 :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (13 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U3} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {}, U3 -> {x10 <= _v}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U3
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge x15 (ICons x14
                                                        (?? :: IList {A7|x14 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x14 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Checking x15 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Checking x11 :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C2 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x14 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x14 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x14 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x14 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x14 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge x15 (ICons x10
                                                        (?? :: IList {A7|x10 <= _v})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: IList {A7|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2 && x10 <= _v} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 0)
Checking x15 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Checking x11 :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: IList {A7|x10 <= _v} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: IList {A7|x10 <= _v} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2 && x10 <= _v} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2 && x10 <= _v
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
IList {a|x10 <= _v && x10 <= _v}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge x15 (merge INil
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U2} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (13 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge x15 (merge x15
                                                        (?? :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))})))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U2} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U2} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (12 0)
Checking x15 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (13 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: {IList A7|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- a <: {a|U2} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U2
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
{IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (merge INil INil)
                                             (?? :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A10 -> x23:IList {A10|x22 <= _v} -> {IList A10|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A10|False}|_v == (INil)} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A10
UNIFY A10 WITH {a|U1} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (11 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (11 0)
Checking x15 :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (12 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen (INil) && ielems x18 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (11 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (11 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (merge INil x11)
                                             (?? :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U1} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Checking x15 :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (13 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen (INil) + ilen x11 && ielems x18 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (merge x15 INil)
                                             (?? :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A9 -> x23:IList {A9|x22 <= _v} -> {IList A9|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A9|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A9|False}|_v == (INil)} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A9
UNIFY A9 WITH {a|U1} PRODUCING {a|U4}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}, U4 -> {}] (12 0)
Checking x15 :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (13 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x18 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x18 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen (INil) && ielems x18 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (12 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (12 1)
Invalid Constraint: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
Strengthening: C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
*******************Filling holes in ICons
                                      x10 (merge (merge x15 x11)
                                             (?? :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A8|False}|_v == (INil)}
Checking INil :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {A8|False}|_v == (INil)} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A8
UNIFY A8 WITH {a|U1} PRODUCING {a|U3}
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|False} <: {a|U1} ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
Constraints
  C2 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (13 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}, U3 -> {}] (13 0)
Checking x15 :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x15} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x14 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (13 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == x15, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x18 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == x15 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x18 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking x15 ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> x15
Checking x11 :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {a|x10 <= _v} <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (14 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (14 0)
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x22:{IList A8|ilen _v >= 0 && ilen _v <= ilen xs} -> x23:{IList A8|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x22 >= 0 && ilen x22 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A8|ilen _v == ilen x22 + ilen x23 && ielems _v == ielems x22 + ielems x23}
Checking xs :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == xs} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == xs} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == xs && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == xs, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x18 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == xs && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x18 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking xs ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> xs
Checking ys :: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- {IList a|_v == ys} <: LET x18:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- {IList|_v == ys} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x18, xs, ys True, C2, M1, M3 |- a <: {a|U1} ()
Pred assignment
Constraints
  C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C2 && (M1 && (M3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))) ==> U1
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x10 <= _v}, U2 -> {x10 <= _v}] (12 2)
Invalid Constraint: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Strengthening: C2 && (M1 && (M3 && (_v == ys && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x18 == ilen x15 + ilen x11 && ielems x18 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
_v == ys, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x18 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x18 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen x18 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
assumption _v == ys && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x18 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x18 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))
mustHave !((ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ys ::
x18:{IList {a|x10 <= _v}|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} -> {IList {a|x10 <= _v}|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x18 >= 0 && ilen x18 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ys
Checking program ICons x14
                   (ICons x14 (ICons x14 INil))
Checking ICons x14 (ICons x14
                      (ICons x14
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:(LET x19:({IList A7|_v == (ICons x14 (INil))}) IN {IList A6|_v == (ICons x14 x19)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 (INil)) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
x17 == (ICons x14 x19), x19 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen x19 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x19) && (x19 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x19)) == 1 + ilen x19 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x19)) == [x14] + ielems x19 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 (ICons x14 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 (ICons x14 INil))
Checking program ICons x14
                   (ICons x14 (ICons x14 x15))
Checking ICons x14 (ICons x14
                      (ICons x14
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:(LET x19:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|_v == (ICons x14 x19)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 x15) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19
All assumptions:
x17 == (ICons x14 x19), x19 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen x19 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x19) && (x19 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x19)) == 1 + ilen x19 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x19)) == [x14] + ielems x19 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 (ICons x14 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 (ICons x14 x15))
Checking program ICons x14
                   (ICons x14 (ICons x14 x11))
Checking ICons x14 (ICons x14
                      (ICons x14
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:(LET x19:({IList A7|_v == (ICons x14 x11)}) IN {IList A6|_v == (ICons x14 x19)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 x11) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x14 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19
All assumptions:
x17 == (ICons x14 x19), x19 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen x19 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x19) && (x19 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x19)) == 1 + ilen x19 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x19)) == [x14] + ielems x19 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 (ICons x14 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 (ICons x14 x11))
Checking program ICons x14
                   (ICons x14 (ICons x10 INil))
Checking ICons x14 (ICons x14
                      (ICons x10
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:(LET x19:({IList A7|_v == (ICons x10 (INil))}) IN {IList A6|_v == (ICons x14 x19)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 (INil)) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (9 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, ielems (INil) == []
All assumptions:
x17 == (ICons x14 x19), x19 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen x19 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x19) && (x19 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x19)) == 1 + ilen x19 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x19)) == [x14] + ielems x19 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 (ICons x10 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 (ICons x10 INil))
Checking program ICons x14
                   (ICons x14 (ICons x10 x15))
Checking ICons x14 (ICons x14
                      (ICons x10
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:(LET x19:({IList A7|_v == (ICons x10 x15)}) IN {IList A6|_v == (ICons x14 x19)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 x15) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19
All assumptions:
x17 == (ICons x14 x19), x19 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, x10 <= x14, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen x19 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x19) && (x19 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x19)) == 1 + ilen x19 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x19)) == [x14] + ielems x19 && (x10 <= x14 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 (ICons x10 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 (ICons x10 x15))
Checking program ICons x14
                   (ICons x14 (ICons x10 x11))
Checking ICons x14 (ICons x14
                      (ICons x10
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:(LET x19:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|_v == (ICons x14 x19)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 x11) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (x19 == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19
All assumptions:
x17 == (ICons x14 x19), x19 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen x19 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x19) && (x19 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x19)) == 1 + ilen x19 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x19)) == [x14] + ielems x19 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 (ICons x10 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 (ICons x10 x11))
Checking program ICons x14
                   (ICons x14 (merge INil INil))
Checking ICons x14 (ICons x14
                      (merge INil
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:(LET x19:({IList A7|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A6|_v == (ICons x14 x19)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen (INil) + ilen (INil) && ielems x19 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen (INil) + ilen (INil) && ielems x19 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}] (10 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen (INil) + ilen (INil) && ielems x19 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen (INil) + ilen (INil) && ielems x19 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, ielems (INil) == []
All assumptions:
x17 == (ICons x14 x19), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen x19 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ilen (INil) == 0, ielems x19 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen x19 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x19) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x19 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x19)) == 1 + ilen x19 && (ilen (INil) == 0 && (ielems x19 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x19)) == [x14] + ielems x19 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 (merge INil INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 (merge INil INil))
Checking program ICons x14
                   (ICons x14 (merge INil x11))
Checking ICons x14 (ICons x14
                      (merge INil
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:(LET x19:({IList A7|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A6|_v == (ICons x14 x19)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen (INil) + ilen x11 && ielems x19 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen (INil) + ilen x11 && ielems x19 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen (INil) + ilen x11 && ielems x19 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen (INil) + ilen x11 && ielems x19 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, ielems (INil) == []
All assumptions:
x17 == (ICons x14 x19), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen x19 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ilen (INil) == 0, ielems x19 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, ielems (INil) == [], x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen x19 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x19) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x19 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x19)) == 1 + ilen x19 && (ilen (INil) == 0 && (ielems x19 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x19)) == [x14] + ielems x19 && (ielems (INil) == [] && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 (merge INil x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 (merge INil x11))
Checking program ICons x14
                   (ICons x14 (merge x15 INil))
Checking ICons x14 (ICons x14
                      (merge x15
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:(LET x19:({IList A7|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A6|_v == (ICons x14 x19)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen x15 + ilen (INil) && ielems x19 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen x15 + ilen (INil) && ielems x19 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}] (11 2)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen x15 + ilen (INil) && ielems x19 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen x15 + ilen (INil) && ielems x19 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, ielems (INil) == []
All assumptions:
x17 == (ICons x14 x19), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x17, ilen x19 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ilen (INil) == 0, ielems x19 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen x19 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption x17 == (ICons x14 x19) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x19 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x19)) == 1 + ilen x19 && (ilen (INil) == 0 && (ielems x19 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x19)) == [x14] + ielems x19 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x14 (merge x15 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ICons x14
                             (ICons x14 (merge x15 INil))
Checking program ICons x14
                   (ICons x14 (merge x15 x11))
Checking ICons x14 (ICons x14
                      (merge x15
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C2, M1, M3 |- LET x17:(LET x19:({IList A7|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A6|_v == (ICons x14 x19)}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C2, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen x15 + ilen x11 && ielems x19 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen x15 + ilen x11 && ielems x19 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (13 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (13 1)
Invalid Constraint: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen x15 + ilen x11 && ielems x19 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
Strengthening: C2 && (M1 && (M3 && (x17 == (ICons x14 x19) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x19 == ilen x15 + ilen x11 && ielems x19 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19
All assumptions:
x17 == (ICons x14 x19), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x19 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x19)) == 1 + ilen x19, ielems _v == [x14] + ielems x17, ielems x19 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x19)) == [x14] + ielems x19, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen x17 >= 0, ilen x19 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ielems _v == ielems xs + ielems ys
assumption x17 == (ICons x14 x19) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x19 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x19)) == 1 + ilen x19 && (ielems _v == [x14] + ielems x17 && (ielems x19 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x19)) == [x14] + ielems x19 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ielems _v == ielems xs + ielems ys)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C2 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (14 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (14 0)
Typing Constraints
Type assignment
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
Simple Constraints
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (14 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}] (14 0)
Auxiliary goals are:
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (ICons x10
                      (ICons x14
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 (INil))} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 (INil)) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 (ICons x14 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (ICons x10 (ICons
                                           x14 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (ICons x10
                      (ICons x14
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x15)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x15)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 (ICons x14 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (ICons x10 (ICons
                                           x14 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (ICons x10
                      (ICons x14
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x11)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x11)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 (ICons x14 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (ICons x10 (ICons
                                           x14 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (ICons x10
                      (ICons x10
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 (INil))} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 (INil)) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 (ICons x10 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (ICons x10 (ICons
                                           x10 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (ICons x10
                      (ICons x10
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x15)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x15)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 (ICons x10 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (ICons x10 (ICons
                                           x10 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (ICons x10
                      (ICons x10
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x11)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x11)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 (ICons x10 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (ICons x10 (ICons
                                           x10 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x14 (ICons x10
                      (merge INil
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x25 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x25 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x25 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x25 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 (merge INil INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (ICons x10 (merge
                                           INil INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (ICons x10
                      (merge INil
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x25 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x25 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x25 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x25 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 (merge INil x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (ICons x10 (merge
                                           INil x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (ICons x10
                      (merge x15
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x25 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x25 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x25 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x25 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 (merge x15 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (ICons x10 (merge
                                           x15 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
Checking ICons x14 (ICons x10
                      (merge x15
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
Strengthening: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> True && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x14 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(True && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C3 -> {}, C4 -> {}, M1 -> {}, M3 -> {}, U4 -> {x14 <= _v}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
Strengthening: C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), _v == x10, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (_v == x10 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C3 -> {}, C4 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {}] (23 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {}] (23 1)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
Strengthening: C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x14 <= _v && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v && x10 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v]
Optimal valuations:
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C3 -> {}, C4 -> {}, M1 -> {}, M3 -> {}, U5 -> {x10 <= _v}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x10 <= _v}] (23 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x10 <= _v}] (23 1)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
Strengthening: C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (ICons
                           x10 (merge x15 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (ICons x10 (merge
                                           x15 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x14 (merge (ICons
                             x14 INil)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 (INil))} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A12 WITH {a|U4} PRODUCING {a|U3}
UNIFY A10 WITH {a|U4} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x14 INil) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x14
                                       INil) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge (ICons
                             x14 INil)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 (INil))} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems x23 == ielems x24 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x14 INil) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x14
                                       INil) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge (ICons
                             x14 x15)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x15)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x15)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x14 x15) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x14
                                       x15) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (merge (ICons
                             x14 x15)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x15)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x15)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x23 == ilen x24 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems _v == [x14] + ielems x23, ielems x23 == ielems x24 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ielems _v == ielems xs + ielems ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x23 == ilen x24 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems _v == [x14] + ielems x23 && (ielems x23 == ielems x24 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ielems _v == ielems xs + ielems ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x14 x15) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x14
                                       x15) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge (ICons
                             x14 x11)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x11)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x11)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x14 x11) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x14
                                       x11) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (merge (ICons
                             x14 x11)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x11)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x11)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x24 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x24 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x14 x11) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x14
                                       x11) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x14 (merge (ICons
                             x10 INil)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 (INil))} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A12 WITH {a|U4} PRODUCING {a|U3}
UNIFY A10 WITH {a|U4} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x10 INil) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x10
                                       INil) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge (ICons
                             x10 INil)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 (INil))} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x10 INil) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x10
                                       INil) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge (ICons
                             x10 x15)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x15)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x15)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x10 x15) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x10
                                       x15) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (merge (ICons
                             x10 x15)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x15)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x15)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
Strengthening: C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> True && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x10 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(True && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C3 -> {}, C4 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (23 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (23 1)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
Strengthening: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> True && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x14 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(True && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C3 -> {}, C4 -> {}, M1 -> {}, M3 -> {}, U4 -> {x14 <= _v}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
Strengthening: C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x10 x15) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x10
                                       x15) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge (ICons
                             x10 x11)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x11)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x11)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x10 x11) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x10
                                       x11) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (merge (ICons
                             x10 x11)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x11)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x11)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x24 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x24 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (ICons x10 x11) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (ICons x10
                                       x11) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x14 (merge INil
                      (ICons x14
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x14 (INil))} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: IList {A11|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A11 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil (ICons x14 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge INil
                                (ICons x14 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
Checking ICons x14 (merge INil
                      (ICons x14
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x14 x15)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A11|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x15)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil (ICons x14 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge INil
                                (ICons x14 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
Checking ICons x14 (merge INil
                      (ICons x14
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x14 x11)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A11|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x11)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil (ICons x14 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge INil
                                (ICons x14 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x14 (merge INil
                      (ICons x10
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x10 (INil))} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: IList {A11|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A11 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil (ICons x10 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge INil
                                (ICons x10 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
Checking ICons x14 (merge INil
                      (ICons x10
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x10 x15)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A11|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x15)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil (ICons x10 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge INil
                                (ICons x10 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
Checking ICons x14 (merge INil
                      (ICons x10
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x10 x11)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A11|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x11)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil (ICons x10 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge INil
                                (ICons x10 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A11|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A11|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A13|False}|_v == (INil)}
Checking ICons x14 (merge INil
                      (merge INil
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A13|False}|_v == (INil)} <: {IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A13
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A11|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A11 WITH {a|U4} PRODUCING {a|U3}
UNIFY A13 WITH {a|U3} PRODUCING {a|U4}
UNIFY A12 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U5}
A13 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U5}
A13 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen x25 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems x25 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen x25 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems x25 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil (merge INil INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge INil
                                (merge INil INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A11|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A11|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x14 (merge INil
                      (merge INil
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A11|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A11 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen x25 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems x25 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen x25 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems x25 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil (merge INil x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge INil
                                (merge INil x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A11|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A11|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x14 (merge INil
                      (merge x15
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A11|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A11 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen x25 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems x25 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen x25 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems x25 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil (merge x15 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge INil
                                (merge x15 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A11|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A11|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
Checking ICons x14 (merge INil
                      (merge x15
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A11|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen x25 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems x25 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen x25 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems x25 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           INil (merge x15 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge INil
                                (merge x15 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge x15
                      (ICons x14
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 (INil))} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems x23 == ielems x15 + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems x23 == ielems x15 + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           x15 (ICons x14 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge x15 (ICons
                                           x14 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (merge x15
                      (ICons x14
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x15)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x15)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x15 + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x15 + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           x15 (ICons x14 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge x15 (ICons
                                           x14 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (merge x15
                      (ICons x14
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x11)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x11)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x23 == ilen x15 + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems _v == [x14] + ielems x23, ielems x23 == ielems x15 + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ielems _v == ielems xs + ielems ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x23 == ilen x15 + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems _v == [x14] + ielems x23 && (ielems x23 == ielems x15 + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ielems _v == ielems xs + ielems ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           x15 (ICons x14 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge x15 (ICons
                                           x14 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge x15
                      (ICons x10
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 (INil))} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x15 + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x15 + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           x15 (ICons x10 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge x15 (ICons
                                           x10 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (merge x15
                      (ICons x10
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x15)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x15)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x15 + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x15 + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           x15 (ICons x10 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge x15 (ICons
                                           x10 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x14 (merge x15
                      (ICons x10
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x11)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x11)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (23 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (23 1)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
Strengthening: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> True && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x14 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(True && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C3 -> {}, C4 -> {}, M1 -> {}, M3 -> {}, U4 -> {x14 <= _v}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {}] (23 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {}] (23 1)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
Strengthening: C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= _v, x14 <= x10}
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C3 -> {}, C4 -> {}, M1 -> {}, M3 -> {}, U5 -> {x14 <= _v}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
Strengthening: C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), _v == x10, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (_v == x10 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C3 -> {}, C4 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}] (24 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}] (24 0)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x14 (merge x15
                      (merge INil
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A10 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen x25 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x15 + ielems x25, ielems x25 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen x25 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x15 + ielems x25 && (ielems x25 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           x15 (merge INil INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge x15 (merge
                                           INil INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge x15
                      (merge INil
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen x25 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x15 + ielems x25, ielems x25 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen x25 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x15 + ielems x25 && (ielems x25 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           x15 (merge INil x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge x15 (merge
                                           INil x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge x15
                      (merge x15
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen x25 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x15 + ielems x25, ielems x25 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen x25 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x15 + ielems x25 && (ielems x25 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           x15 (merge x15 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge x15 (merge
                                           x15 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
Checking ICons x14 (merge x15
                      (merge x15
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen x25 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x15 + ielems x25, ielems x25 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen x25 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x15 + ielems x25 && (ielems x25 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           x15 (merge x15 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge x15 (merge
                                           x15 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A13|False}|_v == (INil)}
Checking ICons x14 (merge (merge
                             INil INil)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A13|False}|_v == (INil)} <: LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A13
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A13 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U5} PRODUCING {a|U4}
UNIFY A11 WITH {a|U5} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U5}
A12 -> {a|U4}
A13 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U5}
A12 -> {a|U4}
A13 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen x24 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems x24 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen x24 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems x24 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (merge INil INil) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (merge
                                       INil INil) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x14 (merge (merge
                             INil INil)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A10 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen x24 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems x11, ielems x24 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen x24 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems x11 && (ielems x24 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (merge INil INil) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (merge
                                       INil INil) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x14 (merge (merge
                             INil x11)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A12 WITH {a|U4} PRODUCING {a|U3}
UNIFY A10 WITH {a|U4} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen x24 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems x24 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen x24 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems x24 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (merge INil x11) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (merge
                                       INil x11) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge (merge
                             INil x11)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen x24 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems x11, ielems x24 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen x24 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems x11 && (ielems x24 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (merge INil x11) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (merge
                                       INil x11) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x14 (merge (merge
                             x15 INil)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A12 WITH {a|U4} PRODUCING {a|U3}
UNIFY A10 WITH {a|U4} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen x24 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems x24 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen x24 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems x24 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (merge x15 INil) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (merge x15
                                       INil) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge (merge
                             x15 INil)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen x24 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems x11, ielems x24 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen x24 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems x11 && (ielems x24 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (merge x15 INil) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (merge x15
                                       INil) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x14 (merge (merge
                             x15 x11)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen x24 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems x24 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen x24 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems x24 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (merge x15 x11) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (merge x15
                                       x11) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
Checking ICons x14 (merge (merge
                             x15 x11)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x14 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen x24 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x24 + ielems x11, ielems x24 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen x24 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x24 + ielems x11 && (ielems x24 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x14 (merge
                           (merge x15 x11) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x14 (merge (merge x15
                                       x11) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (ICons x14
                      (ICons x14
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|_v == (ICons x14 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|_v == (ICons x14 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 (INil))} <: IList {A9|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x14 x25), x25 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x14 x25) && (x25 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x25)) == 1 + ilen x25 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x25)) == [x14] + ielems x25 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 (ICons x14 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x14 (ICons
                                           x14 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (ICons x14
                      (ICons x14
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|_v == (ICons x14 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|_v == (ICons x14 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x15)} <: IList {A9|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x15)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x14 x25), x25 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x14 x25) && (x25 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x25)) == 1 + ilen x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x25)) == [x14] + ielems x25 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 (ICons x14 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x14 (ICons
                                           x14 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (ICons x14
                      (ICons x14
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|_v == (ICons x14 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|_v == (ICons x14 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x11)} <: IList {A9|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x11)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x14 x25), x25 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x14 x25) && (x25 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x25)) == 1 + ilen x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x25)) == [x14] + ielems x25 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 (ICons x14 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x14 (ICons
                                           x14 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (ICons x14
                      (ICons x10
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|_v == (ICons x14 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|_v == (ICons x14 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 (INil))} <: IList {A9|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x14 x25), x25 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x14 x25) && (x25 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x25)) == 1 + ilen x25 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x25)) == [x14] + ielems x25 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 (ICons x10 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x14 (ICons
                                           x10 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (ICons x14
                      (ICons x10
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|_v == (ICons x14 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|_v == (ICons x14 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x15)} <: IList {A9|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x15)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x14 x25), x25 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x14 x25) && (x25 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x25)) == 1 + ilen x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x25)) == [x14] + ielems x25 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 (ICons x10 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x14 (ICons
                                           x10 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (ICons x14
                      (ICons x10
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|_v == (ICons x14 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|_v == (ICons x14 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x11)} <: IList {A9|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x11)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x14 x25), x25 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x14 x25) && (x25 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x25)) == 1 + ilen x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x25)) == [x14] + ielems x25 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 (ICons x10 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x14 (ICons
                                           x10 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (ICons x14
                      (merge INil
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|_v == (ICons x14 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|_v == (ICons x14 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: IList {A9|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A10 WITH {a|U4 && x14 <= _v} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x14 x25), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x25 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ilen (INil) == 0, ielems x25 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x14 x25) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x25 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x25)) == 1 + ilen x25 && (ilen (INil) == 0 && (ielems x25 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x25)) == [x14] + ielems x25 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 (merge INil INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x14 (merge
                                           INil INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (ICons x14
                      (merge INil
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|_v == (ICons x14 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|_v == (ICons x14 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: IList {A9|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x14 x25), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x25 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ilen (INil) == 0, ielems x25 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x14 x25) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x25 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x25)) == 1 + ilen x25 && (ilen (INil) == 0 && (ielems x25 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x25)) == [x14] + ielems x25 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 (merge INil x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x14 (merge
                                           INil x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (ICons x14
                      (merge x15
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|_v == (ICons x14 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|_v == (ICons x14 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: IList {A9|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x14 x25), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x25 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 x25)) == 1 + ilen x25, ilen (INil) == 0, ielems x25 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 x25)) == [x14] + ielems x25, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x14 x25) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x25 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x25)) == 1 + ilen x25 && (ilen (INil) == 0 && (ielems x25 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 x25)) == [x14] + ielems x25 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 (merge x15 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x14 (merge
                                           x15 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
Checking ICons x10 (ICons x14
                      (merge x15
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|_v == (ICons x14 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|_v == (ICons x14 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: IList {A9|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x14 x25) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
Strengthening: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> True && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x10 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(True && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C3 -> {}, C4 -> {}, M1 -> {}, M3 -> {}, U4 -> {x10 <= _v}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
Strengthening: C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), _v == x14, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (_v == x14 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C3 -> {}, C4 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {}] (23 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {}] (23 1)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x14 <= _v
Strengthening: C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x10 <= _v && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v && x14 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x14 <= _v}
Pruned valuations:
{x14 <= _v}
Diffs: (1)
[C3 -> {}, C4 -> {}, M1 -> {}, M3 -> {}, U5 -> {x14 <= _v}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {x14 <= _v}] (23 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {x14 <= _v}] (23 1)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
Strengthening: C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, x10 <= x14, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x14 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (x10 <= x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !(x14 <= _v)
qualsList [x14 != x10
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x14 (merge x15 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x14 (merge
                                           x15 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (ICons x10
                      (ICons x14
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 (INil))} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (16 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (16 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 (ICons x14 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x10 (ICons
                                           x14 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (ICons x10
                      (ICons x14
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x15)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x15)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 (ICons x14 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x10 (ICons
                                           x14 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (ICons x10
                      (ICons x14
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x11)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x11)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 (ICons x14 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x10 (ICons
                                           x14 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (ICons x10
                      (ICons x10
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 (INil))} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (16 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (16 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 (ICons x10 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x10 (ICons
                                           x10 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (ICons x10
                      (ICons x10
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x15)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x15)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (17 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 (ICons x10 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x10 (ICons
                                           x10 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (ICons x10
                      (ICons x10
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x11)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x11)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), x25 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (x25 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 (ICons x10 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x10 (ICons
                                           x10 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (ICons x10
                      (merge INil
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x25 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x25 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x25 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x25 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 (merge INil INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x10 (merge
                                           INil INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (ICons x10
                      (merge INil
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x25 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x25 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x25 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x25 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 (merge INil x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x10 (merge
                                           INil x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (ICons x10
                      (merge x15
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x25 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x25 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x25 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x25 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 (merge x15 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x10 (merge
                                           x15 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x24:A9 -> x25:IList {A9|x24 <= _v} -> {IList A9|_v == (ICons x24 x25)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
Checking ICons x10 (ICons x10
                      (merge x15
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|_v == (ICons x10 x25)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|_v == (ICons x10 x25)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: IList {A9|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A9 ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x25)} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x23 == (ICons x10 x25) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x23 == (ICons x10 x25), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x25 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x25)) == 1 + ilen x25, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems _v == [x10] + ielems x23, ielems x25 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x25)) == [x10] + ielems x25, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ielems _v == ielems xs + ielems ys
assumption !(x10 <= x14 && x14 <= x10) && (x23 == (ICons x10 x25) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x25 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x25)) == 1 + ilen x25 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems _v == [x10] + ielems x23 && (ielems x25 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x25)) == [x10] + ielems x25 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ielems _v == ielems xs + ielems ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (ICons
                           x10 (merge x15 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (ICons x10 (merge
                                           x15 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (merge (ICons
                             x14 INil)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 (INil))} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A12 WITH {a|U4} PRODUCING {a|U3}
UNIFY A10 WITH {a|U4} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (ICons x14 INil) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (ICons x14
                                       INil) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge (ICons
                             x14 INil)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 (INil))} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x14 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems x23 == ielems x24 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (ICons x14 INil) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (ICons x14
                                       INil) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge (ICons
                             x14 x15)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x15)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x15)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (ICons x14 x15) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (ICons x14
                                       x15) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (merge (ICons
                             x14 x15)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x15)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x15)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (23 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (23 1)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
Strengthening: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> True && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x10 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(True && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C3 -> {}, C4 -> {}, M1 -> {}, M3 -> {}, U4 -> {x10 <= _v}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {}] (23 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {}] (23 1)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
Strengthening: C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14, x14 <= _v}
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C3 -> {}, C4 -> {}, M1 -> {}, M3 -> {}, U5 -> {x10 <= _v}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {x10 <= _v}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {x10 <= _v}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
Strengthening: C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), _v == x14, xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (_v == x14 && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x10 <= x14}
Pruned valuations:
{x10 <= x14}
Diffs: (1)
[C3 -> {}, C4 -> {x10 <= x14}, M1 -> {}, M3 -> {}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {x10 <= _v}] (24 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x10 <= x14}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {x10 <= _v}] (24 0)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge (ICons
                             x14 x11)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x11)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x11)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (ICons x14 x11) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (ICons x14
                                       x11) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (merge (ICons
                             x14 x11)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x11)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x11)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x14 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x24 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x24 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (ICons x14 x11) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (ICons x14
                                       x11) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (merge (ICons
                             x10 INil)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 (INil))} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A12 WITH {a|U4} PRODUCING {a|U3}
UNIFY A10 WITH {a|U4} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (ICons x10 INil) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (ICons x10
                                       INil) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge (ICons
                             x10 INil)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 (INil))} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x10 (INil)) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (ICons x10 INil) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (ICons x10
                                       INil) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge (ICons
                             x10 x15)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x15)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x15)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (ICons x10 x15) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (ICons x10
                                       x15) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (merge (ICons
                             x10 x15)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x15)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x15)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x10 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x23 == ilen x24 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems _v == [x10] + ielems x23, ielems x23 == ielems x24 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ielems _v == ielems xs + ielems ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x23 == ilen x24 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems _v == [x10] + ielems x23 && (ielems x23 == ielems x24 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ielems _v == ielems xs + ielems ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (ICons x10 x15) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (ICons x10
                                       x15) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge (ICons
                             x10 x11)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x11)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x11)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (ICons x10 x11) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (ICons x10
                                       x11) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (merge (ICons
                             x10 x11)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x11)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x11)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (x24 == (ICons x10 x11) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x24 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x24 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x24 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x24 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x24 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (ICons x10 x11) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (ICons x10
                                       x11) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (merge INil
                      (ICons x14
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x14 (INil))} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: IList {A11|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A11 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3 && x14 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil (ICons x14 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge INil
                                (ICons x14 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
Checking ICons x10 (merge INil
                      (ICons x14
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x14 x15)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A11|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x15)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil (ICons x14 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge INil
                                (ICons x14 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
Checking ICons x10 (merge INil
                      (ICons x14
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x14 x11)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A11|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x11)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x14 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x11)) == [x14] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x14 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x11)) == [x14] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil (ICons x14 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge INil
                                (ICons x14 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (merge INil
                      (ICons x10
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x10 (INil))} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: IList {A11|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A11 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil (ICons x10 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge INil
                                (ICons x10 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
Checking ICons x10 (merge INil
                      (ICons x10
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x10 x15)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A11|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x15)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (18 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil (ICons x10 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge INil
                                (ICons x10 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A11 -> x27:IList {A11|x26 <= _v} -> {IList A11|_v == (ICons x26 x27)}
Checking ICons x10 (merge INil
                      (ICons x10
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|_v == (ICons x10 x11)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A11|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x11)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil (ICons x10 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge INil
                                (ICons x10 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A11|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A11|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A13|False}|_v == (INil)}
Checking ICons x10 (merge INil
                      (merge INil
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A13|False}|_v == (INil)} <: {IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A13
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A11|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A11 WITH {a|U4} PRODUCING {a|U3}
UNIFY A13 WITH {a|U3} PRODUCING {a|U4}
UNIFY A12 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U5}
A13 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U5}
A13 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen x25 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems x25 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen x25 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems x25 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil (merge INil INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge INil
                                (merge INil INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A11|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A11|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (merge INil
                      (merge INil
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A11|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A11 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen x25 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems x25 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen x25 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems x25 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil (merge INil x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge INil
                                (merge INil x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A11|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A11|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (merge INil
                      (merge x15
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A11|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A11 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U3}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen x25 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems x25 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen x25 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems x25 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil (merge x15 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge INil
                                (merge x15 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A10|False}|_v == (INil)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A11|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A11|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
Checking ICons x10 (merge INil
                      (merge x15
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A11|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A11|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A11|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A11|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A11|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A10|False}|_v == (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x25 && ielems _v == ielems (INil) + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen (INil) + ilen x25 && ielems x23 == ielems (INil) + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen (INil) + ilen x25, ilen x25 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems (INil) + ielems x25, ielems x25 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen (INil) + ilen x25 && (ilen x25 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems (INil) + ielems x25 && (ielems x25 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           INil (merge x15 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge INil
                                (merge x15 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge x15
                      (ICons x14
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 (INil))}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 (INil))} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x14 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 (INil))} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x14 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen ((ICons x14 (INil))) == 1 + ilen (INil), ilen (INil) == 0, ielems x23 == ielems x15 + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems ((ICons x14 (INil))) == [x14] + ielems (INil), ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x14 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen ((ICons x14 (INil))) == 1 + ilen (INil) && (ilen (INil) == 0 && (ielems x23 == ielems x15 + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems ((ICons x14 (INil))) == [x14] + ielems (INil) && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 (ICons x14 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge x15 (ICons
                                           x14 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (merge x15
                      (ICons x14
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 x15)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x15)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x15)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x14 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x15 + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x14 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x15 + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 (ICons x14 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge x15 (ICons
                                           x14 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (merge x15
                      (ICons x14
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x14 x11)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x14 x11)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x14} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x11)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x14 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x14 <= _v
Strengthening: C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> True && x14 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x10 <= _v, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x14 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(True && x14 <= _v)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
{x14 <= x10}
Pruned valuations:
{x14 <= x10}
Diffs: (1)
[C3 -> {}, C4 -> {x14 <= x10}, M1 -> {}, M3 -> {}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (23 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (23 1)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
Strengthening: C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> True && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x10 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(True && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v]
Optimal valuations:
{x10 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C3 -> {}, C4 -> {}, M1 -> {}, M3 -> {}, U4 -> {x10 <= _v}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x10 <= _v}, U5 -> {}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
Strengthening: C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, x14 <= _v, x14 <= x10, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (x14 <= _v && (x14 <= x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= x14]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 (ICons x14 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge x15 (ICons
                                           x14 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge x15
                      (ICons x10
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 (INil))}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 (INil))} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4 && x10 <= _v} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 (INil))} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 (INil)) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x10 (INil)), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 (INil))) == 1 + ilen (INil), ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x15 + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 (INil))) == [x10] + ielems (INil), ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x10 (INil)) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 (INil))) == 1 + ilen (INil) && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x15 + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 (INil))) == [x10] + ielems (INil) && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 (ICons x10 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge x15 (ICons
                                           x10 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (merge x15
                      (ICons x10
                         x15)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 x15)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x15)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x15)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 5)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (19 5)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x15) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x10 x15), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x10 x15)) == 1 + ilen x15, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x15 + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x10 x15)) == [x10] + ielems x15, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x10 x15) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x10 x15)) == 1 + ilen x15 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x15 + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x10 x15)) == [x10] + ielems x15 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 (ICons x10 x15)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge x15 (ICons
                                           x10 x15))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x26:A10 -> x27:IList {A10|x26 <= _v} -> {IList A10|_v == (ICons x26 x27)}
Checking ICons x10 (merge x15
                      (ICons x10
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|_v == (ICons x10 x11)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|_v == (ICons x10 x11)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: IList {A10|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A10 ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5 && x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x11)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 2)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
Strengthening: C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), x25 == (ICons x10 x11), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen x23 == ilen x15 + ilen x25, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems _v == [x10] + ielems x23, ielems x23 == ielems x15 + ielems x25, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ielems _v == ielems xs + ielems ys
assumption !(x10 <= x14 && x14 <= x10) && (x25 == (ICons x10 x11) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen x23 == ilen x15 + ilen x25 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems _v == [x10] + ielems x23 && (ielems x23 == ielems x15 + ielems x25 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))))))
mustHave !(ielems _v == ielems xs + ielems ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 (ICons x10 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge x15 (ICons
                                           x10 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (merge x15
                      (merge INil
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A10 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen (INil) && ielems x25 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen x25 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x15 + ielems x25, ielems x25 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen x25 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x15 + ielems x25 && (ielems x25 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 (merge INil INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge x15 (merge
                                           INil INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge x15
                      (merge INil
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen (INil) + ilen x11 && ielems x25 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen x25 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x15 + ielems x25, ielems x25 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen x25 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x15 + ielems x25 && (ielems x25 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 (merge INil x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge x15 (merge
                                           INil x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge x15
                      (merge x15
                         INil)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil)} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen (INil) && ielems x25 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen x25 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x15 + ielems x25, ielems x25 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen x25 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x15 + ielems x25 && (ielems x25 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 (merge x15 INil)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge x15 (merge
                                           x15 INil))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
Checking ICons x10 (merge x15
                      (merge x15
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x25:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x25:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x25 && ielems _v == ielems x15 + ielems x25} <: IList ()
merge, x10, x11, x14, x15, x25, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((ilen x25 == ilen x15 + ilen x11 && ielems x25 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x15 + ilen x25, ilen x25 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x15 + ielems x25, ielems x25 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x25 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x15 + ilen x25 && (ilen x25 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x15 + ielems x25 && (ielems x25 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           x15 (merge x15 x11)) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge x15 (merge
                                           x15 x11))
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A13|False}|_v == (INil)}
Checking ICons x10 (merge (merge
                             INil INil)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A13|False}|_v == (INil)} <: LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A13
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A13 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U5} PRODUCING {a|U4}
UNIFY A11 WITH {a|U5} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U5}
A12 -> {a|U4}
A13 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U5}
A12 -> {a|U4}
A13 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen x24 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems x24 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen x24 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems x24 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (merge INil INil) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (merge
                                       INil INil) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (merge (merge
                             INil INil)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A10 WITH {a|U4} PRODUCING {a|U3}
UNIFY A12 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U3}
A11 -> {a|U5}
A12 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil) && ielems _v == ielems (INil) + ielems (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen (INil) && ielems x24 == ielems (INil) + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen x24 == ilen (INil) + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems x11, ielems x24 == ielems (INil) + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen x24 == ilen (INil) + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems x11 && (ielems x24 == ielems (INil) + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (merge INil INil) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (merge
                                       INil INil) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (merge (merge
                             INil x11)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A12 WITH {a|U4} PRODUCING {a|U3}
UNIFY A10 WITH {a|U4} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (20 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen x24 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems x24 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen x24 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems x24 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (merge INil x11) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (merge
                                       INil x11) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge (merge
                             INil x11)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11 && ielems _v == ielems (INil) + ielems x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen (INil) + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen (INil) >= 0 && ilen (INil) < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen (INil) + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen (INil) + ilen x11 && ielems x24 == ielems (INil) + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen x24 == ilen (INil) + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems x11, ielems x24 == ielems (INil) + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen x24 == ilen (INil) + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems x11 && (ielems x24 == ielems (INil) + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (merge INil x11) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (merge
                                       INil x11) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A12|False}|_v == (INil)}
Checking ICons x10 (merge (merge
                             x15 INil)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A12|False}|_v == (INil)} <: LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A12 WITH {a|U4} PRODUCING {a|U3}
UNIFY A10 WITH {a|U4} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A12 -> {a|U3}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen x24 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems x24 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen x24 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems x24 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (merge x15 INil) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (merge x15
                                       INil) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge (merge
                             x15 INil)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A10 WITH {a|U3} PRODUCING {a|U4}
UNIFY A11 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U4}
A11 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U4} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil) && ielems _v == ielems x15 + ielems (INil)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen (INil)} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen (INil) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 3)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 3)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen (INil) && ielems x24 == ielems x15 + ielems (INil)) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen x24 == ilen x15 + ilen (INil), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems x11, ielems x24 == ielems x15 + ielems (INil), ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen x24 == ilen x15 + ilen (INil) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems x11 && (ielems x24 == ielems x15 + ielems (INil) && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (merge x15 INil) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (merge x15
                                       INil) x11)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
INSTANTIATE <a> . {IList a|_v == (INil)}
INTO {IList {A11|False}|_v == (INil)}
Checking ICons x10 (merge (merge
                             x15 x11)
                      INil) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {A11|False}|_v == (INil)} <: LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U3}
UNIFY A11 WITH {a|U3} PRODUCING {a|U4}
UNIFY A10 WITH {a|U3} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U4}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U3}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (INil)} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|False} <: {a|U3} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen (INil) && ielems _v == ielems x24 + ielems (INil)} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 0} <: {IList|ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (ilen _v == 0 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (U3 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (21 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen (INil) && ielems x23 == ielems x24 + ielems (INil)) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == []
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen (INil), ilen x24 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ilen (INil) == 0, ielems x23 == ielems x24 + ielems (INil), ielems x24 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ielems (INil) == [], ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen (INil) && (ilen x24 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ilen (INil) == 0 && (ielems x23 == ielems x24 + ielems (INil) && (ielems x24 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ielems (INil) == [] && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (merge x15 x11) INil) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (merge x15
                                       x11) INil)
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x22:A8 -> x23:IList {A8|x22 <= _v} -> {IList A8|_v == (ICons x22 x23)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x24:{IList A9|ilen _v >= 0 && ilen _v <= ilen xs} -> x25:{IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A9|ilen _v == ilen x24 + ilen x25 && ielems _v == ielems x24 + ielems x25}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x26:{IList A10|ilen _v >= 0 && ilen _v <= ilen xs} -> x27:{IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x26 >= 0 && ilen x26 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A10|ilen _v == ilen x26 + ilen x27 && ielems _v == ielems x26 + ielems x27}
Checking ICons x10 (merge (merge
                             x15 x11)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x23:(LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11}) IN {IList A8|_v == (ICons x10 x23)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList {A8|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x24:({IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11}) IN {IList A9|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList A10|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList A9|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: {IList A10|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: {IList A10|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys |- A10
merge, x10, x11, x14, x15, xs, ys |- A9
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: A8 ()
merge, x10, x11, x14, x15, xs, ys |- A8
merge, x10, x11, x14, x15, xs, ys |- C4
UNIFY A8 WITH a PRODUCING {a|U3}
UNIFY A9 WITH {a|U3 && x10 <= _v} PRODUCING {a|U4}
UNIFY A10 WITH {a|U4} PRODUCING {a|U5}
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C4
merge, x10, x11, x14, x15, xs, ys |- {a|U3}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|_v == x10} <: {a|U3} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U4}
merge, x10, x11, x14, x15, xs, ys |- {a|U5}
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x15} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x14 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U5} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11 && ielems _v == ielems x15 + ielems x11} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {a|U5} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|x10 <= _v} <: {a|U4} ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x24 + ilen x11 && ielems _v == ielems x24 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x24, xs, ys True, C3, C4, M1, M3 |- {a|U4} <: {a|U3 && x10 <= _v} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x10 x23)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {a|U3} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == ilen x15 + ilen x11} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x23} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x23, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x10] + ielems x23} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (ilen _v == ilen x15 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x24 >= 0 && ilen x24 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (ielems _v == [x10] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 4)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {}, U5 -> {}] (22 4)
Invalid Constraint: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Strengthening: C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x24 + ilen x11 && ielems x23 == ielems x24 + ielems x11) && ((ilen x24 == ilen x15 + ilen x11 && ielems x24 == ielems x15 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen _v == 1 + ilen x23, ilen x23 == ilen x24 + ilen x11, ilen x24 == ilen x15 + ilen x11, ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems x23 == ielems x24 + ielems x11, ielems x24 == ielems x15 + ielems x11, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen x23 >= 0, ilen x24 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: ilen _v == ilen xs + ilen ys
assumption !(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x23 == ilen x24 + ilen x11 && (ilen x24 == ilen x15 + ilen x11 && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems x23 == ielems x24 + ielems x11 && (ielems x24 == ielems x15 + ielems x11 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x24 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))))))))
mustHave !(ilen _v == ilen xs + ilen ys)
qualsList [x14 != x10
          ,x10 <= x14
          ,x14 <= x10]
Optimal valuations:
Pruned valuations:
Diffs: (0)
TYPE ERROR: Cannot find sufficiently strong refinements
when checking ICons x10 (merge
                           (merge x15 x11) x11) ::
{IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys}
in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ICons x10 (merge (merge x15
                                       x11) x11)
Checking program ICons x14
                   (merge x15 (ICons x10 x11))
Checking ICons x14 (merge x15
                      (ICons x10
                         x11)) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C4, M1, M3 |- LET x17:(LET x19:({IList A7|_v == (ICons x10 x11)}) IN {IList A6|ilen _v == ilen x15 + ilen x19 && ielems _v == ielems x15 + ielems x19}) IN {IList A5|_v == (ICons x14 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C3, C4, M1, M3 |- {IList|_v == (ICons x14 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C3, C4, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C3, C4, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C3, C4, M1, M3 |- {IList|ielems _v == [x14] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C4 && (M1 && (M3 && (x19 == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x19 && ielems x17 == ielems x15 + ielems x19) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x19 == (ICons x10 x11) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x19 && ielems x17 == ielems x15 + ielems x19) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}] (26 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}] (26 0)
Typing Constraints
Type assignment
A10 -> {a|U5}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}] (26 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}] (26 0)
Auxiliary goals are:
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x28:A11 -> x29:IList {A11|x28 <= _v} -> {IList A11|_v == (ICons x28 x29)}
INSTANTIATE <a> . x0:{IList a|ilen _v >= 0 && ilen _v <= ilen xs} -> x1:{IList a|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x0 >= 0 && ilen x0 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList a|ilen _v == ilen x0 + ilen x1 && ielems _v == ielems x0 + ielems x1}
INTO x30:{IList A12|ilen _v >= 0 && ilen _v <= ilen xs} -> x31:{IList A12|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x30 >= 0 && ilen x30 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} -> {IList A12|ilen _v == ilen x30 + ilen x31 && ielems _v == ielems x30 + ielems x31}
INSTANTIATE <a> . x:a -> xs:IList {a|x <= _v} -> {IList a|_v == (ICons x xs)}
INTO x32:A13 -> x33:IList {A13|x32 <= _v} -> {IList A13|_v == (ICons x32 x33)}
Checking ICons x10 (merge (ICons
                             x14 x15)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else 
                if x14 <= x10
                  then ICons x14 (merge x15 (ICons
                                               x10 x11))
                  else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- LET x29:(LET x30:({IList A13|_v == (ICons x14 x15)}) IN {IList A12|ilen _v == ilen x30 + ilen x11 && ielems _v == ielems x30 + ielems x11}) IN {IList A11|_v == (ICons x10 x29)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- LET x30:({IList A13|_v == (ICons x14 x15)}) IN {IList A12|ilen _v == ilen x30 + ilen x11 && ielems _v == ielems x30 + ielems x11} <: IList {A11|x10 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {IList {a|x10 <= _v}|_v == x11} <: LET x30:({IList A13|_v == (ICons x14 x15)}) IN {IList A12|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x30 >= 0 && ilen x30 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {IList A13|_v == (ICons x14 x15)} <: {IList A12|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {IList {a|x14 <= _v}|_v == x15} <: IList {A13|x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {a|_v == x14} <: A13 ()
merge, x10, x11, x14, x15, xs, ys |- A13
merge, x10, x11, x14, x15, xs, ys |- A12
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {a|_v == x10} <: A11 ()
merge, x10, x11, x14, x15, xs, ys |- A11
merge, x10, x11, x14, x15, xs, ys |- C6
UNIFY A11 WITH a PRODUCING {a|U6}
UNIFY A12 WITH {a|U6 && x10 <= _v} PRODUCING {a|U7}
UNIFY A13 WITH {a|U7} PRODUCING {a|U8}
Type assignment
A10 -> {a|U5}
A11 -> {a|U6}
A12 -> {a|U7}
A13 -> {a|U8}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U6}
A12 -> {a|U7}
A13 -> {a|U8}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, xs, ys |- C6
merge, x10, x11, x14, x15, xs, ys |- {a|U6}
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {a|_v == x10} <: {a|U6} ()
merge, x10, x11, x14, x15, xs, ys |- {a|U7}
merge, x10, x11, x14, x15, xs, ys |- {a|U8}
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {a|_v == x14} <: {a|U8} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {IList|_v == x15} <: IList ()
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {a|x14 <= _v} <: {a|U8 && x14 <= _v} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {IList|_v == (ICons x14 x15)} <: {IList|ilen _v >= 0 && ilen _v <= ilen xs} ()
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {a|U8} <: {a|U7} ()
merge, x10, x11, x14, x15, x30, xs, ys True, C3, C5, C6, M1, M3 |- {IList|_v == x11} <: {IList|(ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x30 >= 0 && ilen x30 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))} ()
merge, x10, x11, x14, x15, x30, xs, ys True, C3, C5, C6, M1, M3 |- {a|x10 <= _v} <: {a|U7} ()
merge, x10, x11, x14, x15, x30, xs, ys True, C3, C5, C6, M1, M3 |- {IList|ilen _v == ilen x30 + ilen x11 && ielems _v == ielems x30 + ielems x11} <: IList ()
merge, x10, x11, x14, x15, x30, xs, ys True, C3, C5, C6, M1, M3 |- {a|U7} <: {a|U6 && x10 <= _v} ()
merge, x10, x11, x14, x15, x29, xs, ys True, C3, C5, C6, M1, M3 |- {IList|_v == (ICons x10 x29)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x29, xs, ys True, C3, C5, C6, M1, M3 |- {a|U6} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- {IList|ilen _v == 1 + ilen x15} <: {IList|ilen _v <= ilen xs && ilen _v >= 0} ()
addSplitConstraint merge, x10, x11, x14, x15, x29, xs, ys True, C3, C5, C6, M1, M3 |- {IList|ilen _v == 1 + ilen x29} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x29, xs, ys True, C3, C5, C6, M1, M3 |- {IList|ielems _v == [x10] + ielems x29} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C5 && (C6 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U6
  C3 && (C5 && (C6 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U8
  C3 && (C5 && (C6 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U8 && x14 <= _v
  C3 && (C5 && (C6 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C5 && (C6 && (M1 && (M3 && (U8 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U7
  C3 && (C5 && (C6 && (M1 && (M3 && (_v == x11 && (x30 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x30 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x30 >= 0 && ilen x30 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C5 && (C6 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U7
  C3 && (C5 && (C6 && (M1 && (M3 && (U7 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U6 && x10 <= _v
  C3 && (C5 && (C6 && (M1 && (M3 && (x30 == (ICons x14 x15) && (ilen _v == 1 + ilen x29 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x29 >= 0 && (ilen x30 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x29 == ilen x30 + ilen x11 && ielems x29 == ielems x30 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C5 && (C6 && (M1 && (M3 && (x30 == (ICons x14 x15) && (ielems _v == [x10] + ielems x29 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x29 >= 0 && (ilen x30 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x29 == ilen x30 + ilen x11 && ielems x29 == ielems x30 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C5 -> {!(x14 <= x10)}
  C6 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
  U6 -> {x14 <= _v, x10 <= _v}
  U7 -> {x14 <= _v, x10 <= _v}
  U8 -> {x14 <= _v, x10 <= _v}
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {}, U8 -> {}] (35 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {}, U8 -> {}] (35 1)
Invalid Constraint: C3 && (C5 && (C6 && (M1 && (M3 && (U7 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U6 && x10 <= _v
Strengthening: C3 && (C5 && (C6 && (M1 && (M3 && (U7 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> True && x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x14 <= x10), !(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: True && x10 <= _v
assumption !(x14 <= x10) && (!(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(True && x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v]
Optimal valuations:
{x10 <= _v}
{x14 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C3 -> {}, C5 -> {}, C6 -> {}, M1 -> {}, M3 -> {}, U7 -> {x10 <= _v}]
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {x10 <= _v}, U8 -> {}] (35 1)
Chosen candidate: 0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {x10 <= _v}, U8 -> {}] (35 1)
Invalid Constraint: C3 && (C5 && (C6 && (M1 && (M3 && (U8 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U7
Strengthening: C3 && (C5 && (C6 && (M1 && (M3 && (U8 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> x10 <= _v
Instantiated axioms:
ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15
All assumptions:
!(x14 <= x10), !(x10 <= x14 && x14 <= x10), xs == (ICons x14 x15), ys == (ICons x10 x11), ilen ((ICons x10 x11)) == 1 + ilen x11, ilen ((ICons x14 x15)) == 1 + ilen x15, ielems ((ICons x10 x11)) == [x10] + ielems x11, ielems ((ICons x14 x15)) == [x14] + ielems x15, ilen x11 >= 0, ilen x15 >= 0, ilen xs >= 0, ilen ys >= 0, forall _x . _x in ielems x11 ==> x10 <= _x, forall _x . _x in ielems x15 ==> x14 <= _x
RHS: x10 <= _v
assumption !(x14 <= x10) && (!(x10 <= x14 && x14 <= x10) && (xs == (ICons x14 x15) && (ys == (ICons x10 x11) && (ilen ((ICons x10 x11)) == 1 + ilen x11 && (ilen ((ICons x14 x15)) == 1 + ilen x15 && (ielems ((ICons x10 x11)) == [x10] + ielems x11 && (ielems ((ICons x14 x15)) == [x14] + ielems x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))
mustHave !(x10 <= _v)
qualsList [x14 != x10
          ,x10 <= _v
          ,x10 <= x14
          ,x14 <= _v]
Optimal valuations:
{x10 <= _v}
{x14 <= _v}
Pruned valuations:
{x10 <= _v}
Diffs: (1)
[C3 -> {}, C5 -> {}, C6 -> {}, M1 -> {}, M3 -> {}, U8 -> {x10 <= _v}]
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {x10 <= _v}, U8 -> {x10 <= _v}] (36 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {x10 <= _v}, U8 -> {x10 <= _v}] (36 0)
Checking program ICons x10
                   (merge (ICons x14 x15) x11)
Checking ICons x10 (merge (ICons
                             x14 x15)
                      x11) :: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} in
\xs . \ys . 
    match ys with
      ICons x10 x11 -> 
        match xs with
          ICons x14 x15 -> 
            if (x10 <= x14) && (x14 <= x10)
              then ICons x14 (ICons x14 (merge
                                           x15 x11))
              else 
                if x14 <= x10
                  then ICons x14 (merge x15 (ICons
                                               x10 x11))
                  else ??
Typing Constraints
merge, x10, x11, x14, x15, xs, ys True, C3, C5, C6, M1, M3 |- LET x17:(LET x18:({IList A7|_v == (ICons x14 x15)}) IN {IList A6|ilen _v == ilen x18 + ilen x11 && ielems _v == ielems x18 + ielems x11}) IN {IList A5|_v == (ICons x10 x17)} <: {IList a|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
Type assignment
A10 -> {a|U5}
A11 -> {a|U6}
A12 -> {a|U7}
A13 -> {a|U8}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
merge, x10, x11, x14, x15, x17, xs, ys True, C3, C5, C6, M1, M3 |- {IList|_v == (ICons x10 x17)} <: {IList|ilen _v == ilen xs + ilen ys && ielems _v == ielems xs + ielems ys} ()
merge, x10, x11, x14, x15, x17, xs, ys True, C3, C5, C6, M1, M3 |- {a|U0} <: a ()
Pred assignment
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C3, C5, C6, M1, M3 |- {IList|ilen _v == 1 + ilen x17} <: {IList|ilen _v == ilen xs + ilen ys} ()
addSplitConstraint merge, x10, x11, x14, x15, x17, xs, ys True, C3, C5, C6, M1, M3 |- {IList|ielems _v == [x10] + ielems x17} <: {IList|ielems _v == ielems xs + ielems ys} ()
Constraints
  C3 && (C5 && (C6 && (M1 && (M3 && (x18 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x18 + ilen x11 && ielems x17 == ielems x18 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C5 && (C6 && (M1 && (M3 && (x18 == (ICons x14 x15) && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x18 + ilen x11 && ielems x17 == ielems x18 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ielems _v == ielems xs + ielems ys
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C5 -> {!(x14 <= x10)}
  C6 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
  U6 -> {x14 <= _v, x10 <= _v}
  U7 -> {x14 <= _v, x10 <= _v}
  U8 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {x10 <= _v}, U8 -> {x10 <= _v}] (38 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {x10 <= _v}, U8 -> {x10 <= _v}] (38 0)
Typing Constraints
Type assignment
A10 -> {a|U5}
A11 -> {a|U6}
A12 -> {a|U7}
A13 -> {a|U8}
A3 -> a
A4 -> a
A5 -> {a|U0}
A6 -> {a|U1}
A7 -> {a|U2}
A8 -> {a|U3}
A9 -> {a|U4}
Simple Constraints
Pred assignment
Constraints
QMap
  C0 -> {}
  C1 -> {}
  C2 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C3 -> {!(x10 <= x14 && x14 <= x10)}
  C4 -> {x14 <= x10, x14 != x10, x10 <= x14}
  C5 -> {!(x14 <= x10)}
  C6 -> {x14 <= x10, x14 != x10, x10 <= x14}
  M0 -> {ys == (INil), xs == (INil)}
  M1 -> {ys == (ICons x10 x11)}
  M2 -> {xs == (INil)}
  M3 -> {xs == (ICons x14 x15)}
  U0 -> {x14 <= _v, x10 <= _v}
  U1 -> {x14 <= _v, x10 <= _v}
  U2 -> {x14 <= _v, x10 <= _v}
  U3 -> {x14 <= _v, x10 <= _v}
  U4 -> {x14 <= _v, x10 <= _v}
  U5 -> {x14 <= _v, x10 <= _v}
  U6 -> {x14 <= _v, x10 <= _v}
  U7 -> {x14 <= _v, x10 <= _v}
  U8 -> {x14 <= _v, x10 <= _v}
Checking consistency
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {x10 <= _v}, U8 -> {x10 <= _v}] (38 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {x10 <= _v}, U8 -> {x10 <= _v}] (38 0)
Auxiliary goals are:
Re-checking candidates after updating C5
Checking validity
  C3 && (C5 && (C6 && (M1 && (M3 && (U7 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U6 && x10 <= _v
  C3 && (C5 && (C6 && (M1 && (M3 && (U8 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U7
  C3 && (C5 && (C6 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U6
  C3 && (C5 && (C6 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U8
  C3 && (C5 && (C6 && (M1 && (M3 && (_v == x11 && (x30 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x30 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x30 >= 0 && ilen x30 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C5 && (C6 && (M1 && (M3 && (x18 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x18 + ilen x11 && ielems x17 == ielems x18 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C5 && (C6 && (M1 && (M3 && (x18 == (ICons x14 x15) && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x18 + ilen x11 && ielems x17 == ielems x18 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ielems _v == ielems xs + ielems ys
  C3 && (C5 && (C6 && (M1 && (M3 && (x30 == (ICons x14 x15) && (ilen _v == 1 + ilen x29 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x29 >= 0 && (ilen x30 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x29 == ilen x30 + ilen x11 && ielems x29 == ielems x30 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C5 && (C6 && (M1 && (M3 && (x30 == (ICons x14 x15) && (ielems _v == [x10] + ielems x29 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x29 >= 0 && (ilen x30 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x29 == ilen x30 + ilen x11 && ielems x29 == ielems x30 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ielems _v == ielems xs + ielems ys
  C3 && (C5 && (C6 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C5 && (C6 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U7
  C3 && (C5 && (C6 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U8 && x14 <= _v
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {!(x10 <= x14 && x14 <= x10)}, C4 -> {x14 <= x10}, C5 -> {}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {x10 <= _v}, U8 -> {x10 <= _v}] (38 0)
Remaining Candidates (0)
TYPE ERROR: Re-checking candidates failed
Re-checking candidates after updating C3
Checking validity
  C3 && (C4 && (M1 && (M3 && (U4 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3 && x14 <= _v
  C3 && (C4 && (M1 && (M3 && (U5 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C4 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5
  C3 && (C4 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U3
  C3 && (C4 && (M1 && (M3 && (_v == x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v >= 0 && ilen _v <= ilen xs
  C3 && (C4 && (M1 && (M3 && (x19 == (ICons x10 x11) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x19 && ielems x17 == ielems x15 + ielems x19) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x19 == (ICons x10 x11) && (ielems _v == [x14] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x19 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x15 + ilen x19 && ielems x17 == ielems x15 + ielems x19) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ilen _v == 1 + ilen x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C4 && (M1 && (M3 && (x25 == (ICons x10 x11) && (ielems _v == [x14] + ielems x23 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x23 >= 0 && (ilen x25 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x23 == ilen x15 + ilen x25 && ielems x23 == ielems x15 + ielems x25) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))))))) ==> ielems _v == ielems xs + ielems ys
  C3 && (C4 && (M1 && (M3 && (ilen _v == 1 + ilen x11 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> ilen _v <= ilen ys && (ilen _v >= 0 && ((ilen x15 >= 0 && ilen x15 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys)))
  C3 && (C4 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U5 && x10 <= _v
  C3 && (C4 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x)))))))))) ==> U4
  C3 && (C5 && (C6 && (M1 && (M3 && (U7 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U6 && x10 <= _v
  C3 && (C5 && (C6 && (M1 && (M3 && (U8 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U7
  C3 && (C5 && (C6 && (M1 && (M3 && (_v == x10 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U6
  C3 && (C5 && (C6 && (M1 && (M3 && (_v == x14 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U8
  C3 && (C5 && (C6 && (M1 && (M3 && (_v == x11 && (x30 == (ICons x14 x15) && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x30 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))) ==> (ilen _v >= 0 && ilen _v <= ilen ys) && ((ilen x30 >= 0 && ilen x30 < ilen xs) || (ilen _v >= 0 && ilen _v < ilen ys))
  C3 && (C5 && (C6 && (M1 && (M3 && (x18 == (ICons x14 x15) && (ilen _v == 1 + ilen x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x18 + ilen x11 && ielems x17 == ielems x18 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C5 && (C6 && (M1 && (M3 && (x18 == (ICons x14 x15) && (ielems _v == [x10] + ielems x17 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x17 >= 0 && (ilen x18 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x17 == ilen x18 + ilen x11 && ielems x17 == ielems x18 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ielems _v == ielems xs + ielems ys
  C3 && (C5 && (C6 && (M1 && (M3 && (x30 == (ICons x14 x15) && (ilen _v == 1 + ilen x29 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x29 >= 0 && (ilen x30 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x29 == ilen x30 + ilen x11 && ielems x29 == ielems x30 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ilen _v == ilen xs + ilen ys
  C3 && (C5 && (C6 && (M1 && (M3 && (x30 == (ICons x14 x15) && (ielems _v == [x10] + ielems x29 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen x29 >= 0 && (ilen x30 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((ilen x29 == ilen x30 + ilen x11 && ielems x29 == ielems x30 + ielems x11) && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))))))) ==> ielems _v == ielems xs + ielems ys
  C3 && (C5 && (C6 && (M1 && (M3 && (ilen _v == 1 + ilen x15 && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> ilen _v <= ilen xs && ilen _v >= 0
  C3 && (C5 && (C6 && (M1 && (M3 && (x10 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U7
  C3 && (C5 && (C6 && (M1 && (M3 && (x14 <= _v && (ilen x11 >= 0 && (ilen x15 >= 0 && (ilen xs >= 0 && (ilen ys >= 0 && ((forall _x . _x in ielems x11 ==> x10 <= _x) && (forall _x . _x in ielems x15 ==> x14 <= _x))))))))))) ==> U8 && x14 <= _v
Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {x10 <= _v}, U8 -> {x10 <= _v}] (38 0)
Remaining Candidates (1)
  0: [C0 -> {}, C1 -> {}, C2 -> {x10 <= x14, x14 <= x10}, C3 -> {}, C4 -> {x14 <= x10}, C5 -> {!(x14 <= x10)}, C6 -> {}, M0 -> {ys == (INil)}, M1 -> {ys == (ICons x10 x11)}, M2 -> {xs == (INil)}, M3 -> {xs == (ICons x14 x15)}, U0 -> {}, U1 -> {x14 <= _v}, U2 -> {x14 <= _v}, U3 -> {}, U4 -> {x14 <= _v}, U5 -> {x14 <= _v}, U6 -> {}, U7 -> {x10 <= _v}, U8 -> {x10 <= _v}] (38 0)
